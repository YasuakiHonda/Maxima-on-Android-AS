<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on August, 17 2018 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima 5.41.0 Manual: 85. to_poly_solve</title>

<meta name="description" content="Maxima 5.41.0 Manual: 85. to_poly_solve">
<meta name="keywords" content="Maxima 5.41.0 Manual: 85. to_poly_solve">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="figures/favicon.ico">


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="to_005fpoly_005fsolve_002dpkg"></a>
<a name="SEC394"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_84.html#SEC393" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC395" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC388" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_86.html#SEC396" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_89.html#SEC426" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 85. to_poly_solve </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC395">85.1 Functions and Variables for to_poly_solve</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><a name="Item_003a-Functions-and-Variables-for-to_005fpoly_005fsolve"></a>
</p><hr size="6">
<a name="Functions-and-Variables-for-to_005fpoly_005fsolve"></a>
<a name="SEC395"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC394" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_86.html#SEC396" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC394" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC394" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_86.html#SEC396" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_89.html#SEC426" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 85.1 Functions and Variables for to_poly_solve </h2>

<p>The packages <code>to_poly</code> and <code>to_poly_solve</code> are experimental;
the specifications of the functions in these packages might change or
the some of the functions in these packages might be merged into other
Maxima functions.
</p>
<p>Barton Willis (Professor of Mathematics, University of Nebraska at
Kearney) wrote the <code>to_poly</code> and <code>to_poly_solve</code> packages and the
English language user documentation for these packages.
</p>
<p><a name="Item_003a-_0025and"></a>
</p><dl>
<dt><u>Operator:</u> <b>%and</b>
<a name="IDX2523"></a>
</dt>
<dd><p>The operator <code>%and</code> is a simplifying nonshort-circuited logical
conjunction.  Maxima simplifies an <code>%and</code> expression to either true,
false, or a logically equivalent, but simplified, expression.  The
operator <code>%and</code> is associative, commutative, and idempotent.  Thus
when <code>%and</code> returns a noun form, the arguments of <code>%and</code> form
a non-redundant sorted list; for example
</p>
<pre class="example">(%i1) a %and (a %and b);
(%o1)                       a %and b
</pre>
<p>If one argument to a conjunction is the <i>explicit</i> the negation of another
argument, <code>%and</code> returns false:
</p>
<pre class="example">(%i2) a %and (not a);
(%o2)                         false
</pre>
<p>If any member of the conjunction is false, the conjunction simplifies
to false even if other members are manifestly non-boolean; for example
</p>
<pre class="example">(%i3) 42 %and false;
(%o3)                         false
</pre>
<p>Any argument of an <code>%and</code> expression that is an inequation (that
is, an inequality or equation), is simplified using the Fourier
elimination package.  The Fourier elimination simplifier has a
pre-processor that converts some, but not all, nonlinear inequations
into linear inequations; for example the Fourier elimination code
simplifies <code>abs(x) + 1 &gt; 0</code> to true, so
</p>
<pre class="example">(%i4) (x &lt; 1) %and (abs(x) + 1 &gt; 0);
(%o4)                         x &lt; 1
</pre>
<p><b>Notes</b>  
</p><ul>
<li> The option variable <code>prederror</code> does <i>not</i> alter the
simplification <code>%and</code> expressions.

</li><li> To avoid operator precedence errors, compound expressions
involving the operators <code>%and, %or</code>, and <code>not</code> should be
fully parenthesized.

</li><li> The Maxima operators <code>and</code> and <code>or</code> are both
short-circuited.  Thus <code>and</code> isn't associative or commutative.

</li></ul>

<p><b>Limitations</b> The conjunction <code>%and</code> simplifies inequations
<i>locally, not globally</i>.  This means that conjunctions such as
</p>
<pre class="example">(%i5) (x &lt; 1) %and (x &gt; 1);
(%o5)                 (x &gt; 1) %and (x &lt; 1)
</pre>
<p>do <i>not</i> simplify to false.  Also, the Fourier elimination code <i>ignores</i>
the fact database;
</p>
<pre class="example">(%i6) assume(x &gt; 5);
(%o6)                        [x &gt; 5]
(%i7) (x &gt; 1) %and (x &gt; 2);
(%o7)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>Finally, nonlinear inequations that aren't easily converted into an
equivalent linear inequation aren't simplified.
</p>
<p>There is no support for distributing <code>%and</code> over <code>%or</code>;
neither is there support for distributing a logical negation over
<code>%and</code>.
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Related functions</b> <code>%or, %if, and, or, not</code>
</p>
<p><b>Status</b> The operator <code>%and</code> is experimental; the
specifications of this function might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<p><a name="Item_003a-_0025if"></a>
</p><dl>
<dt><u>Operator:</u> <b>%if</b><i> (<var>bool</var>, <var>a</var>, <var>b</var>)</i>
<a name="IDX2524"></a>
</dt>
<dd><p>The operator <code>%if</code> is a simplifying conditional.  The
<i>conditional</i> <var>bool</var> should be boolean-valued.  When the
conditional is true, return the second argument; when the conditional is
false, return the third; in all other cases, return a noun form.
</p>
<p>Maxima inequations (either an inequality or an equality) are <i>not</i>
boolean-valued; for example, Maxima does <i>not</i> simplify <em>5 &lt; 6</em>
to true, and it does not simplify <em>5 = 6</em> to false; however, in
the context of a conditional to an <code>%if</code> statement, Maxima
<i>automatically</i> attempts to determine the truth value of an
inequation.  Examples:
</p>
<pre class="example">(%i1) f : %if(x # 1, 2, 8);
(%o1)                 %if(x - 1 # 0, 2, 8)
(%i2) [subst(x = -1,f), subst(x=1,f)];
(%o2)                        [2, 8]
</pre>
<p>If the conditional involves an inequation, Maxima simplifies it using
the Fourier elimination package.
</p>
<p><b>Notes</b> 
</p>
<ul>
<li> If the conditional is manifestly non-boolean, Maxima returns a noun form:
</li></ul>

<pre class="example">(%i3) %if(42,1,2);
(%o3)                     %if(42, 1, 2)
</pre>
<ul>
<li> The Maxima operator <code>if</code> is nary, the operator <code>%if</code> <i>isn't</i>
nary.
</li></ul>

<p><b>Limitations</b> The Fourier elimination code only simplifies nonlinear
inequations that are readily convertible to an equivalent linear
inequation.
</p>
<p><b>To use:</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status:</b> The operator <code>%if</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>
  
<p><a name="Item_003a-_0025or"></a>
</p><dl>
<dt><u>Operator:</u> <b>%or</b>
<a name="IDX2525"></a>
</dt>
<dd><p>The operator <code>%or</code> is a simplifying nonshort-circuited logical
disjunction.  Maxima simplifies an <code>%or</code> expression to either
true, false, or a logically equivalent, but simplified,
expression.  The operator <code>%or</code> is associative, commutative, and
idempotent.  Thus when <code>%or</code> returns a noun form, the arguments
of <code>%or</code> form a non-redundant sorted list; for example
</p>
<pre class="example">(%i1) a %or (a %or b);
(%o1)                        a %or b
</pre>
<p>If one member of the disjunction is the <i>explicit</i> the negation of another
member, <code>%or</code> returns true:
</p>
<pre class="example">(%i2) a %or (not a);
(%o2)                         true
</pre>
<p>If any member of the disjunction is true, the disjunction simplifies
to true even if other members of the disjunction are manifestly non-boolean;
for example
</p>
<pre class="example">(%i3) 42 %or true;
(%o3)                         true
</pre>
<p>Any argument of an <code>%or</code> expression that is an inequation (that
is, an inequality or equation), is simplified using the Fourier
elimination package.  The Fourier elimination code simplifies
<code>abs(x) + 1 &gt; 0</code> to true, so we have
</p>
<pre class="example">(%i4) (x &lt; 1) %or (abs(x) + 1 &gt; 0);
(%o4)                         true
</pre>
<p><b>Notes</b>  
</p><ul>
<li> The option variable <code>prederror</code> does <i>not</i> alter the 
simplification of <code>%or</code> expressions.

</li><li> You should parenthesize compound expressions involving the
operators <code>%and, %or</code>, and <code>not</code>; the binding powers of these
operators might not match your expectations.

</li><li> The Maxima operators <code>and</code> and <code>or</code> are both short-circuited.
Thus <code>or</code> isn't associative or commutative.

</li></ul>

<p><b>Limitations</b> The conjunction <code>%or</code> simplifies inequations
<i>locally, not globally</i>.  This means that conjunctions such as
</p>

<pre class="example">(%i1) (x &lt; 1) %or (x &gt;= 1);
(%o1) (x &gt; 1) %or (x &gt;= 1)
</pre>
<p>do <i>not</i> simplify to true.  Further, the Fourier elimination code ignores
the fact database;
</p>
<pre class="example">(%i2) assume(x &gt; 5);
(%o2)                        [x &gt; 5]
(%i3) (x &gt; 1) %and (x &gt; 2);
(%o3)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>Finally, nonlinear inequations that aren't easily converted into an
equivalent linear inequation aren't simplified.
</p>
<p>The algorithm that looks for terms that cannot both be false is weak;
also there is no support for distributing <code>%or</code> over <code>%and</code>;
neither is there support for distributing a logical negation over
<code>%or</code>.
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Related functions</b> <code>%or, %if, and, or, not</code>
</p>
<p><b>Status</b> The operator <code>%or</code> is experimental; the
specifications of this function might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<p><a name="complex_005fnumber_005fp"></a>
<a name="Item_003a-complex_005fnumber_005fp"></a>
</p><dl>
<dt><u>Function:</u> <b>complex_number_p</b><i> (<var>x</var>)</i>
<a name="IDX2526"></a>
</dt>
<dd><p>The predicate <code>complex_number_p</code> returns true if its argument is
either <code>a + %i * b</code>, <code>a</code>, <code>%i b</code>, or <code>%i</code>,
where <code>a</code> and <code>b</code> are either rational or floating point
numbers (including big floating point); for all other inputs,
<code>complex_number_p</code> returns false; for example
</p>
<pre class="example">(%i1) map('complex_number_p,[2/3, 2 + 1.5 * %i, %i]);
(%o1)                  [true, true, true]
(%i2) complex_number_p((2+%i)/(5-%i));
(%o2)                         false
(%i3) complex_number_p(cos(5 - 2 * %i));
(%o3)                         false
</pre>
<p><b>Related functions</b> <code>isreal_p</code>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The operator <code>complex_number_p</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="compose_005ffunctions"></a>
<a name="Item_003a-compose_005ffunctions"></a>
</p><dl>
<dt><u>Function:</u> <b>compose_functions</b><i> (<var>l</var>)</i>
<a name="IDX2527"></a>
</dt>
<dd><p>The function call <code>compose_functions(l)</code> returns a lambda form that is
the <i>composition</i> of the functions in the list <var>l</var>.  The functions are
applied from <i>right</i> to <i>left</i>; for example
</p>
<pre class="example">(%i1) compose_functions([cos, exp]);
                                        %g151
(%o1)             lambda([%g151], cos(%e     ))
(%i2) %(x);
                                  x
(%o2)                       cos(%e )
</pre>
<p>When the function list is empty, return the identity function:
</p>
<pre class="example">(%i3) compose_functions([]);
(%o3)                lambda([%g152], %g152)
(%i4)  %(x);
(%o4)                           x
</pre>
<p><b>Notes</b> 
</p><ul>
<li> When Maxima determines that a list member isn't a symbol or
a lambda form, <code>funmake</code> (<i>not</i> <code>compose_functions</code>)
signals an error:
</li></ul>

<pre class="example">(%i5) compose_functions([a &lt; b]);

funmake: first argument must be a symbol, subscripted symbol,
string, or lambda expression; found: a &lt; b
#0: compose_functions(l=[a &lt; b])(to_poly_solve.mac line 40)
 -- an error. To debug this try: debugmode(true);
</pre>
<ul>
<li> To avoid name conflicts, the independent variable is determined by the
function <code>new_variable</code>.

<pre class="example">(%i6) compose_functions([%g0]);
(%o6)              lambda([%g154], %g0(%g154))
(%i7) compose_functions([%g0]);
(%o7)              lambda([%g155], %g0(%g155))
</pre>
<p>Although the independent variables are different, Maxima is able to to
deduce that these lambda forms are semantically equal:
</p>
<pre class="example">(%i8) is(equal(%o6,%o7));
(%o8)                         true
</pre></li></ul>

<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b>  The function <code>compose_functions</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<p><a name="dfloat"></a>
<a name="Item_003a-dfloat"></a>
</p><dl>
<dt><u>Function:</u> <b>dfloat</b><i> (<var>x</var>)</i>
<a name="IDX2528"></a>
</dt>
<dd><p>The function <code>dfloat</code> is a similar to <code>float</code>, but the function
<code>dfloat</code> applies <code>rectform</code> when <code>float</code> fails to evaluate
to an IEEE double floating point number; thus
</p>
<pre class="example">(%i1) float(4.5^(1 + %i));
                               %i + 1
(%o1)                       4.5
(%i2) dfloat(4.5^(1 + %i));
(%o2)        4.48998802962884 %i + .3000124893895671
</pre>
<p><b>Notes</b> 
</p>
<ul>
<li> The rectangular form of an expression might be poorly suited for
numerical evaluation-for example, the rectangular form might
needlessly involve the difference of floating point numbers
(subtractive cancellation).


</li><li> The identifier <code>float</code> is both an option variable (default
value false) and a function name.


</li></ul>

<p><b>Related functions</b> <code>float, bfloat</code>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>dfloat</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="elim"></a>
<a name="Item_003a-elim"></a>
</p><dl>
<dt><u>Function:</u> <b>elim</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2529"></a>
</dt>
<dd><p>The function <code>elim</code> eliminates the variables in the set or list
<code>x</code> from the equations in the set or list <code>l</code>.  Each member
of <code>x</code> must be a symbol; the members of <code>l</code> can either be
equations, or expressions that are assumed to equal zero.
</p>
<p>The function <code>elim</code> returns a list of two lists; the first is
the list of expressions with the variables eliminated; the second
is the list of pivots; thus, the second list is a list of
expressions that <code>elim</code> used to eliminate the variables.
</p>
<p>Here is a example of eliminating between linear equations:
</p>
<pre class="example">(%i1) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1), 
           set(x,y));
(%o1)            [[2 z - 7], [y + 7, z - x + 1]]
</pre>
<p>Eliminating <code>x</code> and <code>y</code> yields the single equation <code>2 z - 7 = 0</code>;
the equations <code>y + 7 = 0</code> and <code>z - z + 1 = 1</code> were used as pivots.
Eliminating all three variables from these equations, triangularizes the linear
system:
</p>
<pre class="example">(%i2) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
           set(x,y,z));
(%o2)           [[], [2 z - 7, y + 7, z - x + 1]]
</pre>
<p>Of course, the equations needn't be linear:
</p>
<pre class="example">(%i3) elim(set(x^2 - 2 * y^3 = 1,  x - y = 5), [x,y]);
                     3    2
(%o3)       [[], [2 y  - y  - 10 y - 24, y - x + 5]]
</pre>
<p>The user doesn't control the order the variables are
eliminated.  Instead, the algorithm uses a heuristic to <i>attempt</i> to
choose the best pivot and the best elimination order.
</p>
<p><b>Notes</b> 
</p>
<ul>
<li> Unlike the related function <code>eliminate</code>, the function
<code>elim</code> does <i>not</i> invoke <code>solve</code> when the number of equations
equals the number of variables.

</li><li> The function <code>elim</code> works by applying resultants; the option
variable <code>resultant</code> determines which algorithm Maxima
uses.  Using <code>sqfr</code>, Maxima factors each resultant and suppresses
multiple zeros.

</li><li> The <code>elim</code> will triangularize a nonlinear set of polynomial
equations; the solution set of the triangularized set <i>can</i> be larger
than that solution set of the untriangularized set.  Thus, the triangularized
equations can have <i>spurious</i> solutions.
</li></ul>

<p><b>Related functions</b> <i>elim_allbut, eliminate_using, eliminate</i>
</p>
<p><b>Option variables</b> <i>resultant</i>
</p>
<p><b>To use</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>Status</b> The function <code>elim</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>
 
<p><a name="elim_005fallbut"></a>
<a name="Item_003a-elim_005fallbut"></a>
</p><dl>
<dt><u>Function:</u> <b>elim_allbut</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2530"></a>
</dt>
<dd><p>This function is similar to <code>elim</code>, except that it eliminates all the
variables in the list of equations <code>l</code> <i>except</i> for those variables that
in in the list <code>x</code>
</p>
<pre class="example">(%i1) elim_allbut([x+y = 1, x - 5*y = 1],[]);
(%o1)                 [[], [y, y + x - 1]]
(%i2) elim_allbut([x+y = 1, x - 5*y = 1],[x]);
(%o2)                [[x - 1], [y + x - 1]]
</pre>
<p><b>To use</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>Option variables</b> <i>resultant</i>
</p>
<p><b>Related functions</b> <i>elim, eliminate_using, eliminate</i>
</p>
<p><b>Status</b> The function <code>elim_allbut</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="eliminate_005fusing"></a>
<a name="Item_003a-eliminate_005fusing"></a>
</p><dl>
<dt><u>Function:</u> <b>eliminate_using</b><i> (<var>l</var>, <var>e</var>, <var>x</var>)</i>
<a name="IDX2531"></a>
</dt>
<dd><p>Using <code>e</code> as the pivot, eliminate the symbol <code>x</code> from the
list or set of equations in <code>l</code>.  The function <code>eliminate_using</code>
returns a set.
</p>
<pre class="example">(%i1) eq : [x^2 - y^2 - z^3 , x*y - z^2 - 5, x - y + z];
               3    2    2     2
(%o1)      [- z  - y  + x , - z  + x y - 5, z - y + x]
(%i2) eliminate_using(eq,first(eq),z);
        3              2      2      3    2
(%o2) {y  + (1 - 3 x) y  + 3 x  y - x  - x , 
                        4    3  3       2  2             4
                       y  - x  y  + 13 x  y  - 75 x y + x  + 125}
(%i3) eliminate_using(eq,second(eq),z);
        2            2       4    3  3       2  2             4
(%o3) {y  - 3 x y + x  + 5, y  - x  y  + 13 x  y  - 75 x y + x
                                                           + 125}
(%i4) eliminate_using(eq, third(eq),z);
        2            2       3              2      2      3    2
(%o4) {y  - 3 x y + x  + 5, y  + (1 - 3 x) y  + 3 x  y - x  - x }
</pre>
<p><b>Option variables</b> <i>resultant</i>
</p>
<p><b>Related functions</b> <i>elim, eliminate, elim_allbut</i>
</p>
<p><b>To use</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>Status</b> The function <code>eliminate_using</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="fourier_005felim"></a>
<a name="Item_003a-fourier_005felim"></a>
</p><dl>
<dt><u>Function:</u> <b>fourier_elim</b><i> ([<var>eq1</var>, <var>eq2</var>, &hellip;], [<var>var1</var>, <var>var</var>, &hellip;])</i>
<a name="IDX2532"></a>
</dt>
<dd><p>Fourier elimination is the analog of Gauss elimination for linear inequations
(equations or inequalities).  The function call <code>fourier_elim([eq1, eq2,
...], [var1, var2, ...])</code> does Fourier elimination on a list of linear
inequations <code>[eq1, eq2, ...]</code> with respect to the variables
<code>[var1, var2, ...]</code>; for example
</p>
<pre class="example">(%i1) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[x,y]);
(%o1)            [y - 5 &lt; x, x &lt; y + 7, 10 &lt; y]
(%i2) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[y,x]);
(%o2)        [max(10, x - 7) &lt; y, y &lt; x + 5, 5 &lt; x]
</pre>
<p>Eliminating first with respect to <em>x</em> and second with respect to
<em>y</em> yields lower and upper bounds for <em>x</em> that depend on
<em>y</em>, and lower and upper bounds for <em>y</em> that are numbers.
Eliminating in the other order gives <em>x</em> dependent lower and
upper bounds for <em>y</em>, and numerical lower and upper bounds for
<em>x</em>.
</p>
<p>When necessary, <code>fourier_elim</code> returns a <em>disjunction</em> of lists of
inequations:
</p>
<pre class="example">(%i3) fourier_elim([x # 6],[x]);
(%o3)                  [x &lt; 6] or [6 &lt; x]
</pre>
<p>When the solution set is empty,  <code>fourier_elim</code> returns <code>emptyset</code>,
and when the solution set is all reals, <code>fourier_elim</code> returns <code>universalset</code>;
for example
</p>
<pre class="example">(%i4) fourier_elim([x &lt; 1, x &gt; 1],[x]);
(%o4)                       emptyset
(%i5) fourier_elim([minf &lt; x, x &lt; inf],[x]);
(%o5)                     universalset
</pre>
<p>For nonlinear inequations, <code>fourier_elim</code> returns a (somewhat) 
simplified list of inequations:
</p>
<pre class="example">(%i6) fourier_elim([x^3 - 1 &gt; 0],[x]);
               2                             2
(%o6) [1 &lt; x, x  + x + 1 &gt; 0] or [x &lt; 1, - (x  + x + 1) &gt; 0]
(%i7) fourier_elim([cos(x) &lt; 1/2],[x]);
(%o7)                  [1 - 2 cos(x) &gt; 0]
</pre>
<p>Instead of a list of inequations, the first argument to <code>fourier_elim</code>
may be a logical disjunction or conjunction:
</p>
<pre class="example">(%i8) fourier_elim((x + y &lt; 5) and (x - y &gt;8),[x,y]);
                                              3
(%o8)            [y + 8 &lt; x, x &lt; 5 - y, y &lt; - -]
                                              2
(%i9) fourier_elim(((x + y &lt; 5) and x &lt; 1) or  (x - y &gt;8),[x,y]);
(%o9)          [y + 8 &lt; x] or [x &lt; min(1, 5 - y)]
</pre>
<p>The function <code>fourier_elim</code> supports the inequation operators 
<code>&lt;, &lt;=, &gt;, &gt;=, #</code>, and <code>=</code>.
</p>
<p>The Fourier elimination code has a preprocessor that converts some
nonlinear inequations that involve the absolute value, minimum, and
maximum functions into linear in equations.  Additionally, the preprocessor
handles some expressions that are the product or quotient of linear terms:
</p>
<pre class="example">(%i10) fourier_elim([max(x,y) &gt; 6, x # 8, abs(y-1) &gt; 12],[x,y]);
(%o10) [6 &lt; x, x &lt; 8, y &lt; - 11] or [8 &lt; x, y &lt; - 11]
 or [x &lt; 8, 13 &lt; y] or [x = y, 13 &lt; y] or [8 &lt; x, x &lt; y, 13 &lt; y]
 or [y &lt; x, 13 &lt; y]
(%i11) fourier_elim([(x+6)/(x-9) &lt;= 6],[x]);
(%o11)           [x = 12] or [12 &lt; x] or [x &lt; 9]
(%i12) fourier_elim([x^2 - 1 # 0],[x]);
(%o12)      [- 1 &lt; x, x &lt; 1] or [1 &lt; x] or [x &lt; - 1]
</pre>
<p><b>To use</b> <tt>`load(fourier_elim)'</tt>
</p>
</dd></dl>

<p><a name="isreal_005fp"></a>
<a name="Item_003a-isreal_005fp"></a>
</p><dl>
<dt><u>Function:</u> <b>isreal_p</b><i> (<var>e</var>)</i>
<a name="IDX2533"></a>
</dt>
<dd><p>The predicate <code>isreal_p</code> returns true when Maxima is able to
determine that <code>e</code> is real-valued on the <i>entire</i> real line; it
returns false when Maxima is able to determine that <code>e</code> <i>isn't</i>
real-valued on some nonempty subset of the real line; and it returns a
noun form for all other cases.
</p>
<pre class="example">(%i1) map('isreal_p, [-1, 0, %i, %pi]);
(%o1)               [true, true, false, true]
</pre>
<p>Maxima variables are assumed to be real; thus
</p>
<pre class="example">(%i2) isreal_p(x);
(%o2)                         true
</pre>
<p>The function <code>isreal_p</code> examines the fact database:
</p>
<pre class="example">(%i3) declare(z,complex)$

(%i4) isreal_p(z);
(%o4)                      isreal_p(z)
</pre>
<p><b>Limitations</b>
Too often, <code>isreal_p</code> returns a noun form when it should be able
to return false; a simple example: the logarithm function isn't
real-valued on the entire real line, so <code>isreal_p(log(x))</code> should
return false; however
</p>
<pre class="example">(%i5) isreal_p(log(x));
(%o5)                   isreal_p(log(x))
</pre>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Related functions</b> <i>complex_number_p</i>
</p>
<p><b>Status</b> The function <code>isreal_p</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>


<p><a name="new_005fvariable"></a>
<a name="Item_003a-new_005fvariable"></a>
</p><dl>
<dt><u>Function:</u> <b>new_variable</b><i> (type)</i>
<a name="IDX2534"></a>
</dt>
<dd><p>Return a unique symbol of the form <code>%[z,n,r,c,g]k</code>, where
<code>k</code> is an integer.  The allowed values for <em>type</em> are
<i>integer, natural_number, real, natural_number,</i> and <i>general</i>.
(By natural number, we mean the <i>nonnegative integers</i>; thus zero is
a natural number.  Some, but not all,definitions of natural number
<i>exclude</i> zero.)
</p>
<p>When <em>type</em> isn't one of the allowed values, <em>type</em> defaults
to <em>general</em>.  For integers, natural numbers, and complex numbers,
Maxima automatically appends this information to the fact database.
</p>
<pre class="example">(%i1) map('new_variable,
          ['integer, 'natural_number, 'real, 'complex, 'general]);
(%o1)          [%z144, %n145, %r146, %c147, %g148]
(%i2) nicedummies(%);
(%o2)               [%z0, %n0, %r0, %c0, %g0]
(%i3) featurep(%z0, 'integer);
(%o3)                         true
(%i4) featurep(%n0, 'integer);
(%o4)                         true
(%i5) is(%n0 &gt;= 0);
(%o5)                         true
(%i6) featurep(%c0, 'complex);
(%o6)                         true
</pre>
<p><b>Note</b> Generally, the argument to <code>new_variable</code> should be quoted.  The quote
will protect against errors similar to
</p>
<pre class="example">(%i7) integer : 12$

(%i8) new_variable(integer);
(%o8)                         %g149
(%i9) new_variable('integer);
(%o9)                         %z150
</pre>
<p><b>Related functions</b> <i>nicedummies</i>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>new_variable</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="nicedummies"></a>
<a name="Item_003a-nicedummies"></a>
</p><dl>
<dt><u>Function:</u> <b>nicedummies</b>
<a name="IDX2535"></a>
</dt>
<dd><p>Starting with zero, the function <code>nicedummies</code> re-indexes the variables 
in an expression that were introduced by <code>new_variable</code>;
</p>
<pre class="example">(%i1) new_variable('integer) + 52 * new_variable('integer);
(%o1)                   52 %z136 + %z135
(%i2) new_variable('integer) - new_variable('integer);
(%o2)                     %z137 - %z138
(%i3) nicedummies(%);
(%o3)                       %z0 - %z1
</pre>
<p><b>Related functions</b> <i>new_variable</i>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>nicedummies</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="Item_003a-parg"></a>
</p><dl>
<dt><u>Function:</u> <b>parg</b><i> (<var>x</var>)</i>
<a name="IDX2536"></a>
</dt>
<dd><p>The function <code>parg</code> is a simplifying version of the complex argument function 
<code>carg</code>; thus
</p>
<pre class="example">(%i1) map('parg,[1,1+%i,%i, -1 + %i, -1]);
                        %pi  %pi  3 %pi
(%o1)               [0, ---, ---, -----, %pi]
                         4    2     4
</pre>
<p>Generally, for a non-constant input, <code>parg</code> returns a noun form; thus
</p>
<pre class="example">(%i2) parg(x + %i * sqrt(x));
(%o2)                 parg(x + %i sqrt(x))
</pre>
<p>When <code>sign</code> can determine that the input is a positive or negative real
number, <code>parg</code> will return a non-noun form for a non-constant input.
Here are two examples:
</p>

<pre class="example">(%i3) parg(abs(x));
(%o3) 0
(%i4) parg(-x^2-1);
(%o4)                          %pi
</pre>
<p><b>Note</b> The <code>sign</code> function mostly ignores the variables that are declared
to be complex (<code>declare(x,complex)</code>); for variables that are declared
to be complex, the <code>parg</code> can return incorrect values; for example
</p>

<pre class="example">(%i1) declare(x,complex)$

(%i2) parg(x^2 + 1);
(%o2) 0
</pre>
<p><b>Related function</b> <i>carg, isreal_p</i>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>parg</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="real_005fimagpart_005fto_005fconjugate"></a>
<a name="Item_003a-real_005fimagpart_005fto_005fconjugate"></a>
</p><dl>
<dt><u>Function:</u> <b>real_imagpart_to_conjugate</b><i> (<var>e</var>)</i>
<a name="IDX2537"></a>
</dt>
<dd><p>The function <code>real_imagpart_to_conjugate</code> replaces all occurrences
of <code>realpart</code> and <code>imagpart</code> to algebraically equivalent expressions
involving the <code>conjugate</code>.
</p>
<pre class="example">(%i1) declare(x, complex)$

(%i2) real_imagpart_to_conjugate(realpart(x) +  imagpart(x) = 3);
          conjugate(x) + x   %i (x - conjugate(x))
(%o2)     ---------------- - --------------------- = 3
                 2                     2
</pre>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>real_imagpart_to_conjugate</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="rectform_005flog_005fif_005fconstant"></a>
<a name="Item_003a-rectform_005flog_005fif_005fconstant"></a>
</p><dl>
<dt><u>Function:</u> <b>rectform_log_if_constant</b><i> (<var>e</var>)</i>
<a name="IDX2538"></a>
</dt>
<dd><p>The function <code>rectform_log_if_constant</code> converts all terms of the form
<code> log(c)</code> to  <code>rectform(log(c))</code>, where <code>c</code> is
either a declared constant expression or explicitly declared constant
</p>
<pre class="example">(%i1) rectform_log_if_constant(log(1-%i) - log(x - %i));
                                 log(2)   %i %pi
(%o1)            - log(x - %i) + ------ - ------
                                   2        4
(%i2) declare(a,constant, b,constant)$

(%i3) rectform_log_if_constant(log(a + %i*b));
                       2    2
                  log(b  + a )
(%o3)             ------------ + %i atan2(b, a)
                       2
</pre>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>rectform_log_if_constant</code> is
experimental; the specifications of this function might change might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<p><a name="simp_005finequality"></a>
<a name="Item_003a-simp_005finequality"></a>
</p><dl>
<dt><u>Function:</u> <b>simp_inequality</b><i> (<var>e</var>)</i>
<a name="IDX2539"></a>
</dt>
<dd><p>The function <code>simp_inequality</code> applies some simplifications to
conjunctions and disjunctions of inequations.
</p>
<p><b>Limitations</b> The function <code>simp_inequality</code> is limited in at least two ways;
first, the simplifications are local; thus
</p>

<pre class="example">(%i1) simp_inequality((x &gt; minf) %and (x &lt; 0));
(%o1) (x&gt;1) %and (x&lt;1)
</pre>
<p>And second, <code>simp_inequality</code> doesn't consult the fact database:
</p>
<pre class="example">(%i2) assume(x &gt; 0)$

(%i3) simp_inequality(x &gt; 0);
(%o3)                         x &gt; 0
</pre>
<p><b>To use</b> <tt>`load(fourier_elim)'</tt>
</p>
<p><b>Status</b> The function <code>simp_inequality</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="standardize_005finverse_005ftrig"></a>
<a name="Item_003a-standardize_005finverse_005ftrig"></a>
</p><dl>
<dt><u>Function:</u> <b>standardize_inverse_trig</b><i> (<var>e</var>)</i>
<a name="IDX2540"></a>
</dt>
<dd><p>This function applies the identities <code>cot(x) = atan(1/x),
acsc(x) = asin(1/x),</code> and similarly for <code>asec, acoth, acsch</code>
and <code>asech</code> to an expression.  See Abramowitz and Stegun, 
Eqs. 4.4.6 through 4.4.8 and 4.6.4 through 4.6.6.
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status</b> The function <code>standardize_inverse_trig</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<p><a name="subst_005fparallel"></a>
<a name="Item_003a-subst_005fparallel"></a>
</p><dl>
<dt><u>Function:</u> <b>subst_parallel</b><i> (<var>l</var>, <var>e</var>)</i>
<a name="IDX2541"></a>
</dt>
<dd><p>When <code>l</code> is a single equation or a list of equations, substitute
the right hand side of each equation for the left hand side.  The
substitutions are made in parallel; for example
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) subst_parallel([x=y,y=x], [x,y]);
(%o2)                        [y, x]
</pre>
<p>Compare this to substitutions made serially:
</p>
<pre class="example">(%i3) subst([x=y,y=x],[x,y]);
(%o3)                        [x, x]
</pre>
<p>The function <code>subst_parallel</code> is similar to <code>sublis</code> except that
<code>subst_parallel</code> allows for substitution of nonatoms; for example
</p>
<pre class="example">(%i4) subst_parallel([x^2 = a, y = b], x^2 * y);
(%o4)                          a b
(%i5) sublis([x^2 = a, y = b], x^2 * y);

                                                             2
sublis: left-hand side of equation must be a symbol; found: x
 -- an error. To debug this try: debugmode(true);
</pre>
<p>The substitutions made by <code>subst_parallel</code> are literal, not semantic; thus 
<code>subst_parallel</code> <i>does not</i> recognize that <em>x * y</em> is a subexpression 
of <em>x^2 * y</em>
</p>
<pre class="example">(%i6) subst_parallel([x * y = a], x^2 * y);
                               2
(%o6)                         x  y
</pre>
<p>The function <code>subst_parallel</code> completes all substitutions
<i>before</i> simplifications.  This allows for substitutions into
conditional expressions where errors might occur if the
simplifications were made earlier:
</p>
<pre class="example">(%i7) subst_parallel([x = 0], %if(x &lt; 1, 5, log(x)));
(%o7)                           5
(%i8) subst([x = 0], %if(x &lt; 1, 5, log(x)));

log: encountered log(0).
 -- an error. To debug this try: debugmode(true);
</pre>
<p><b>Related functions</b> <i>subst, sublis, ratsubst</i>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve_extra.lisp)'</tt>
</p>
<p><b>Status</b> The function <code>subst_parallel</code> is experimental; the
specifications of this function might change might change and its
functionality might be merged into other Maxima functions.
</p>
</dd></dl>

<p><a name="to_005fpoly"></a>
<a name="Item_003a-to_005fpoly"></a>
</p><dl>
<dt><u>Function:</u> <b>to_poly</b><i> (<var>e</var>, <var>l</var>)</i>
<a name="IDX2542"></a>
</dt>
<dd><p>The function <code>to_poly</code> attempts to convert the equation <code>e</code>
into a polynomial system along with inequality constraints; the
solutions to the polynomial system that satisfy the constraints are
solutions to the equation <code>e</code>.  Informally, <code>to_poly</code>
attempts to polynomialize the equation <var>e</var>; an example might
clarify:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly(sqrt(x) = 3, [x]);
                            2
(%o2) [[%g130 - 3, x = %g130 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g130), parg(%g130) &lt;= ---], []]
                       2                                 2
</pre>
<p>The conditions <code>-%pi/2&lt;parg(%g130),parg(%g130)&lt;=%pi/2</code> tell us that
<code>%g130</code> is in the range of the square root function.  When this is
true, the solution set to <code>sqrt(x) = 3</code> is the same as the
solution set to <code>%g130-3,x=%g130^2</code>.
</p>
<p>To polynomialize trigonometric expressions, it is necessary to
introduce a non algebraic substitution; these non algebraic substitutions
are returned in the third list returned by <code>to_poly</code>; for example
</p>
<pre class="example">(%i3) to_poly(cos(x),[x]);
                2                                 %i x
(%o3)    [[%g131  + 1], [2 %g131 # 0], [%g131 = %e    ]]
</pre>
<p>Constant terms aren't polynomializied unless the number one is a member of
the variable list; for example
</p>
<pre class="example">(%i4) to_poly(x = sqrt(5),[x]);
(%o4)                [[x - sqrt(5)], [], []]
(%i5) to_poly(x = sqrt(5),[1,x]);
                            2
(%o5) [[x - %g132, 5 = %g132 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g132), parg(%g132) &lt;= ---], []]
                       2                                 2
</pre>
<p>To generate a polynomial with <em>sqrt(5) + sqrt(7)</em> as
one of its roots, use the commands
</p>
<pre class="example">(%i6) first(elim_allbut(first(to_poly(x = sqrt(5) + sqrt(7),
                                      [1,x])), [x]));
                          4       2
(%o6)                   [x  - 24 x  + 4]
</pre>
<p><b>Related functions</b> <i>to_poly_solve</i>
</p>
<p><b>To use</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>Status:</b> The function <code>to_poly</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<p><a name="Item_003a-to_005fpoly_005fsolve"></a>
</p><dl>
<dt><u>Function:</u> <b>to_poly_solve</b><i> (<var>e</var>, <var>l</var>, [options])</i>
<a name="IDX2543"></a>
</dt>
<dd><p>The function <code>to_poly_solve</code> tries to solve the equations <em>e</em>
for the variables <em>l</em>.  The equation(s) <em>e</em> can either be a
single expression or a set or list of expressions; similarly, <em>l</em>
can either be a single symbol or a list of set of symbols.  When
a member of <em>e</em> isn't explicitly an equation, for example <em>x^2 -1</em>,
the solver asummes that the expression vanishes.
</p>
<p>The basic strategy of <code>to_poly_solve</code> is to convert the input into a polynomial form and to 
call <code>algsys</code> on the polynomial system. Internally  <code>to_poly_solve</code> defaults <code>algexact</code> 
to true. To change the default for <code>algexact</code>, append 'algexact=false to the <code>to_poly_solve</code> 
argument list.
</p>
<p>When <code>to_poly_solve</code> is able to determine the solution set, each
member of the solution set is a list in a <code>%union</code> object:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(x*(x-1) = 0, x);
(%o2)               %union([x = 0], [x = 1])
</pre>
<p>When  <code>to_poly_solve</code> is <i>unable</i> to determine the solution set, a
<code>%solve</code> nounform is returned (in this case, a warning is printed)
</p>
<pre class="example">(%i3) to_poly_solve(x^k + 2* x + 1 = 0, x);

Nonalgebraic argument given to 'to_poly'
unable to solve
                          k
(%o3)            %solve([x  + 2 x + 1 = 0], [x])
</pre>
<p>Subsitution into a <code>%solve</code> nounform can sometimes result in the solution
</p>
<pre class="example">(%i4) subst(k = 2, %);
(%o4)                   %union([x = - 1])
</pre>
<p>Especially for trigonometric equations, the solver sometimes needs
to introduce an arbitrary integer.  These arbitrary integers have the 
form <code>%zXXX</code>, where <code>XXX</code> is an integer; for example
</p>
<pre class="example">(%i5) to_poly_solve(sin(x) = 0, x);
(%o5)   %union([x = 2 %pi %z33 + %pi], [x = 2 %pi %z35])
</pre>
<p>To re-index these variables to zero, use <code>nicedummies</code>:
</p>
<pre class="example">(%i6) nicedummies(%);
(%o6)    %union([x = 2 %pi %z0 + %pi], [x = 2 %pi %z1])
</pre>
<p>Occasionally, the solver introduces an arbitrary complex number of the
form <code>%cXXX</code> or an  arbitrary real number of the form <code>%rXXX</code>.
The function <code>nicedummies</code> will re-index these identifiers to zero.
</p>
<p>The solution set sometimes involves simplifing versions of various
of logical operators including <code>%and</code>, <code>%or</code>, or <code>%if</code>
for conjunction, disjuntion, and implication, respectively; for example
</p>
<pre class="example">(%i7) sol : to_poly_solve(abs(x) = a, x);
(%o7) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i8) subst(a = 42, sol);
(%o8)             %union([x = - 42], [x = 42])
(%i9) subst(a = -42, sol);
(%o9)                       %union()
</pre>
<p>The empty set is represented by <code>%union()</code>.
</p>
<p>The function <code>to_poly_solve</code> is able to solve some, but not all,
equations involving rational powers, some nonrational powers, absolute
values, trigonometric functions, and minimum and maximum.  Also, some it
can solve some equations that are solvable in in terms of the Lambert W
function; some examples:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(set(max(x,y) = 5, x+y = 2), set(x,y));
(%o2)      %union([x = - 3, y = 5], [x = 5, y = - 3])
(%i3) to_poly_solve(abs(1-abs(1-x)) = 10,x);
(%o3)             %union([x = - 10], [x = 12])
(%i4) to_poly_solve(set(sqrt(x) + sqrt(y) = 5, x + y = 10),
                    set(x,y));
                     3/2               3/2
                    5    %i - 10      5    %i + 10
(%o4) %union([x = - ------------, y = ------------], 
                         2                 2
                                3/2                 3/2
                               5    %i + 10        5    %i - 10
                          [x = ------------, y = - ------------])
                                    2                   2
(%i5) to_poly_solve(cos(x) * sin(x) = 1/2,x,
                    'simpfuncs = ['expand, 'nicedummies]);
                                         %pi
(%o5)              %union([x = %pi %z0 + ---])
                                          4
(%i6) to_poly_solve(x^(2*a) + x^a + 1,x);
                                        2 %i %pi %z81
                                        -------------
                                  1/a         a
                  (sqrt(3) %i - 1)    %e
(%o6) %union([x = -----------------------------------], 
                                  1/a
                                 2
                                                  2 %i %pi %z83
                                                  -------------
                                            1/a         a
                          (- sqrt(3) %i - 1)    %e
                     [x = -------------------------------------])
                                           1/a
                                          2
(%i7) to_poly_solve(x * exp(x) = a, x);
(%o7)              %union([x = lambert_w(a)])
</pre>
<p>For <i>linear</i> inequalities, <code>to_poly_solve</code> automatically does Fourier
elimination:
</p>
<pre class="example">(%i8) to_poly_solve([x + y &lt; 1, x - y &gt;= 8], [x,y]);
                               7
(%o8) %union([x = y + 8, y &lt; - -], 
                               2
                                                              7
                                 [y + 8 &lt; x, x &lt; 1 - y, y &lt; - -])
                                                              2
</pre>
<p>Each optional argument to <code>to_poly_solve</code> must be an equation;
generally, the order of these options does not matter.
</p>
<ul>
<li> <code>simpfuncs = l</code>, where <code>l</code> is a list of functions.
Apply the composition of the members of l to each solution.

<pre class="example">(%i1) to_poly_solve(x^2=%i,x);
                               1/4             1/4
(%o1)       %union([x = - (- 1)   ], [x = (- 1)   ])
(%i2) to_poly_solve(x^2= %i,x, 'simpfuncs = ['rectform]);
                      %i         1             %i         1
(%o2) %union([x = - ------- - -------], [x = ------- + -------])
                    sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre>
<p>Sometimes additional simplification can revert a simplification; for example
</p>
<pre class="example">(%i3) to_poly_solve(x^2=1,x);
(%o3)              %union([x = - 1], [x = 1])
(%i4) to_poly_solve(x^2= 1,x, 'simpfuncs = [polarform]);
                                        %i %pi
(%o4)            %union([x = 1], [x = %e      ]
</pre>
<p>Maxima doesn't try to check that each member of the function list <code>l</code> is
purely a simplification; thus
</p>
<pre class="example">(%i5) to_poly_solve(x^2 = %i,x, 'simpfuncs = [lambda([s],s^2)]);
(%o5)                   %union([x = %i])
</pre>
<p>To convert each solution to a double float, use <code>simpfunc = ['dfloat]</code>:
</p>
<pre class="example">(%i6) to_poly_solve(x^3 +x + 1 = 0,x, 
                    'simpfuncs = ['dfloat]), algexact : true;
(%o6) %union([x = - .6823278038280178], 
[x = .3411639019140089 - 1.161541399997251 %i], 
[x = 1.161541399997251 %i + .3411639019140089])
</pre>
</li><li> <code>use_grobner = true</code> With this option, the function
<code>poly_reduced_grobner</code> is applied to the equations before
attempting their solution.  Primarily, this option provides a workaround
for weakness in the function <code>algsys</code>.  Here is an example of
such a workaround:

<pre class="example">(%i7) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y],
                    'use_grobner = true);
                    sqrt(7) - 1      sqrt(7) + 1
(%o7) %union([x = - -----------, y = -----------], 
                         2                2
                                 sqrt(7) + 1        sqrt(7) - 1
                            [x = -----------, y = - -----------])
                                      2                  2
(%i8) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y]);
(%o8)                       %union()
</pre>
</li><li> <code>maxdepth = k</code>, where <code>k</code> is a positive integer.  This
function controls the maximum recursion depth for the solver.  The
default value for <code>maxdepth</code> is five.  When the recursions depth is
exceeded, the solver signals an error:

<pre class="example">(%i9) to_poly_solve(cos(x) = x,x, 'maxdepth = 2);

Unable to solve
Unable to solve
(%o9)        %solve([cos(x) = x], [x], maxdepth = 2)
</pre>
</li><li> <code>parameters = l</code>, where <code>l</code> is a list of symbols.  The solver
attempts to return a solution that is valid for all members of the list
<code>l</code>; for example:

<pre class="example">(%i10) to_poly_solve(a * x = x, x);
(%o10)                   %union([x = 0])
(%i11) to_poly_solve(a * x = x, x, 'parameters = [a]);
(%o11) %union(%if(a - 1 = 0, [x = %c111], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre>
<p>In <code>(%o2)</code>, the solver introduced a dummy variable; to re-index the
these dummy variables, use the function <code>nicedummies</code>:
</p>
<pre class="example">(%i12) nicedummies(%);
(%o12) %union(%if(a - 1 = 0, [x = %c0], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre></li></ul>

<p>The <code>to_poly_solve</code> uses data stored in the hashed array
<code>one_to_one_reduce</code> to solve equations of the form <em>f(a) =
f(b)</em>.  The assignment <code>one_to_one_reduce['f,'f] : lambda([a,b],
a=b)</code> tells <code>to_poly_solve</code> that the solution set of <em>f(a)
= f(b)</em> equals the solution set of <em>a=b</em>; for example
</p>
<pre class="example">(%i13) one_to_one_reduce['f,'f] : lambda([a,b], a=b)$

(%i14) to_poly_solve(f(x^2-1) = f(0),x);
(%o14)             %union([x = - 1], [x = 1])
</pre>
<p>More generally, the assignment <code>one_to_one_reduce['f,'g] : lambda([a,b],
w(a, b) = 0</code> tells <code>to_poly_solve</code> that the solution set of <em>f(a)
= f(b)</em> equals the solution set of <em>w(a,b) = 0</em>; for example
</p>
<pre class="example">(%i15) one_to_one_reduce['f,'g] : lambda([a,b], a = 1 + b/2)$

(%i16) to_poly_solve(f(x) - g(x),x);
(%o16)                   %union([x = 2])
</pre>
<p>Additionally, the function <code>to_poly_solve</code> uses data stored in the hashed array 
<code>function_inverse</code> to solve equations of the form <em>f(a) = b</em>.
The assignment <code>function_inverse['f] : lambda([s], g(s))</code> 
informs  <code>to_poly_solve</code> that the solution set to <code>f(x) = b</code> equals
the solution set to <code>x = g(b)</code>; two examples:
</p>
<pre class="example">(%i17) function_inverse['Q] : lambda([s], P(s))$

(%i18) to_poly_solve(Q(x-1) = 2009,x);
(%o18)              %union([x = P(2009) + 1])
(%i19) function_inverse['G] : lambda([s], s+new_variable(integer));
(%o19)       lambda([s], s + new_variable(integer))
(%i20) to_poly_solve(G(x - a) = b,x);
(%o20)             %union([x = b + a + %z125])
</pre>

<p><b>Notes</b>
</p>
<ul class="toc">
<li> The solve variables needn't be symbols; when <code>fullratsubst</code> is 
able to appropriately make substitutions, the solve variables can be nonsymbols:
</li></ul>

<pre class="example">(%i1) to_poly_solve([x^2 + y^2 + x * y = 5, x * y = 8],
                    [x^2 + y^2, x * y]);
                                  2    2
(%o1)           %union([x y = 8, y  + x  = - 3])
</pre>
<ul class="toc">
<li> For equations that involve complex conjugates, the solver automatically
appends the conjugate equations; for example
</li></ul>

<pre class="example">(%i1) declare(x,complex)$

(%i2) to_poly_solve(x + (5 + %i) * conjugate(x) = 1, x);
                                   %i + 21
(%o2)              %union([x = - -----------])
                                 25 %i - 125
(%i3) declare(y,complex)$

(%i4) to_poly_solve(set(conjugate(x) - y = 42 + %i,
                        x + conjugate(y) = 0), set(x,y));
                           %i - 42        %i + 42
(%o4)        %union([x = - -------, y = - -------])
                              2              2
</pre>
<ul class="toc">
<li> For an equation that involves the absolute value function, the
<code>to_poly_solve</code> consults the fact database to decide if the
argument to the absolute value is complex valued.  When

<pre class="example">(%i1) to_poly_solve(abs(x) = 6, x);
(%o1)              %union([x = - 6], [x = 6])
(%i2) declare(z,complex)$

(%i3) to_poly_solve(abs(z) = 6, z);
(%o3) %union(%if((%c11 # 0) %and (%c11 conjugate(%c11) - 36 = 
                                       0), [z = %c11], %union()))
</pre>
<p><i>This is the only situation that the solver consults the fact database.  If
a solve variable is declared to be an integer, for example, <code>to_poly_solve</code>
ignores this declaration</i>.
</p></li></ul>

<p><b>Relevant option variables</b> <i>algexact, resultant, algebraic</i>
</p>
<p><b>Related functions</b> <i>to_poly</i>
</p>
<p><b>To use</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>Status:</b> The function <code>to_poly_solve</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<p><a name="g_t_0025union"></a>
<a name="Item_003a-_0025union"></a>
</p><dl>
<dt><u>Operator:</u> <b>%union</b><i> (<var>soln_1</var>, <var>soln_2</var>, <var>soln_3</var>, ...)</i>
<a name="IDX2544"></a>
</dt>
<dt><u>Operator:</u> <b>%union</b><i> ()</i>
<a name="IDX2545"></a>
</dt>
<dd><p><code>%union(<var>soln_1</var>, <var>soln_2</var>, <var>soln_3</var>, ...)</code> represents the union of its arguments,
each of which represents a solution set,
as determined by <code>to_poly_solve</code>.
<code>%union()</code> represents the empty set.
</p>
<p>In many cases, a solution is a list of equations <code>[<var>x</var> = ..., <var>y</var> = ..., <var>z</var> = ...]</code>
where <var>x</var>, <var>y</var>, and <var>z</var> are one or more unknowns.
In such cases, <code>to_poly_solve</code> returns a <code>%union</code> expression
containing one or more such lists.
</p>
<p>The solution set sometimes involves simplifing versions of various
of logical operators including <code>%and</code>, <code>%or</code>, or <code>%if</code>
for conjunction, disjuntion, and implication, respectively.
</p>
<p>Examples:
</p>
<p><code>%union(...)</code> represents the union of its arguments,
each of which represents a solution set,
as determined by <code>to_poly_solve</code>.
In many cases, a solution is a list of equations.
</p>
<pre class="example">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) to_poly_solve ([sqrt(x^2 - y^2), x + y], [x, y]);
(%o2)    %union([x = 0, y = 0], [x = %c13, y = - %c13])
</pre>
<p><code>%union()</code> represents the empty set.
</p>
<pre class="example">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) to_poly_solve (abs(x) = -1, x);
(%o2)                       %union()
</pre>
<p>The solution set sometimes involves simplifing versions of various
of logical operators.
</p>
<pre class="example">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) sol : to_poly_solve (abs(x) = a, x);
(%o2) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i3) subst (a = 42, sol);
(%o3)             %union([x = - 42], [x = 42])
(%i4) subst (a = -42, sol);
(%o4)                       %union()
</pre>
</dd></dl>

<p><a name="Item_003a-unit_002dpkg"></a>
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC394" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_86.html#SEC396" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_89.html#SEC426" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>本田 康晃</em> on <em>August, 17 2018</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
