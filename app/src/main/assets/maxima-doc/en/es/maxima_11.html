<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on octubre, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.41.0: 11. Base de datos de Maxima</title>

<meta name="description" content="Manual de Maxima 5.41.0: 11. Base de datos de Maxima">
<meta name="keywords" content="Manual de Maxima 5.41.0: 11. Base de datos de Maxima">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Base-de-datos-de-Maxima"></a>
<a name="SEC68"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_10.html#SEC67" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_10.html#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 11. Base de datos de Maxima </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC69">11.1 Introducción a la base de datos de Maxima</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC72">11.2 Funciones y variables para las propiedades</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC73">11.3 Funciones y variables para los hechos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC74">11.4 Funciones y variables para los predicados</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>




<hr size="6">
<a name="Introducci_00f3n-a-la-base-de-datos-de-Maxima"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC72" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.1 Introducción a la base de datos de Maxima </h2>

<a name="SEC70"></a>
<h3 class="subheading"> Propiedades </h3>

<p>A las variables y funciones se les puede asignar propiedades con la función 
<code>declare</code>. Estas propiedades son almacenadas en un <i>banco de datos</i> o
registradas en una <i>lista de propiedades</i> que proporciona Lisp. Con la función
<code>featurep</code> se puede comprobar si un símbolo tiene una 
determinada propiedad y con la función <code>properties</code> se pueden obtener
todas las propiedades asociadas a él. A su vez, la función <code>remove</code>
elimina una propiedad de la base de datos o de la lista de propiedades. En caso
de utilizar <code>kill</code> para borrar el valor asignado a una variable, también
serán borradas todas las propiedades asociadas a la misma.
</p>
<p>El usuario tiene la facultad de añadirle propiedades a un símbolo
con las funciones <code>put</code> y <code>qput</code>. Con la función <code>get</code> podrá
leer sus propiedades y borrarlas con <code>rem</code>.
</p>
<p>Las variables pueden tener las siguientes propiedades a almacenar en el banco de
datos:
</p>
<pre class="verbatim">   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex
</pre>
<p>Las funciones pueden tener las siguientes propiedades a almacenar en el banco de
datos:
</p>
<pre class="verbatim">   increasing     decreasing
   posfun         integervalued
</pre>
<p>Las siguientes propiedades se pueden aplicar a funciones y se utilizan para
su correcta simplificación. Estas propiedades se describen en el capítulo
dedicado a la simplificación:
</p>
<pre class="verbatim">   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
</pre>
<p>Otras propiedades aplicables a variables y funciones, y que se almacenan
en la lista de propiedades de Lisp, son:
</p>
<pre class="verbatim">   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray
</pre>
<a name="SEC71"></a>
<h3 class="subheading"> Contextos </h3>

<p>Maxima administra contextos en los que se almacenan tanto las propiedades de las
variables y funciones como hechos o hipótesis sobre las mismas. Los hechos se
establecen con la función <code>assume</code> y se almacenan en el contexto actual.
Por ejemplo, con <code>assume(a&gt;10)</code> guarda Maxima la información sobre el
hecho de que la variable <code>a</code> es mayor que <code>10</code>. Con la función
<code>forget</code> se borran los hechos de la base de datos. Cuando Maxima pregunta
al usuario sobre las propiedades de una variable, éstas son almacenadas en
un contexto.
</p>
<p>Cada contexto se identifica por un nombre. Al iniciarse Maxima, el contexto
actual recibe el nombre de <code>initial</code> y se puede definir un número
arbitrario de contextos adicionales que pueden organizarse de forma jerárquica.
Así, el contexto <code>initial</code> está incluido en el contexto
<code>global</code>. Los hechos definidos en un contexto dado están siempre
activos en los contextos de nivel inferior. Por ejemplo, el contexto <code>global</code>
contiene hechos que se inicializan por el propio Maxima y estarán activos,
por tanto, en el contexto <code>initial</code>.
</p>
<p>Los contextos pueden almacenar un número arbitrario de hechos y pueden desactivarse
con la función <code>deactivate</code>. Desactivar un contexto no implica la pérdida de
los hechos almacenados, pudiendo ser posteriormente reactivado con la función 
<code>activate</code>, estando los hechos siempre a disposición del usuario.
</p>







<hr size="6">
<a name="Funciones-y-variables-para-las-propiedades"></a>
<a name="SEC72"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC73" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.2 Funciones y variables para las propiedades </h2>

<dl>
<dt><u>Propiedad:</u> <b>alphabetic</b>
<a name="IDX415"></a>
</dt>
<dd><p><code>alphabetic</code> es un tipo de propiedad reconocida por <code>declare</code>.
La expresión <code>declare(<var>s</var>, alphabetic)</code> le indica a Maxima que reconozca
como alfabéticos todos los caracteres que haya en <var>s</var>, que debe ser una cadena de texto.
</p>
<p>Véase también <code>Identifiers</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) xx\~yy\`\@ : 1729;
(%o1)                         1729
(%i2) declare (&quot;~`@&quot;, alphabetic);
(%o2)                         done
(%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
(%o3)               `xx@@yy~ + @yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@yy`xx, `xx@@yy~]
</pre></dd></dl>

<dl>
<dt><u>Propiedad:</u> <b>bindtest</b>
<a name="IDX416"></a>
</dt>
<dd><p>La sentencia <code>declare(<var>x</var>, bindtest</code> le indica a Maxima que devuelva un mensaje
de error cuando el símbolo <var>x</var> no tenga asociado valor alguno.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>constant</b>
<a name="IDX417"></a>
</dt>
<dd><p><code>declare(<var>a</var>, constant)</code> declara <var>a</var> como constante.  La declaración
de un símbolo como constante no impide que se le asigne un valor no
constante al símbolo.
</p>
<p>Véanse <code>constantp</code> y <code>declare</code>
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(c, constant);
(%o1)                         done
(%i2) constantp(c);
(%o2)                         true
(%i3) c : x;
(%o3)                           x
(%i4) constantp(c);
(%o4)                         false
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>constantp</b><i> (<var>expr</var>)</i>
<a name="IDX418"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una expresión constante y
<code>false</code> en caso contrario.
</p>
<p>Una expresión se considera constante si sus argumentos son números 
(incluidos los números racionales que se muestran con <code>/R/</code>), 
constantes simbólicas como <code>%pi</code>, <code>%e</code> o <code>%i</code>, variables 
con valor constante o declarada como constante por <code>declare</code>,
o funciones cuyos argumentos son constantes.
</p>
<p>La función <code>constantp</code> evalúa sus argumentos.
</p>
<p>Ejemplos:
</p>

<pre class="example">(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>declare</b><i> (<var>a_1</var>, <var>f_1</var>, <var>a_2</var>, <var>f_2</var>, ...)</i>
<a name="IDX419"></a>
</dt>
<dd><p>Asigna al átomo o lista de átomos <var>a_i</var> la propiedad o lista de 
propiedades<var>p_i</var>. Si <var>a_i</var> y/o <var>p_i</var> son listas, cada uno de
los átomos adquiere todas las propiedades.
</p>
<p>La función <code>declare</code> no evalúa sus argumentos y siempre devuelve la
expresión <code>done</code>.
</p>
<p>La llamada <code>featurep (<var>object</var>, <var>feature</var>)</code> devuelve <code>true</code>
si <var>object</var> ha sido previamente declarado como poseedor de la propiedad
<var>feature</var>.
</p>
<p>Véase también <code>features</code>.
</p>
<p>La función <code>declare</code> reconoce las siguientes propiedades:
</p>
<dl compact="compact">
<dt> <code>additive</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      haciendo uso de la sustitución 
      <code><var>a_i</var>(x + y + z + ...)</code> <code>--&gt;</code>
      <code><var>a_i</var>(x) + <var>a_i</var>(y) + <var>a_i</var>(z) + ...</code>.
      Tal sustitución se aplica únicamente al primer argumento.
</p>
</dd>
<dt> <code>alphabetic</code></dt>
<dd><p>      Indica a Maxima que reconozca todos los caracteres de la cadena alfanumérica
      <var>a_i</var> como caracteres alfabéticos.
</p>
</dd>
<dt> <code>antisymmetric, commutative, symmetric</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función simétrica o
      antisimétrica. La propiedad <code>commutative</code> equivale a <code>symmetric</code>.
</p>
</dd>
<dt> <code>bindtest</code></dt>
<dd><p>      Hace que Maxima envíe un error si <var>a_i</var> es evaluado sin habérsele
      asignado un valor.
</p>
</dd>
<dt> <code>constant</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una constante
      simbólica.
</p>
</dd>
<dt> <code>even, odd</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable entera par o impar.
</p>
</dd>
<dt> <code>evenfun, oddfun</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función par o impar.
</p>
</dd>
<dt> <code>evflag</code></dt>
<dd><p>      Hace que <var>a_i</var> sea reconocida por <code>ev</code>, de manera que a <var>a_i</var> se le
      asigne el valor <code>true</code> durante la ejecución de <code>ev</code> cuando <var>a_i</var> 
      aparezca como argumento de control de <code>ev</code>. Véase también <code>evflag</code>.
</p>
</dd>
<dt> <code>evfun</code></dt>
<dd><p>      Hace que <var>a_i</var> sea reconocida por <code>ev</code>, de manera que la función
      nombrada por <var>a_i</var> se aplique cuando <var>a_i</var> aparezca como argumento
      de control de <code>ev</code>. Véase también <code>evfun</code>.
</p>
</dd>
<dt> <code>feature</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como el nombre de una propiedad.
      Otros átomos podrán ser declarados entonces como poseedores de
      la propiedad <var>a_i</var>.
</p>
</dd>
<dt> <code>increasing, decreasing</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función creciente o decreciente.
</p>
</dd>
<dt> <code>integer, noninteger</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable entera o no entera.
</p>
</dd>
<dt> <code>integervalued</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función de valor entero.
</p>
</dd>
<dt> <code>lassociative, rassociative</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función asociativa por la derecha o
      por la izquierda.
</p>
</dd>
<dt> <code>linear</code></dt>
<dd><p>      Equivale a declarar <var>a_i</var> conjuntamente como <code>outative</code> y <code>additive</code>.
</p>
</dd>
<dt> <code>mainvar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una &quot;variable principal&quot;,
      dándole prioridad frente a cualesquiera otras constantes o
      variables en la ordenación canónica de expresiones de Maxima,
      tal como determina <code>ordergreatp</code>.
</p>
</dd>
<dt> <code>multiplicative</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      haciendo uso de la sustitución 
      <code><var>a_i</var>(x * y * z * ...)</code> <code>--&gt;</code> <code><var>a_i</var>(x) * <var>a_i</var>(y) * <var>a_i</var>(z) * ...</code>.
      Tal sustitución se aplica únicamente al primer argumento.
</p>
</dd>
<dt> <code>nary</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función n-aria.
</p>
<p>      La declaración <code>nary</code> no es equivalente a la función <code>nary</code>.
      El único efecto de <code>declare(foo, nary)</code> consiste en hacer que
      el simplificador de Maxima reduzca expresiones anidadas; por ejemplo, 
      para transformar <code>foo(x, foo(y, z))</code> a <code>foo(x, y, z)</code>.
</p>
</dd>
<dt> <code>nonarray</code></dt>
<dd><p>      Indica que Maxima no debe considerar <var>a_i</var> como un array. Esta declaración
      evita la evaluación múltiple de variables subindicadas.
</p>
</dd>
<dt> <code>nonscalar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una variable no escalar.
      Se aplica comúnmente para declarar una variable como un vector simbólico
      o una matriz simbólica.
</p>
</dd>
<dt> <code>noun</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como un nombre. El efecto
      que se obtiene es que se reemplazan todas las expresiones <var>a_i</var>
      por <code>'<var>a_i</var></code> o <code>nounify (<var>a_i</var>)</code>,
      dependiendo del contexto.
</p>
</dd>
<dt> <code>outative</code></dt>
<dd><p>      Hace que Maxima simplifique las expresiones <var>a_i</var>
      extrayendo los factores constantes del primer argumento.
</p>
<p>      Cuando <var>a_i</var> tenga un único argumento, un factor se considerará constante
      si es una constante literal o declarada.
</p>
<p>      Cuando <var>a_i</var> tenga dos o más argumentos, un factor se considerará constante
      si el segundo argumento es un símbolo y el factor no contiene al
      segundo argumento.
</p>
</dd>
<dt> <code>posfun</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una función positiva.
</p>
</dd>
<dt> <code>rational, irrational</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable real racional o irracional.
</p>
</dd>
<dt> <code>real, imaginary, complex</code></dt>
<dd><p>      Hace que Maxima reconozca a <var>a_i</var> como una variable real, imaginaria o compleja.
</p>
</dd>
<dt> <code>scalar</code></dt>
<dd><p>      Hace que Maxima considere a <var>a_i</var> como una variable escalar.
</p>
</dd>
</dl>

<p>Ejemplos sobre el uso de estas propiedades están disponibles en la 
documentación correspondiente a cada propiedad por separado.
</p></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>decreasing</b>
<a name="IDX420"></a>
</dt>
<dt><u>Propiedad:</u> <b>increasing</b>
<a name="IDX421"></a>
</dt>
<dd><p>Las instrucciones <code>declare(<var>f</var>, decreasing)</code> y
<code>declare(<var>f</var>, increasing</code> le indican a Maxima que reconozca la función
<var>f</var> como una función decreciente o creciente.
</p>
<p>Véase también <code>declare</code> para más propiedades.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) assume(a &gt; b);
(%o1)                        [a &gt; b]
(%i2) is(f(a) &gt; f(b));
(%o2)                        unknown
(%i3) declare(f, increasing);
(%o3)                         done
(%i4) is(f(a) &gt; f(b));
(%o4)                         true
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>even</b>
<a name="IDX422"></a>
</dt>
<dt><u>Propiedad:</u> <b>odd</b>
<a name="IDX423"></a>
</dt>
<dd><p><code>declare(<var>a</var>, even)</code> y <code>declare(<var>a</var>, odd)</code> le indican a Maxima
que reconozca el símbolo <var>a</var> como entero par o impar.  Las
propiedades <code>even</code> y <code>odd</code> no son reconocidas por las funciones 
<code>evenp</code>, <code>oddp</code> y <code>integerp</code>.
</p>
<p>Véanse también <code>declare</code> y <code>askinteger</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(n, even);
(%o1)                         done
(%i2) askinteger(n, even);
(%o2)                          yes
(%i3) askinteger(n);
(%o3)                          yes
(%i4) evenp(n);
(%o4)                         false
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>feature</b>
<a name="IDX424"></a>
</dt>
<dd><p>Maxima interpreta dos tipos diferentes de propiedades, del sistema y las que
se aplican a expresiones matemáticas. Véase <code>status</code> para obtener
información sobre propiedades del sistema, así como
<code>features</code> y <code>featurep</code> para propiedades de las expresiones matemáticas.
</p>
<p><code>feature</code> no es el nombre de ninguna función o variable.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>featurep</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX425"></a>
</dt>
<dd><p>Intenta determinar si el objeto <var>a</var> tiene la propiedad <var>f</var> en base a los
hechos almacenados en la base de datos. En caso afirmativo, devuelve <code>true</code>,
o <code>false</code> en caso contrario.
</p>
<p>Nótese que <code>featurep</code> devuelve <code>false</code> cuando no se puedan verificar ni
<var>f</var> ni su negación.
</p>
<p><code>featurep</code> evalúa su argumento.
</p>
<p>Véanse también <code>declare</code> y <code>features</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (j, even)$
(%i2) featurep (j, integer);
(%o2)                           true
</pre></dd></dl>



<dl>
<dt><u>Declaración:</u> <b>features</b>
<a name="IDX426"></a>
</dt>
<dd><p>Maxima reconoce ciertas propiedades matemáticas sobre funciones y variables.
</p>
<p>La llamada <code>declare (<var>x</var>, <var>foo</var>)</code> asocia la propiedad <var>foo</var> a la función o variable <var>x</var>.
</p>
<p>La llamada <code>declare (<var>foo</var>, feature)</code> declara una nueva propiedad <var>foo</var>. 
Por ejemplo, <code>declare ([rojo, verde, azul], feature)</code> declara tres nuevas propiedades, 
<code>rojo</code>, <code>verde</code> y <code>azul</code>.
</p>
<p>El predicado <code>featurep (<var>x</var>, <var>foo</var>)</code>
devuelve <code>true</code> si <var>x</var> goza de la propiedad <var>foo</var>, y <code>false</code> en caso contrario.
</p>
<p>La lista <code>features</code> contiene las propiedades que reconoce Maxima; a saber,
</p>
<pre class="verbatim">   integer        noninteger      even
   odd            rational        irrational
   real           imaginary       complex
   analytic       increasing      decreasing
   oddfun         evenfun         posfun
   commutative    lassociative    rassociative
   symmetric      antisymmetric
</pre>
<p>junto con las definidas por el usuario.
</p>
<p>La lista <code>features</code> sólo contiene propiedades matemáticas. 
Hay otra lista con propiedades no matemáticas; Véase <code>status</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>get</b><i> (<var>a</var>, <var>i</var>)</i>
<a name="IDX427"></a>
</dt>
<dd><p>Recupera la propiedad de usuario indicada por <var>i</var> asociada al átomo <var>a</var> 
o devuelve <code>false</code> si <var>a</var> no tiene la propiedad <var>i</var>.
</p>
<p>La función <code>get</code> evalúa sus argumentos.
</p>
<p>Véanse también <code>put</code> y <code>qput</code>.
</p>
<pre class="example">(%i1) put (%e, 'transcendental, 'type);
(%o1)                    transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error(expr,&quot;is not numeric.&quot;)) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)  [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)     [transcendental, [algebraic, transcendental]]
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>integer</b>
<a name="IDX428"></a>
</dt>
<dt><u>Propiedad:</u> <b>noninteger</b>
<a name="IDX429"></a>
</dt>
<dd><p><code>declare(<var>a</var>, integer)</code> o <code>declare(<var>a</var>, noninteger)</code> indica a
Maxima que reconozca <var>a</var> como una variable entera o no entera.
</p>
<p>Véase también <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) declare(n, integer, x, noninteger);
(%o1)                         done
(%i2) askinteger(n);
(%o2)                          yes
(%i3) askinteger(x);
(%o3)                          no
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>integervalued</b>
<a name="IDX430"></a>
</dt>
<dd><p><code>declare(<var>f</var>, integervalued)</code> indica a MAxima que reconozca <var>f</var> como
una función que toma valores enteros.
</p>
<p>Véase también <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) exp(%i)^f(x);
                              %i f(x)
(%o1)                      (%e  )
(%i2) declare(f, integervalued);
(%o2)                         done
(%i3) exp(%i)^f(x);
                              %i f(x)
(%o3)                       %e
</pre></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>nonarray</b>
<a name="IDX431"></a>
</dt>
<dd><p>La instrucción <code>declare(a, nonarray)</code> le indica a Maxima que
no considere <var>a</var> como un array. Esta declaración evita la 
evaluación múltiple de <var>a</var>, si ésta es una variable subindicada.
</p>
<p>Véase también <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
</pre></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>nonscalar</b>
<a name="IDX432"></a>
</dt>
<dd><p>Hace que los átomos se comporten como hace una lista o matriz 
con respecto del operador <code>.</code> del la multiplicación no conmutativa.
</p>
<p>Véase también <code>declare</code>.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>nonscalarp</b><i> (<var>expr</var>)</i>
<a name="IDX433"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> no es escalar, es decir, 
si contiene átomos declarados como no escalares, listas o matrices. 
</p></dd></dl>


<dl>
<dt><u>Declaración:</u> <b>posfun</b>
<a name="IDX434"></a>
</dt>
<dd><p>La instrucción <code>declare (f, posfun)</code> declara a <code>f</code> como 
función positiva, de forma que 
<code>is (f(x) &gt; 0)</code> devolverá <code>true</code>.
</p>
<p>Véase también <code>declare</code>.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>printprops</b><i> (<var>a</var>, <var>i</var>)</i>
<a name="IDX435"></a>
</dt>
<dt><u>Función:</u> <b>printprops</b><i> ([<var>a_1</var>, ..., <var>a_n</var>], <var>i</var>)</i>
<a name="IDX436"></a>
</dt>
<dt><u>Función:</u> <b>printprops</b><i> (all, <var>i</var>)</i>
<a name="IDX437"></a>
</dt>
<dd><p>Muestra la propiedad con el indicador <var>i</var> asociado 
con el átomo <var>a</var>. <var>a</var> puede ser también una lista de
átomos o el átomo <code>all</code> en cuyo caso todos los átomos a los cuales se les haya dado esa propiedad serán usados. 
Por ejemplo, <code>printprops ([f, g], atvalue)</code>. <code>printprops</code> es 
para propiedades que no pueden ser mostradas de otra manera, i.e. para
<code>atvalue</code>, <code>atomgrad</code>, <code>gradef</code>, y <code>matchdeclare</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>properties</b><i> (<var>a</var>)</i>
<a name="IDX438"></a>
</dt>
<dd><p>Devuelve una lista con los nombres de todas las propiedades asociadas
al t'omo <var>a</var>.
</p></dd></dl>


<dl>
<dt><u>Variable del sistema:</u> <b>props</b>
<a name="IDX439"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p><code>props</code> son t'omos que tienen asociadas otras propiedades además de las
explícitamente mencionadas en <code>infolists</code>, tales como las
especificadas por <code>atvalue</code>, <code>matchdeclare</code> y la función 
<code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>propvars</b><i> (<var>prop</var>)</i>
<a name="IDX440"></a>
</dt>
<dd><p>Devuelve la lista con los átomos de la lista <code>props</code> que tienen
la propiedad indicada por <var>prop</var>. Así, <code>propvars (atvalue)</code> 
devuelve la lista con los átomos a los que se les ha asociado valores con
<code>atvalue</code>.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>put</b><i> (<var>átomo</var>, <var>valor</var>, <var>indicador</var>)</i>
<a name="IDX441"></a>
</dt>
<dd><p>Asigna el <var>valor</var> a la propiedad  (especificada por <var>indicador</var>) de <var>átomo</var>;
<var>indicador</var> puede ser el nombre de cualquier propiedad y no solamente de aquellas definidas por el sistema.
</p>
<p><code>rem</code> deshace la asignación realizada por <code>put</code>.
</p>
<p>La función <code>put</code> evalúa sus argumentos y devuelve <var>valor</var>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) put (foo, (a+b)^5, expr);
                                   5
(%o1)                       (b + a)
(%i2) put (foo, &quot;Hello&quot;, str);
(%o2)                         Hello
(%i3) properties (foo);
(%o3)            [[user properties, str, expr]]
(%i4) get (foo, expr);
                                   5
(%o4)                       (b + a)
(%i5) get (foo, str);
(%o5)                         Hello
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>qput</b><i> (<var>átomo</var>, <var>valor</var>, <var>indicador</var>)</i>
<a name="IDX442"></a>
</dt>
<dd><p>Asigna <var>valor</var> a la propiedad de <var>átomo</var> que especifique <var>indicador</var>.
Actúa del mismo modeo que <code>put</code>, excepto que sus argumentos no son evaluados.
</p>
<p>Véase también <code>get</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) foo: aa$ 
(%i2) bar: bb$
(%i3) baz: cc$
(%i4) put (foo, bar, baz);
(%o4)                          bb
(%i5) properties (aa);
(%o5)                [[user properties, cc]]
(%i6) get (aa, cc);
(%o6)                          bb
(%i7) qput (foo, bar, baz);
(%o7)                          bar
(%i8) properties (foo);
(%o8)            [value, [user properties, baz]]
(%i9) get ('foo, 'baz);
(%o9)                          bar
</pre></dd></dl>




<dl>
<dt><u>Propiedad:</u> <b>rational</b>
<a name="IDX443"></a>
</dt>
<dt><u>Propiedad:</u> <b>irrational</b>
<a name="IDX444"></a>
</dt>
<dd><p><code>declare(<var>a</var>, rational)</code> o <code>declare(<var>a</var>, irrational)</code> indica a
Maxima que reconozca <var>a</var> como una variable real racional o irracional.
</p>
<p>Véase también <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Propiedad:</u> <b>real</b>
<a name="IDX445"></a>
</dt>
<dt><u>Propiedad:</u> <b>imaginary</b>
<a name="IDX446"></a>
</dt>
<dt><u>Propiedad:</u> <b>complex</b>
<a name="IDX447"></a>
</dt>
<dd><p><code>declare(<var>a</var>, real)</code>, <code>declare(<var>a</var>, imaginary)</code> o
<code>declare(<var>a</var>, complex)</code> indican a Maxima que reconozca <var>a</var> como variable real,
imaginaria puro o compleja, respectivamente.
</p>
<p>Véase también <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>rem</b><i> (<var>átomo</var>, <var>indicador</var>)</i>
<a name="IDX448"></a>
</dt>
<dd><p>Elimina del <var>átomo</var> la propiedad indicada por <var>indicador</var>.
<code>rem</code> deshace la asignación realizada por <code>put</code>.
</p>
<p><code>rem</code> devuelve <code>done</code> si <var>átomo</var> tenía la 
propiedad <var>indicador</var> cuando <code>rem</code> fue invocado, devolviendo
<code>false</code> si carecía tal propiedad.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>remove</b><i> (<var>a_1</var>, <var>p_1</var>, ..., <var>a_n</var>, <var>p_n</var>)</i>
<a name="IDX449"></a>
</dt>
<dt><u>Función:</u> <b>remove</b><i> ([<var>a_1</var>, ..., <var>a_m</var>], [<var>p_1</var>, ..., <var>p_n</var>], ...)</i>
<a name="IDX450"></a>
</dt>
<dt><u>Función:</u> <b>remove</b><i> (&quot;<var>a</var>&quot;, operator)</i>
<a name="IDX451"></a>
</dt>
<dt><u>Función:</u> <b>remove</b><i> (<var>a</var>, transfun)</i>
<a name="IDX452"></a>
</dt>
<dt><u>Función:</u> <b>remove</b><i> (all, <var>p</var>)</i>
<a name="IDX453"></a>
</dt>
<dd><p>Elimina propiedades asociadas con átomos.
</p>
<p>La llamada <code>remove (<var>a_1</var>, <var>p_1</var>, ..., <var>a_n</var>, <var>p_n</var>)</code>
elimina la propiedad <code>p_k</code> del átomo <code>a_k</code>.
</p>
<p>La llamada <code>remove ([<var>a_1</var>, ..., <var>a_m</var>], [<var>p_1</var>, ..., <var>p_n</var>], ...)</code>
elimina las propiedades <code><var>p_1</var>, ..., <var>p_n</var></code> de los átomos <var>a_1</var>, ..., <var>a_m</var>. Puede tener más de un par de listas.
</p>
<p>La llamada <code>remove (all, <var>p</var>)</code> elimina la propiedad <var>p</var> de todos los átomos que la tengan.
</p>
<p>Las propiedades eliminadas pueden ser de las que define el sistema, como 
<code>function</code>, <code>macro</code> o <code>mode_declare</code>; <code>remove</code> no elimina
las propiedades definidas por <code>put</code>.
</p>
<p>La llamada <code>remove (&quot;<var>a</var>&quot;, operator)</code> o su equivalente <code>remove (&quot;<var>a</var>&quot;, op)</code> elimina de  <var>a</var> las propiedades de operador declaradas por <code>prefix</code>, <code>infix</code>, <code>nary</code>, <code>postfix</code>, <code>matchfix</code> o <code>nofix</code>. Nótese que el nombre del operador debe escribirse como cadena precedida de apóstrofo.
</p>
<p>La función <code>remove</code> devuelve siempre <code>done</code> independientemente que haya algún átomo con la propiedad especificada.
</p>
<p>La función <code>remove</code> no evalúa sus argumentos.
</p></dd></dl>


<dl>
<dt><u>Propiedad:</u> <b>scalar</b>
<a name="IDX454"></a>
</dt>
<dd><p><code>declare(<var>a</var>, scalar)</code> indica a Maxima que considere a <var>a</var> como
una variable escalar.
</p>
<p>Véase también <code>declare</code>.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>scalarp</b><i> (<var>expr</var>)</i>
<a name="IDX455"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es un número, constante  o variable 
declarada como <code>scalar</code> con <code>declare</code>, o compuesta completamente de tales 
números, constantes o variables, pero que no contengan matrices ni listas.
</p></dd></dl>







<hr size="6">
<a name="Funciones-y-variables-para-los-hechos"></a>
<a name="SEC73"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC72" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC74" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.3 Funciones y variables para los hechos </h2>


<dl>
<dt><u>Función:</u> <b>activate</b><i> (<var>context_1</var>, ..., <var>context_n</var>)</i>
<a name="IDX456"></a>
</dt>
<dd><p>Activa los contextos <var>context_1</var>, ..., <var>context_n</var>.
Los hechos en estos contextos están disponibles para hacer deducciones y extraer información.
Los hechos en estos contextos no se listan al invocar <code>facts ()</code>.
</p>
<p>La variable <code>activecontexts</code> es la lista de contextos que se han activado por medio de la función <code>activate</code>.
</p>
</dd></dl>




<dl>
<dt><u>Variable del sistema:</u> <b>activecontexts</b>
<a name="IDX457"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>activecontexts</code> es la lista de contextos que se han activado por medio de la función <code>activate</code>, pero que no se han activado por ser subcontextos del contexto actual.
</p>
</dd></dl>






<dl>
<dt><u>Función:</u> <b>askinteger</b><i> (<var>expr</var>, integer)</i>
<a name="IDX458"></a>
</dt>
<dt><u>Función:</u> <b>askinteger</b><i> (<var>expr</var>)</i>
<a name="IDX459"></a>
</dt>
<dt><u>Función:</u> <b>askinteger</b><i> (<var>expr</var>, even)</i>
<a name="IDX460"></a>
</dt>
<dt><u>Función:</u> <b>askinteger</b><i> (<var>expr</var>, odd)</i>
<a name="IDX461"></a>
</dt>
<dd><p>La llamada <code>askinteger (<var>expr</var>, integer)</code> intenta determinar a partir de la base de datos de <code>assume</code> si <var>expr</var> es un entero. La función <code>askinteger</code> pide más información al usuario si no encuentra la respuesta,
tratando de almacenar la nueva información en la base de datos si es posible. La llamada 
<code>askinteger (<var>expr</var>)</code> equivale a <code>askinteger (<var>expr</var>, integer)</code>.
</p>
<p>La llamadas <code>askinteger (<var>expr</var>, even)</code> ay <code>askinteger (<var>expr</var>, odd)</code> intentan determinar si <var>expr</var> es un entero par o impar, respectivamente.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>asksign</b><i> (<var>expr</var>)</i>
<a name="IDX462"></a>
</dt>
<dd><p>Primero intenta determinar si la expresión especificada es positiva, negativa o cero.  Si no lo consigue, planteará al usuario preguntas que le ayuden a conpletar la deducción. Las respuestas del usuario son almacenadas en la base de datos durante el tiempo que dure este cálculo. El valor que al final devuelva <code>asksign</code> será <code>pos</code>, <code>neg</code> o <code>zero</code>.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>assume</b><i> (<var>pred_1</var>, ..., <var>pred_n</var>)</i>
<a name="IDX463"></a>
</dt>
<dd><p>Añade los predicados <var>pred_1</var>, ..., <var>pred_n</var> al contexto actual.
Si un predicado es inconsistente o redundante con los otros predicados
del contexto actual, entonces no es añadido al contexto. 
El contexto va acumulando predicados con cada llamada a <code>assume</code>.
</p>
<p>La función <code>assume</code> devuelve una lista cuyos miembros son los 
predicados que han sido añadidos al contexto, o los átomos 
<code>redundant</code> o <code>inconsistent</code> si fuere necesario.
</p>
<p>Los predicados <var>pred_1</var>, ..., <var>pred_n</var> tan solo pueden ser
expresiones formadas con los operadores relacionales <code>&lt; &lt;= equal notequal &gt;=</code>
y <code>&gt;</code>. Los predicados no pueden estar formados por expresiones que sean del
tipo igualdad <code>=</code> ni del tipo desigualdad <code>#</code>, ni tampoco pueden ser
funciones de predicado como <code>integerp</code>.
</p>
<p>En cambio, sí se reconocen predicados compuestos de la forma 
<code><var>pred_1</var> and ... and <var>pred_n</var></code>, pero no 
<code><var>pred_1</var> or ... or <var>pred_n</var></code>.
También se reconoce <code>not <var>pred_k</var></code> si <var>pred_k</var> es un
predicado relacional. Expresiones de la forma <code>not (<var>pred_1</var> and <var>pred_2</var>)</code>
y <code>not (<var>pred_1</var> or <var>pred_2</var>)</code> no son reconocidas.
</p>
<p>El mecanismo deductivo de Maxima no es muy potente; existen muchas 
consecuencias que, siendo obvias, no pueden ser obtenidas por <code>is</code>.
Se trata de una debilidad reconocida.
</p>
<p><code>assume</code> no gestiona predicados con números complejos. Si un
predicado contiene un número complejo, <code>assume</code> devuelve
<code>inconsistent</code> o <code>redunant</code>.
</p>
<p>La función <code>assume</code> evalúa sus argumentos.
</p>
<p>Véanse también <code>is</code>, <code>facts</code>, <code>forget</code>, <code>context</code> y <code>declare</code>.
</p>
<p>Ejemplos:
</p>

<pre class="example">(%i1) assume (xx &gt; 0, yy &lt; -1, zz &gt;= 0);
(%o1)              [xx &gt; 0, yy &lt; - 1, zz &gt;= 0]
(%i2) assume (aa &lt; bb and bb &lt; cc);
(%o2)                  [bb &gt; aa, cc &gt; bb]
(%i3) facts ();
(%o3)     [xx &gt; 0, - 1 &gt; yy, zz &gt;= 0, bb &gt; aa, cc &gt; bb]
(%i4) is (xx &gt; yy);
(%o4)                         true
(%i5) is (yy &lt; -yy);
(%o5)                         true
(%i6) is (sinh (bb - aa) &gt; 0);
(%o6)                         true
(%i7) forget (bb &gt; aa);
(%o7)                       [bb &gt; aa]
(%i8) prederror : false;
(%o8)                         false
(%i9) is (sinh (bb - aa) &gt; 0);
(%o9)                        unknown
(%i10) is (bb^2 &lt; cc^2);
(%o10)                       unknown
</pre>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>assumescalar</b>
<a name="IDX464"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>assumescalar</code> ayuda a controlar si una expresión <code>expr</code> para la cual <code>nonscalarp (expr)</code> es <code>false</code> va a tener un comportamiento similar a un escalar bajo ciertas transformaciones.
</p>
<p>Sea <code>expr</code> cualquier expresión distinta de una lista o matriz, y sea también <code>[1, 2, 3]</code> una lista o una matriz. Entonces, <code>expr . [1, 2, 3]</code> dará como resultado <code>[expr, 2 expr, 3 expr]</code> si <code>assumescalar</code> es <code>true</code>, o si <code>scalarp (expr)</code> es <code>true</code>, o si <code>constantp (expr)</code> es <code>true</code>.
</p>
<p>Si <code>assumescalar</code> vale <code>true</code>, la expresión se comportará como un escalar sólo en operaciones conmutativas, pero no en el caso de la multiplicación no conmutativa o producto matricial <code>.</code>.
</p>
<p>Si <code>assumescalar</code> vale <code>false</code>, la expresión se comportará como un no escalar.
</p>
<p>Si <code>assumescalar</code> vale <code>all</code>, la expresión se comportará como un escalar para todas las operaciones.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>assume_pos</b>
<a name="IDX465"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>assume_pos</code> vale <code>true</code> y el signo de un parámetro <var>x</var> no puede ser determinado a partir del contexto actual o de otras consideraciones, <code>sign</code> y <code>asksign (<var>x</var>)</code> devolverán <code>true</code>. Con esto se pueden evitar algunas preguntas al usuario que se generan automáticamente, como las que hacen <code>integrate</code> y otras funciones.
</p>
<p>By default, a parameter is <var>x</var> such that <code>symbolp (<var>x</var>)</code>
or <code>subvarp (<var>x</var>)</code>.
</p>
<p>Por defecto, un parámetro <var>x</var> es aquel para el que <code>symbolp (<var>x</var>)</code> o <code>subvarp (<var>x</var>)</code> devuelven <code>true</code>.
La clase de expresiones que se consideran parámetros se puede extender mediante la utilización de la variable <code>assume_pos_pred</code>.
</p>
<p>Las funciones <code>sign</code> y <code>asksign</code> intentan deducir el signo de una expresión a partir de los signos de los operandos que contiene. Por ejemplo, si <code>a</code> y <code>b</code> son ambos positivos, entonces <code>a + b</code> también es positivo.
</p>
<p>Sin embargo, no es posible obviar todas las preguntas que hace <code>asksign</code>. En particular, cuando el argumento de <code>asksign</code> es una diferencia <code><var>x</var> - <var>y</var></code> o un logaritmo <code>log(<var>x</var>)</code>, <code>asksign</code> siempre solicita una respuesta por parte del usuario, incluso cuando <code>assume_pos</code> vale <code>true</code> y <code>assume_pos_pred</code> es una función que devuelve <code>true</code> para todos los argumentos.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>assume_pos_pred</b>
<a name="IDX466"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando a <code>assume_pos_pred</code> se le asigna el nombre de una función o una expresión lambda de un único argumento <var>x</var>, ésta será invocada para determinar si <var>x</var> se considera un parámetro por <code>assume_pos</code>. La variable 
<code>assume_pos_pred</code> se ignora cuando <code>assume_pos</code> vale <code>false</code>.
</p>
<p>La función <code>assume_pos_pred</code> es invocada por  <code>sign</code> y por <code>asksign</code> con un argumento <var>x</var>, el cual puede ser un átomo, una variable subindicada o una expresión de llamada a una función. Si la función <code>assume_pos_pred</code> devuelve <code>true</code>, <var>x</var> será considerada como un parámetro por <code>assume_pos</code>.
</p>
<p>Por defecto, un parámetro <var>x</var> es aquel para el que <code>symbolp (<var>x</var>)</code> o <code>subvarp (<var>x</var>)</code> devuelven <code>true</code>.
</p>
<p>Véanse también <code>assume</code> y <code>assume_pos</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) assume_pos: true$
(%i2) assume_pos_pred: symbolp$
(%i3) sign (a);
(%o3)                          pos
(%i4) sign (a[1]);
(%o4)                          pnz
(%i5) assume_pos_pred: lambda ([x], display (x), true)$
(%i6) asksign (a);
                              x = a

(%o6)                          pos
(%i7) asksign (a[1]);
                             x = a
                                  1

(%o7)                          pos
(%i8) asksign (foo (a));
                           x = foo(a)

(%o8)                          pos
(%i9) asksign (foo (a) + bar (b));
                           x = foo(a)

                           x = bar(b)

(%o9)                          pos
(%i10) asksign (log (a));
                              x = a

Is  a - 1  positive, negative, or zero?

p;
(%o10)                         pos
(%i11) asksign (a - b);
                              x = a

                              x = b

                              x = a

                              x = b

Is  b - a  positive, negative, or zero?

p;
(%o11)                         neg
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>context</b>
<a name="IDX467"></a>
</dt>
<dd><p>Valor por defecto: <code>initial</code>
</p>
<p>La variable <code>context</code> da nombre al conjunto de hechos establecidos desde <code>assume</code> y <code>forget</code>. La función <code>assume</code> añade nuevos hechos al conjunto nombrado por <code>context</code>, mientras que <code>forget</code> los va eliminando.
Asignando a <code>context</code> un nuevo nombre <var>foo</var> cambia el contexto actual a <var>foo</var>. Si el contexto <var>foo</var> no existe todavía, se crea automáticamente mediante una llamada a <code>newcontext</code>.
</p>
<p>Véase <code>contexts</code> para una descripción general del mecanismo que siguen los contextos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>contexts</b>
<a name="IDX468"></a>
</dt>
<dd><p>Valor por defecto: <code>[initial, global]</code>
</p>
<p>La variable <code>contexts</code> es una lista que contiene los contextos existentes, incluyendo el actualmente activo.
</p>
<p>El mecanismo que siguen los contextos permiten al usuario agrupar y nombrar un conjunto de hechos, que recibe el nombre de contexto. Una vez hecho esto, el usuario puede hacer que Maxima tenga en cuenta o que olvide cualquier número de hechos sin más que activar o desactivar su contexto.
</p>
<p>Cualquier átomo simbólico puede ser el nombre de un contexto, y los hechos contenidos en tal contexto pueden ser almacenados hasta que se destruyan uno a uno mediante llamadas a la función <code>forget</code>, o que se destruyan conjuntamente invocando a <code>kill</code> para eliminar el contexto al que pertenecen.
</p>
<p>Los contextos tienen estructura jerárquica, siendo su raíz el contexto <code>global</code>, el cual contiene información sobre Maxima que necesitan algunas funciones. Cuando en un contexto todos los hechos están activos (lo que significa que están siendo utilizados en deducciones) lo estarán también en cualquier subcontexto del contexto actual.
</p>
<p>Cuando se comienza una sesión de Maxima, el usuario estará trabajando en un contexto llamado <code>initial</code>, el cual tiene un subcontexto de nombre <code>global</code>.
</p>
<p>Véanse también <code>facts</code>, <code>newcontext</code>, <code>supcontext</code>, <code>killcontext</code>, <code>activate</code>, <code>deactivate</code>, <code>assume</code> y <code>forget</code>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>deactivate</b><i> (<var>contexto_1</var>, ..., <var>contexto_n</var>)</i>
<a name="IDX469"></a>
</dt>
<dd><p>Desactiva los contextos especificados <var>contexto_1</var>, ..., <var>contexto_n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>facts</b><i> (<var>item</var>)</i>
<a name="IDX470"></a>
</dt>
<dt><u>Función:</u> <b>facts</b><i> ()</i>
<a name="IDX471"></a>
</dt>
<dd><p>Si <var>item</var> es el nombre de un contexto,
<code>facts (<var>item</var>)</code> devuelve una lista
con los hechos asociados al contexto especificado.
</p>
<p>Si <var>item</var> no es el nombre de un contexto,
<code>facts (<var>item</var>)</code> devuelve una lista con los hechos conocidos acerca de <var>item</var> en el contexto actual. Los hechos que estén activos en contextos diferentes no aparecen en la lista.
</p>
<p>La llamada <code>facts ()</code>, sin argumentos, muestra el contexto actual.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>forget</b><i> (<var>pred_1</var>, ..., <var>pred_n</var>)</i>
<a name="IDX472"></a>
</dt>
<dt><u>Función:</u> <b>forget</b><i> (<var>L</var>)</i>
<a name="IDX473"></a>
</dt>
<dd><p>Borra los predicados establecidos por <code>assume</code>. Los predicados pueden ser expresiones equivalentes, pero no necesariamente idénticas, a las establecidas por <code>assume</code>.
</p>
<p>La llamada <code>forget (<var>L</var>)</code>, siendo <var>L</var> una lista de predicados, borra todos los predicados contenidos en ella.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>is</b><i> (<var>expr</var>)</i>
<a name="IDX474"></a>
</dt>
<dd><p>Intenta determinar si el predicado <var>expr</var>  se puede deducir de los hechos almacenados en la base de datos gestionada por <code>assume</code>.
</p>
<p>Si el predicado se reduce a <code>true</code> o <code>false</code>,
<code>is</code> devuelve <code>true</code> o <code>false</code>, respectivamente.
En otro caso, el valor devuelto está controlado por la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, <code>is</code> emite un mensaje de error;
en caso contrario, <code>is</code> devuelve <code>unknown</code>.
</p>
<p>La instrucción <code>ev(<var>expr</var>, pred)</code>
(que puede escribirse como <code><var>expr</var>, pred</code> en el
modo interactivo) equivale a <code>is(<var>expr</var>)</code>.
</p>
<p>Véanse también <code>assume</code>, <code>facts</code> y <code>maybe</code>.
</p>
<p>Ejemplos:
</p>
<p><code>is</code> evalúa los predicados,
</p>
<pre class="example">(%i1) %pi &gt; %e;
(%o1)                       %pi &gt; %e
(%i2) is (%pi &gt; %e);
(%o2)                         true
</pre>
<p><code>is</code> intenta evaluar predicados a partir 
del conocimiento almacenado en la base de datos de <code>assume</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) assume (b &gt; c);
(%o2)                        [b &gt; c]
(%i3) is (a &lt; b);
(%o3)                         false
(%i4) is (a &gt; c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
</pre>
<p>Si <code>is</code> no puede evaluar el valor lógico del predicado 
a partir de la base de datos gestionada por <code>assume</code>,
la variable global  <code>prederror</code> controla el comportamiento de <code>is</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) prederror: true$
(%i3) is (a &gt; 0);
Maxima was unable to evaluate the predicate:
a &gt; 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a &gt; 0);
(%o5)                        unknown
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>killcontext</b><i> (<var>contexto_1</var>, ..., <var>contexto_n</var>)</i>
<a name="IDX475"></a>
</dt>
<dd><p>Elimina los contextos <var>contexto_1</var>, ..., <var>contexto_n</var>.
</p>
<p>Si alguno de estos contextos es el actual, el nuevo contexto activo será el primer subcontexto disponible del actual que no haya sido eliminado. Si el primer contexto no eliminado disponible es <code>global</code> entonces <code>initial</code> será usado en su lugar.  Si el contexto <code>initial</code> es eliminado, se creará un nuevo contexto <code>initial</code> completamente vacío.
</p>
<p>La función <code>killcontext</code> no elimina un contexto actualmente activo si es un subcontexto del contexto actual, o si se hace uso de la función <code>activate</code>.
</p>
<p>La función <code>killcontext</code> evalúa sus argumentos y devuelve <code>done</code>.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>maybe</b><i> (<var>expr</var>)</i>
<a name="IDX476"></a>
</dt>
<dd><p>Intenta determinar si el predicado <var>expr</var>  se puede deducir de los hechos almacenados en la base de datos gestionada por <code>assume</code>.
</p>
<p>Si el predicado se reduce a <code>true</code> o <code>false</code>,
<code>maybe</code> devuelve <code>true</code> o <code>false</code>, respectivamente.
En otro caso, <code>maybe</code> devuelve <code>unknown</code>.
</p>
<p>La función <code>maybe</code> es funcionalmente equivalente a <code>is</code> con <code>prederror: false</code>,
pero el resultado se calcula sin asignar valor alguno a <code>prederror</code>.
</p>
<p>Véanse también <code>assume</code>, <code>facts</code> y <code>is</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) maybe (x &gt; 0);
(%o1)                        unknown
(%i2) assume (x &gt; 1);
(%o2)                        [x &gt; 1]
(%i3) maybe (x &gt; 0);
(%o3)                         true
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>newcontext</b><i> (<var>nombre</var>)</i>
<a name="IDX477"></a>
</dt>
<dd><p>Crea un nuevo contexto vacío <var>nombre</var>, el cual tiene a <code>global</code> como su único subcontexto. El recién creado contexto pasa a ser el contexto actualmente activo.
</p>
<p>La función <code>newcontext</code> evalúa sus argumentos y devuelve <var>nombre</var>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>sign</b><i> (<var>expr</var>)</i>
<a name="IDX478"></a>
</dt>
<dd><p>Intenta determinar el signo de <var>expr</var> en base a los hechos almacenados en la base de datos. Devuelve una de las siguientes respuestas: <code>pos</code> (positivo), <code>neg</code> (negativo), <code>zero</code> (cero), <code>pz</code>
(positivo o cero), <code>nz</code> (negativo o cero), <code>pn</code> (positivo o negativo),
o <code>pnz</code> (positivo, negativo o cero, lo que significa que el signo es desconocido).
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>supcontext</b><i> (<var>nombre</var>, <var>contexto</var>)</i>
<a name="IDX479"></a>
</dt>
<dt><u>Función:</u> <b>supcontext</b><i> (<var>nombre</var>)</i>
<a name="IDX480"></a>
</dt>
<dd><p>Crea un nuevo contexto <var>nombre</var>, que tiene a <var>contexto</var> como subcontexto. El argumento
<var>contexto</var> debe existir ya.
</p>
<p>Si no se especifica <var>context</var>, se tomará como tal el actual.
</p>
</dd></dl>









<hr size="6">
<a name="Funciones-y-variables-para-los-predicados"></a>
<a name="SEC74"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC73" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.4 Funciones y variables para los predicados </h2>


<dl>
<dt><u>Función:</u> <b>charfun</b><i> (<var>p</var>)</i>
<a name="IDX481"></a>
</dt>
<dd><p>Devuelve 0 cuando el predicado <var>p</var> toma el valor <code>false</code>, y devuelve
1 cuando vale <code>true</code>.  Si el predicado toma un valor diferente de <code>true</code> y <code>false</code> (desconocido), 
entonces devuelve una forma nominal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) charfun(x&lt;1);
(%o1) charfun(x&lt;1)
(%i2) subst(x=-1,%);
(%o2) 1
(%i3) e : charfun('&quot;and&quot;(-1 &lt; x, x &lt; 1))$
(%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
(%o4) [0,1,0]
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>compare</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX482"></a>
</dt>
<dd><p>Devuelve un operador de comparación <var>op</var>
(<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>=</code> o <code>#</code>) de manera que
<code>is (<var>x</var> <var>op</var> <var>y</var>)</code> tome el valor <code>true</code>;
cuando tanto <var>x</var> como <var>y</var> dependan de <code>%i</code> y
<code><var>x</var> # <var>y</var></code>, devuelve <code>notcomparable</code>;
cuando no exista tal operador o Maxima sea incapaz de determinarlo, devolverá <code>unknown</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) compare(1,2);
(%o1) &lt;
(%i2) compare(1,x);
(%o2) unknown
(%i3) compare(%i,%i);
(%o3) =
(%i4) compare(%i,%i+1);
(%o4) notcomparable
(%i5) compare(1/x,0);
(%o5) #
(%i6) compare(x,abs(x));
(%o6) &lt;=
</pre>
<p>La función <code>compare</code> no intenta determinar si los dominios reales de sus argumentos son conjuntos no vacíos; así,
</p>
<pre class="example">(%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
(%o1) &lt;
</pre>
<p>Aquí, el dominio real de <code>acos (x^2 + 1)</code> es el conjunto vacío.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>equal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX483"></a>
</dt>
<dd><p>Representa la equivalencia, esto es, la igualdad de los valores.
</p>
<p>Por sí misma, <code>equal</code> no evalúa ni simplifica.
La función <code>is</code> intenta evaluar <code>equal</code> a un resultado
booleano. La instrucción <code>is(equal(<var>a</var>, <var>b</var>))</code>
devuelve <code>true</code> (o <code>false</code>) si y sólo si
<var>a</var> y <var>b</var> son iguales (o no iguales) para todos los posibles
valores de sus variables, tal como lo determina <code>ratsimp(<var>a</var> - <var>b</var>)</code>;
si <code>ratsimp</code> devuelve 0, las dos expresiones se consideran
equivalentes. Dos expresiones pueden ser equivalentes  sin
ser sintácticamente iguales (es decir, idénticas).
</p>
<p>Si <code>is</code> no consigue reducir <code>equal</code> a <code>true</code> o <code>false</code>,
el resultado está controlado por la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, <code>is</code> emite un mensaje
de error; en caso contrario, <code>is</code> devuelve <code>unknown</code>.
</p>
<p>Además de <code>is</code>, otros operadores evalúan <code>equal</code> y <code>notequal</code>
a  <code>true</code> o <code>false</code>; a saber, <code>if</code>, <code>and</code>, <code>or</code> y <code>not</code>.
</p>
<p>La negación de <code>equal</code> es <code>notequal</code>.
</p>
<p>Ejemplos:
</p>
<p>Por sí misma, <code>equal</code> no evalúa ni simplifica.
</p>
<pre class="example">(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
</pre>
<p>La función <code>is</code> intenta evaluar <code>equal</code> a un resultado
booleano. La instrucción <code>is(equal(<var>a</var>, <var>b</var>))</code>
devuelve <code>true</code> si <code>ratsimp(<var>a</var> - <var>b</var>)</code>
devuelve 0. Dos expresiones pueden ser equivalentes  sin
ser sintácticamente iguales (es decir, idénticas).
</p>
<pre class="example">(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
</pre>
<p>Si <code>is</code> no consigue reducir <code>equal</code> a <code>true</code> o <code>false</code>,
el resultado está controlado por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
</pre>
<p>Otros operadores evalúan <code>equal</code> y <code>notequal</code>
a  <code>true</code> o <code>false</code>.
</p>
<pre class="example">(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
</pre>
<p>Debido a que <code>not <var>expr</var></code>
obliga a la evaluación previa de <var>expr</var>, 
<code>not equal(<var>a</var>, <var>b</var>)</code> equivale a <code>is(notequal(<var>a</var>, <var>b</var>))</code>.
</p>
<pre class="example">(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
</pre></dd></dl>




<dl>
<dt><u>Función:</u> <b>notequal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX484"></a>
</dt>
<dd><p>Representa la negación de <code>equal (<var>a</var>, <var>b</var>)</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a &gt; b);
(%o6)                        [a &gt; b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>unknown</b><i> (<var>expr</var>)</i>
<a name="IDX485"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si <var>expr</var> contiene un operador o función no reconocido por el simplificador de Maxima.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>zeroequiv</b><i> (<var>expr</var>, <var>v</var>)</i>
<a name="IDX486"></a>
</dt>
<dd><p>Analiza si la expresión <var>expr</var> de variable <var>v</var> equivale a cero, devolviendo <code>true</code>, <code>false</code> o
<code>dontknow</code>.
</p>
<p>La función <code>zeroequiv</code> tiene estas restricciones:
</p><ol>
<li>
No utilizar funciones que Maxima no sepa derivar y evaluar.
</li><li>
Si la expresión tiene polos en la recta real, pueden aparecer errores en el resultado, aunque es poco probable.
</li><li>
Si la expresión contiene funciones que no son soluciones de ecuaciones diferenciales ordinarias de primer orden (como las funciones de Bessel) pueden presentarse resultados incorrectos.
</li><li>
El algoritmo utiliza evaluaciones en puntos aleatoriamente seleccionados. Esto conlleva un riesgo,aunque el algoritmo intenta minimizar el error.
</li></ol>

<p>Por ejemplo, <code>zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)</code> devuelve
<code>true</code> y <code>zeroequiv (%e^x + x, x)</code> devuelve <code>false</code>.
Por otro lado <code>zeroequiv (log(a*b) - log(a) - log(b), a)</code> devuelve <code>dontknow</code> debido a la presencia del parámetro <code>b</code>.
</p>
</dd></dl>




<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_12.html#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>octubre, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
