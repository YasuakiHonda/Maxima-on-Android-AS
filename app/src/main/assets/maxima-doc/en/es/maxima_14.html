<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on octubre, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.41.0: 14. Polinomios</title>

<meta name="description" content="Manual de Maxima 5.41.0: 14. Polinomios">
<meta name="keywords" content="Manual de Maxima 5.41.0: 14. Polinomios">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Polinomios"></a>
<a name="SEC88"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_13.html#SEC87" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC82" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 14. Polinomios </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC89">14.1 Introducción a los polinomios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC90">14.2 Funciones y variables para polinomios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-los-polinomios"></a>
<a name="SEC89"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.1 Introducción a los polinomios </h2>

<p>Los polinomios se almacenan en Maxima, bien en un formato general, bien en una forma conocida como canónica (Cannonical Rational Expressions, CRE). La última corresponde al formato estándar y se utiliza internamente para realizar operaciones como <code>factor</code>, <code>ratsimp</code> y demás.
</p>
<p>Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de representación
que es especialmente apropiado para expandir polinomios y funciones racionales
(así como para polinomios parcialmente factorizados y funciones racionales cuando a la variable <code>ratfac</code> se le asigna el valor <code>true</code>). En esta forma CRE las variables se ordenan de mayor a menor. Los polinomios se representan recursivamente como una lista compuesta por la variable principal seguida por una serie de pares de expresiones,
una por cada término del polinomio. El primer miembro
de cada par es el exponente de la variable principal en ese término y el
segundo miembro es el coeficiente de ese término, el cual puede ser un número o
un polinomio en otra variable representado también de esta forma. Así,
la parte principal de la forma CRE de 3*X^2-1 es (X 2 3 0 -1) y la de
2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0 -3)) asumiendo que Y es la variable principal, y será (X 1 (Y 1 2 0 1) 0 -3) si se asume que la variable principal es X. Qué variable se considera &quot;principal&quot; se determinada en orden alfabético inverso.
Las &quot;variables&quot; de la expresión CRE no son necesariamente atómicas. De hecho
cualquier subexpresión cuyo operador principal no es + - * / ni ^ con potencia entera
puede ser considerada como una &quot;variable&quot; de la expresión (en forma CRE) en 
el cual aparezca. Por ejemplo las variables CRE de la expresión
X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).  Si el usuario no
especifica una ordenación de las variables mediante la función <code>ratvars</code> 
Maxima escogerá una alfabéticamente. En general, laa CRE representan expresiones
racionales, esto es, fracciones de polinomios, donde el numerador y
el denominador  no tienen factores comunes, siendo el denominador es
positivo. La forma interna es esencialmente un par de polinomios (el
numerador y el denominador) precedida por la lista de variables ordenadas. Si
una expresión a ser mostrada está en la forma CRE o contiene alguna
subexpresión en forma de CRE, el simbolo /R/ será seguido por la etiqueta de la línea de comando.
Véase la función <code>rat</code> para convertir una expresión a la forma CRE. Una
extensión de la forma CRE se utiliza para la representación de las series de Taylor. La
noción de una expresión racional se extiende de manera que los exponentes de las
variables pueden ser números racionales positivos o negativos y no sólo
enteros positivos y los coeficientes pueden ser también expresiones
racionales y no sólo polinomios. Estas expresiones se representan internamente por una forma polinomial recursiva que es similar a la forma CRE, pero que la generaliza, aportando información adicional como el grado de truncamiento. Como con la forma CRE, el símbolo /T/ sigue la etiqueta de línea de comando en la que se encuentra dicha expresión.
</p>







<hr size="6">
<a name="Funciones-y-variables-para-polinomios"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.2 Funciones y variables para polinomios </h2>

<dl>
<dt><u>Variable opcional:</u> <b>algebraic</b>
<a name="IDX603"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>algebraic</code> debe valer <code>true</code> para que se pueda hacer la simplificación de enteros algebraicos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>berlefact</b>
<a name="IDX604"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>berlefact</code> vale <code>false</code> entonces se utiliza el algoritmo de factorización de Kronecker, en caso contrario se utilizará el algoritmo de Berlekamp, que es el que se aplica por defecto.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>bezout</b><i> (<var>p1</var>, <var>p2</var>, <var>x</var>)</i>
<a name="IDX605"></a>
</dt>
<dd><p>Es una alternativa a la función <code>resultant</code>.  Devuelve una matriz.
</p>
<pre class="example">(%i1) bezout(a*x+b, c*x^2+d, x);
                         [ b c  - a d ]
(%o1)                    [            ]
                         [  a     b   ]
(%i2) determinant(%);
                            2      2
(%o2)                      a  d + b  c
(%i3) resultant(a*x+b, c*x^2+d, x);
                            2      2
(%o3)                      a  d + b  c
</pre></dd></dl>

<dl>
<dt><u>Función:</u> <b>bothcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX606"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer miembro es el coeficiente de <var>x</var> en <var>expr</var> (que coincide con el que devuelve <code>ratcoef</code> si <var>expr</var> está en formato CRE, o el que devuelve <code>coeff</code> si no está en este formato) y cuyo segundo miembro es la parte restante de <var>expr</var>. Esto es, <code>[A, B]</code> donde <code><var>expr</var> = A*<var>x</var> + B</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>coeff</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX607"></a>
</dt>
<dt><u>Función:</u> <b>coeff</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX608"></a>
</dt>
<dd><p>Devuelve el coeficiente de <code><var>x</var>^<var>n</var></code> en <var>expr</var>,
donde <var>expr</var> es un polinomio o monomio en <var>x</var>.
</p>
<p><code>coeff(<var>expr</var>, <var>x</var>^<var>n</var>)</code> es equivalente a
<code>coeff(<var>expr</var>, <var>x</var>, <var>n</var>)</code>.
<code>coeff(<var>expr</var>, <var>x</var>, 0)</code> devuelve el resto de <var>expr</var>,
el cual no contiene a <var>x</var>. En caso de omisión, se entiende
que <var>n</var> es igual a 1.
</p>
<p><var>x</var> puede ser tanto el nombre de una variable simple como el
de una variable con subíndice, o también una
subexpresión de <var>expr</var> que contenga un operador junto con
todos sus argumentos.
</p>
<p>En ocasiones, es posible calcular los coeficientes de expresiones
equivalentes a <var>expr</var> aplicando <code>expand</code> o <code>factor</code>.
<code>coeff</code> no aplica ni <code>expand</code>, ni <code>factor</code>, ni ninguna otra
función.
</p>
<p><code>coeff</code> se distribuye sobre listas, matrices y ecuaciones.
</p>
<p>Ejemplos:
</p>
<p><code>coeff</code> devuelve el coeficiente de <code><var>x</var>^<var>n</var></code> en <var>expr</var>.
</p>
<pre class="example">(%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                3
(%o1)                          b
</pre>
<p><code>coeff(<var>expr</var>, <var>x</var>^<var>n</var>)</code> es equivalente
a <code>coeff(<var>expr</var>, <var>x</var>, <var>n</var>)</code>.
</p>
<pre class="example">(%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
(%o1)                         - c
                                 3
(%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
(%o2)                         - c
                                 3
</pre>
<p><code>coeff(<var>expr</var>, <var>x</var>, 0)</code> devuelve el resto de <var>expr</var>,
el cual no contiene a <var>x</var>.
</p>
<pre class="example">(%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                            3  3
(%o1)                      c  u  + a u
</pre>
<p><var>x</var> puede ser tanto el nombre de una variable simple como el
de una variable con subíndice, o también una
subexpresión de <var>expr</var> que contenga un operador junto con
todos sus argumentos.
</p>
<pre class="example">(%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
(%o1)                        - 2 %pi
(%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
(%o2)                        - 2 %pi
(%i3) coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
                                3
(%o3)                        sin (x)
(%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
(%o4)                         c - d
</pre>
<p><code>coeff</code> no aplica ni <code>expand</code>, ni <code>factor</code>, ni ninguna otra
función.
</p>
<pre class="example">(%i1) coeff (c*(a + b)^3, a);
(%o1)                           0
(%i2) expand (c*(a + b)^3);
                 3          2        2        3
(%o2)           b  c + 3 a b  c + 3 a  b c + a  c
(%i3) coeff (%, a);
                                2
(%o3)                        3 b  c
(%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
(%o4)                           0
(%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                  3
(%o5)                      (b + a)  c
(%i6) coeff (%, (a + b)^3);
(%o6)                           c
</pre>
<p><code>coeff</code> se distribuye sobre listas, matrices y ecuaciones.
</p>
<pre class="example">(%i1) coeff ([4*a, -3*a, 2*a], a);
(%o1)                      [4, - 3, 2]
(%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                          [  a    b  ]
(%o2)                     [          ]
                          [ - c  - d ]
(%i3) coeff (a*u - b*v = 7*u + 3*v, u);
(%o3)                         a = 7
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>content</b><i> (<var>p_1</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX609"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer miembro es el máximo común divisor de los coeficientes de los términos del polinomio <var>p_1</var> de variable <var>x_n</var> (este es el contenido) y cuyo segundo miembro es el polinomio <var>p_1</var> dividido por el contenido.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>denom</b><i> (<var>expr</var>)</i>
<a name="IDX610"></a>
</dt>
<dd><p>Devuelve el denominador de la expresión racional <var>expr</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>divide</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX611"></a>
</dt>
<dd><p>Calcula el cociente y el resto del polinomio <var>p_1</var> dividido por el polinomio <var>p_2</var>, siendo la variable principal <var>x_n</var>.
Las otras funciones son como en la función <code>ratvars</code>. El resultado es una lista cuyo primer miembro es el cociente y el segundo miembro el resto.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
</pre>

<p>Nótese que <code>y</code> es la variable principal en el segundo ejemplo.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>eliminate</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_k</var>])</i>
<a name="IDX612"></a>
</dt>
<dd><p>Elimina variables de ecuaciones (o de expresiones que se supone valen cero) tomando resultantes sucesivas. Devuelve una lista con <code><var>n</var> - <var>k</var></code> expresiones y <var>k</var> variables <var>x_1</var>, ..., <var>x_k</var> eliminadas.  Primero se elimina  <var>x_1</var> dando <code><var>n</var> - 1</code> expresiones, después se elimina <code>x_2</code>, etc.  Si <code><var>k</var> = <var>n</var></code> entonces se devuelve una lista con una única expresión, libre de las variables <var>x_1</var>, ..., <var>x_k</var>. En este caso se llama a <code>solve</code> para resolver la última resultante para la última variable.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ezgcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>p_3</var>, ...)</i>
<a name="IDX613"></a>
</dt>
<dd><p>Devuelve una lista cuyo primer elemento es el máximo común divisor (mcd)
de los polinomios <var>p_1</var>, <var>p_2</var>, <var>p_3</var>, &hellip;,  siendo los 
miembros restantes los mismos polinomios divididos por el mcd. 
Se utiliza siempre el algoritmo <code>ezgcd</code>.
</p>
<p>Véanse también <code>gcd</code>, <code>gcdex</code>, <code>gcdivide</code> y <code>poly_gcd</code>.
</p>
<p>Ejemplos:
</p>
<p>Los tres polinomios tiene como máximo común divisor <code>2*x-3</code>,
el cual se calcula primero con la función <code>gcd</code> y luego con
<code>ezgcd</code>.
</p>
<pre class="example">(%i1) p1 : 6*x^3-17*x^2+14*x-3;
                        3       2
(%o1)                6 x  - 17 x  + 14 x - 3
(%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                    4       3       2
(%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
(%i3) p3 : -8*x^3+14*x^2-x-3;
                          3       2
(%o3)                - 8 x  + 14 x  - x - 3

(%i4) gcd(p1, gcd(p2, p3));
(%o4)                        2 x - 3

(%i5) ezgcd(p1, p2, p3);
                   2               3      2           2
(%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]
</pre>


</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>facexpand</b>
<a name="IDX614"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>facexpand</code> controla si los factores irreducibles devueltos por <code>factor</code> están en formato expandido (por defecto) o recursivo  (CRE normal).
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>factor</b><i> (<var>expr</var>)</i>
<a name="IDX615"></a>
</dt>
<dt><u>Función:</u> <b>factor</b><i> (<var>expr</var>, <var>p</var>)</i>
<a name="IDX616"></a>
</dt>
<dd><p>Factoriza la expresión <var>expr</var>, que puede contener
cualquier número de variables o funciones, en factores 
irreducibles respecto de los enteros. La llamada 
<code>factor (<var>expr</var>, <var>p</var>)</code> factoriza <var>expr</var> 
en el campo de los racionales con un elemento añadido cuyo 
polinomio mínimo es <var>p</var>.
</p>
<p>La función <code>factor</code> utiliza a <code>ifactors</code> 
para factorizar enteros.
</p>
<p>Si la variable <code>factorflag</code> vale <code>false</code> suprime 
la factorización de los factores enteros en las expresiones racionales.
</p>
<p>La variable <code>dontfactor</code> puede contener una lista 
de variables con respecto a las cuales no se factorizará 
(inicialmente está vacía). Tampoco se 
factorizará respecto de cualesquiera otra variables que sean menos importantes (según la ordenación que se sigue en el formato CRE) que aquellas que se encuentran en la lista <code>dontfactor</code>.
</p>
<p>Si la variable <code>savefactors</code> vale <code>true</code>, los 
factores de una expresión en forma de producto se guardarán 
por ciertas funciones a fin de acelerar posteriores factorizaciones 
de expresiones que contengan algunos de estos mismos factores.
</p>
<p>Si <code>berlefact</code> vale <code>false</code> entonces se utiliza el 
algoritmo de factorización de Kronecker, en caso contrario se 
utilizará el algoritmo de Berlekamp, que es el que se aplica por defecto.
</p>
<p>Si la variable <code>intfaclim</code> vale <code>true</code>, Maxima desistirá de
factorizar enteros si no encuentra ningún factor después de las
divisiones tentativas y de aplicar el método rho de Pollard. Si vale
<code>false</code> (este es el caso cuando el usuario invoca explícitamente
a <code>factor</code>), se intentará la factorización completa del entero. El valor
asignado a <code>intfaclim</code> se utiliza en llamadas internas a <code>factor</code>. Así,
se puede cambiar el valor de <code>intfaclim</code> para evitar que Maxima dedique
un tiempo prohibitivo a factorizar números enteros grandes.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
</pre>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>factorflag</b>
<a name="IDX617"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>factorflag</code> vale <code>false</code> se evita la factorización de factores enteros de expresiones racionales.
</p></dd></dl>




<dl>
<dt><u>Función:</u> <b>factorout</b><i> (<var>expr</var>, <var>x_1</var>, <var>x_2</var>, ...)</i>
<a name="IDX618"></a>
</dt>
<dd><p>Reorganiza la suma <var>expr</var> como una suma de términos de la forma 
<code>f (<var>x_1</var>, <var>x_2</var>, ...)*g</code>, donde <code>g</code> es un producto 
de expresiones que no contienen ningún <var>x_i</var> y <code>f</code> se factoriza.
</p>
<p>Nótese que <code>factorout</code> ignora la variable opcional <code>keepfloat</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expand (a*(x+1)*(x-1)*(u+1)^2);
             2  2          2      2      2
(%o1)     a u  x  + 2 a u x  + a x  - a u  - 2 a u - a
(%i2) factorout(%,x);
         2
(%o2) a u  (x - 1) (x + 1) + 2 a u (x - 1) (x + 1)
                                              + a (x - 1) (x + 1)
</pre></dd></dl>




<dl>
<dt><u>Función:</u> <b>factorsum</b><i> (<var>expr</var>)</i>
<a name="IDX619"></a>
</dt>
<dd><p>Intenta agrupar términos en los factores de <var>expr</var> que son sumas en grupos de términos tales que su suma sea factorizable. La función <code>factorsum</code> puede restablecer el recuperar de <code>expand ((x + y)^2 + (z + w)^2)</code> pero no puede recuperar <code>expand ((x + 1)^2 + (x + y)^2)</code> porque los términos tienen variables comunes.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fasttimes</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX620"></a>
</dt>
<dd><p>Calcula el producto de los polinomios <var>p_1</var> y <var>p_2</var> utilizando un algoritmo especial. Los polinomios <code>p_1</code> y <code>p_2</code> deben ser multivariantes, densos y aproximadamente del mismo tamaño. La multiplicación clásica es de orden <code>n_1 n_2</code> donde <code>n_1</code> es el grado de  <code>p_1</code> y  <code>n_2</code> el grado de <code>p_2</code>. La función <code>fasttimes</code> es de orden <code>max (n_1, n_2)^1.585</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fullratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX621"></a>
</dt>
<dd><p>Aplica repetidamente <code>ratsimp</code> a una expresión, seguida de simplificaciones no racionales, hasta que no se obtienen más transformaciones; entonces devuelve el resultado.
</p>
<p>En presencia de expresiones no racionales, una llamada a <code>ratsimp</code> seguida de una simplificación no racional (&quot;general&quot;) puede no ser suficiente para conseguir un resultado simplificado. En ocasiones serán necesarias más de una llamada a <code>ratsimp</code>, que es lo que hace precisamente <code>fullratsimp</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fullratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX622"></a>
</dt>
<dd><p>Similar a <code>ratsubst</code> excepto por el hecho de que se llama a í misma recursivamente hasta que el resultado deja de cambiar. Esta función es útil cuando la expresión a sustituir y la que la sustituye tienen variables comunes.
</p>
<p>La función <code>fullratsubst</code> también acepta sus argumentos en el formato de <code>lratsubst</code>.
</p>
<p>Es necesario ejecutar <code>load (&quot;lrats&quot;)</code> para cargar <code>fullratsubst</code> y <code>lratsubst</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> puede hacer sustituciones múltiples;
<code>lratsubst</code> es análoga a <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
Si sólo se quiere una sustitución, entonces se puede dar una única ecuación como primer argumento.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre><ul>
<li>
<code>fullratsubst</code> equivale a <code>ratsubst</code>, 
excepto por el hecho de que se llama a í misma recursivamente hasta que el resultado deja de cambiar.
</li></ul>
<pre class="example">(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> también acepta una lista de ecuaciones o una sóla ecuación como primer argumento.
</li></ul>
<pre class="example">(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> puede caer en una recursión infinita.
</li></ul>
<pre class="example">(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>gcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ...)</i>
<a name="IDX623"></a>
</dt>
<dd><p>Devuelve el máximo común divisor de <var>p_1</var> y <var>p_2</var>.
La variable <code>gcd</code> determiona qué algoritmo se va a utilizar.
Asignándole a <code>gcd</code> los valores <code>ez</code>, <code>subres</code>, <code>red</code>
o <code>spmod</code>, se seleccionan los algoritmos <code>ezgcd</code>, 
subresultante <code>prs</code>, reducido o modular, respectivamente.
Si <code>gcd</code> vale <code>false</code> entonces <code>gcd(<var>p_1</var>, 
<var>p_2</var>, <var>x</var>)</code> devolverá siempre 1 para cualquier <var>x</var>.
Muchas funciones (por ejemplo,  <code>ratsimp</code>, <code>factor</code>, etc.)
hacen uso de <code>gcd</code> implícitamente.  
En caso de polinomios homogéneos se recomienda darle a 
<code>gcd</code> el valor <code>subres</code>.  Para calcular un máximo 
común divisor en presencia de raíces, como en
 <code>gcd (<var>x</var>^2 - 2*sqrt(2)*<var>x</var> + 2, <var>x</var> - sqrt(2))</code>,
la variable <code>algebraic</code> debe igualarse
a <code>true</code> y <code>gcd</code> no puede ser <code>ez</code>.
</p>
<p>Se recomienda utilizar el algoritmo <code>subres</code> en lugar de <code>red</code>,
por ser aquél más moderno.
</p>
<p>Si la variable <code>gcd</code>, cuyo valor por defecto es <code>spmod</code>,
vale <code>false</code>, no se calculará el máximo común divisor 
cuando las expresiones se conviertan a su forma canónica (CRE),
lo que redundará en ocasiones en mayor rapidez de cálculo.
</p>

</dd></dl>

<dl>
<dt><u>Función:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>)</i>
<a name="IDX624"></a>
</dt>
<dt><u>Función:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>, <var>x</var>)</i>
<a name="IDX625"></a>
</dt>
<dd><p>Devuelve una lista <code>[<var>a</var>, <var>b</var>, <var>u</var>]</code> en la que <var>u</var> es el máximo común divisor (mcd) de <var>f</var> y <var>g</var>, e igual a <code><var>a</var> <var>f</var> + <var>b</var> <var>g</var></code>.
Los argumentos <var>f</var> y <var>g</var> deben ser polinomios univariantes, o indicarles la variable principal <var>x</var> en caso de ser multivariantes. 
</p>
<p>La función <code>gcdex</code> implementa el algoritmo de Euclides, en el que tenemos una secuencia de <code>L[i]: [a[i], b[i], r[i]]</code> todos ellos ortogonales a <code>[f, g, -1]</code> siendo el siguiente calculado a partir de <code>q = quotient(r[i]/r[i+1])</code> y <code>L[i+2]: L[i] - q L[i+1]</code>; el proceso termina en <code>L[i+1]</code> cuando el resto <code>r[i+2]</code> se anula.
</p>

<pre class="example">(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
</pre>

</dd></dl>


<dl>
<dt><u>Función:</u> <b>gcfactor</b><i> (<var>n</var>)</i>
<a name="IDX626"></a>
</dt>
<dd><p>Factoriza el entero gaussiano <var>n</var> como producto, a su vez, de enteros gaussianos, (un entero gaussiano es de la forma<code><var>a</var> + <var>b</var> <code>%i</code></code> donde <var>a</var> y <var>b</var> son números enteros). Los factores se normalizan de manera que tanto la parte real como imaginaria sean no negativas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>gfactor</b><i> (<var>expr</var>)</i>
<a name="IDX627"></a>
</dt>
<dd><p>Factoriza el polinomio <var>expr</var> sobre los enteros gaussianos (un entero gaussiano es de la forma<code><var>a</var> + <var>b</var> <code>%i</code></code> donde <var>a</var> y <var>b</var> son números enteros).
Es como <code>factor (<var>expr</var>, <var>a</var>^2+1)</code> donde <var>a</var> vale <code>%i</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>gfactorsum</b><i> (<var>expr</var>)</i>
<a name="IDX628"></a>
</dt>
<dd><p>Esta función es similar a <code>factorsum</code> pero aplica <code>gfactor</code> en lugar de <code>factor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>hipow</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX629"></a>
</dt>
<dd><p>Devuelve el mayor exponente explícito de  <var>x</var> en <var>expr</var>.
El argumento<var>x</var> puede ser una variable o una expresión general.
Si <var>x</var> no aparece en <var>expr</var>, <code>hipow</code> devuelve <code>0</code>.
</p>
<p>La función <code>hipow</code> no tiene en cuenta expresiones equivalentes a <code>expr</code>.
En particular, <code>hipow</code> no expande <code>expr</code>, de manera que <code>hipow (<var>expr</var>, <var>x</var>)</code> y <code>hipow (expand (<var>expr</var>, <var>x</var>))</code> pueden dar resultados diferentes.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>intfaclim</b>
<a name="IDX630"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si vale <code>true</code>, Maxima  desistirá de
factorizar enteros si no encuentra ningún factor después de las
divisiones tentativas y de aplicar el método rho de Pollard, por lo que 
la factorización puede quedar incompleta.
</p>
<p>Si vale <code>false</code> (este es el caso cuando el usuario invoca explícitamente
a <code>factor</code>), se intentará la factorización completa del entero. El valor
asignado a <code>intfaclim</code> se utiliza en llamadas internas a <code>factor</code>. A la variable
<code>intfaclim</code> se le asigna el valor <code>false</code> cuando se calculan factores desde las
funciones <code>divisors</code>, <code>divsum</code> y <code>totient</code>.
</p>
<p>Las llamadas internas a <code>factor</code> respetan el valor dado por el usuario a <code>intfaclim</code>.
Asignando a <code>intfaclim</code> el valor <code>true</code> se puede reducir  el tiempo que Maxima dedica a
factorizar enteros grandes.
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>keepfloat</b>
<a name="IDX631"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>keepfloat</code> vale <code>true</code>, los números decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato canónico racional (CRE).
</p>
<p>Nótese que la función <code>solve</code> y todas aquellas otras que la
invocan (por ejemplo, <code>eigenvalues</code>) ignoran esta variable, por
lo que hacen la conversión de los números decimales.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) rat(x/2.0);

`rat' replaced 0.5 by 1/2 = 0.5
                                       x
(%o1)/R/                               -
                                       2
(%i2) rat(x/2.0), keepfloat;

(%o2)/R/                             0.5 x
</pre>
<p><code>solve</code> ignora <code>keepfloat</code>:
</p>
<pre class="example">(%i3) solve(1.0-x,x), keepfloat;

`rat' replaced 1.0 by 1/1 = 1.0
(%o3)                               [x = 1]
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>lopow</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX632"></a>
</dt>
<dd><p>Devuelve el menor exponente de <var>x</var> que aparece explícitamente
en <var>expr</var>.
</p>
<pre class="example">(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>lratsubst</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX633"></a>
</dt>
<dd><p>Esta función es similar a <code>subst (<var>L</var>, <var>expr</var>)</code>, excepto por el hecho de que utiliza <code>ratsubst</code> en lugar de <code>subst</code>.
</p>
<p>El primer argumento de <code>lratsubst</code> es una ecuación o lista de ecuaciones idénticas en formato a las aceptadas por <code>subst</code>.  Las sustituciones se hacen en el orden dado por la lista de ecuaciones, esto es, de izquierda a derecha.
</p>
<p>La instrucción <code>load (&quot;lrats&quot;)</code> carga <code>fullratsubst</code> y <code>lratsubst</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> can carry out multiple substitutions.
<code>lratsubst</code> is analogous to <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
If only one substitution is desired, then a single
equation may be given as first argument.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>modulus</b>
<a name="IDX634"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>modulus</code> es un número positivo <var>p</var>, las operaciones con números racionales
(como los devueltos por <code>rat</code> y funciones relacionadas) se realizan módulo <var>p</var>,
utilizando el llamado sistema de módulo balanceado, en el que <code><var>n</var> módulo <var>p</var></code>
se define como un entero <var>k</var> de <code>[-(<var>p</var>-1)/2, ..., 0, ..., (<var>p</var>-1)/2]</code>
si <var>p</var> es impar, o de <code>[-(<var>p</var>/2 - 1), ..., 0, ...., <var>p</var>/2]</code> si <var>p</var> es par,
de tal manera que <code><var>a</var> <var>p</var> + <var>k</var></code> es igual a <var>n</var> para algún entero <var>a</var>.
</p>
<p>Normalmente a <code>modulus</code> se le asigna un número primo. Se acepta que a <code>modulus</code>
se le asigne un entero positivo no primo, pero se obtendrá un mensaje de aviso. Maxima 
responderá con un mensaje de error cuando se le asigne a <code>modulus</code> cero o un número
negativo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) modulus:7;
(%o1)                           7
(%i2) polymod([0,1,2,3,4,5,6,7]);
(%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
(%i3) modulus:false;
(%o3)                         false
(%i4) poly:x^6+x^2+1;
                            6    2
(%o4)                      x  + x  + 1
(%i5) factor(poly);
                            6    2
(%o5)                      x  + x  + 1
(%i6) modulus:13;
(%o6)                          13
(%i7) factor(poly);
                      2        4      2
(%o7)               (x  + 6) (x  - 6 x  - 2)
(%i8) polymod(%);
                            6    2
(%o8)                      x  + x  + 1
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>num</b><i> (<var>expr</var>)</i>
<a name="IDX635"></a>
</dt>
<dd><p>Devuelve el numerador de <var>expr</var> si se trata de una fracción. Si <var>expr</var> no es una fracción, se devuelve <var>expr</var>.
</p>
<p>La función <code>num</code> evalúa su argumento.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>polydecomp</b><i> (<var>p</var>, <var>x</var>)</i>
<a name="IDX636"></a>
</dt>
<dd><p>Descompone el polinomio <var>p</var> de variable <var>x</var> en una composición funcional de polinomios en <var>x</var>. 
La función <code>polydecomp</code> devuelve una lista <code>[<var>p_1</var>, ..., <var>p_n</var>]</code> tal que 
</p>
<pre class="example">lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))
</pre>
<p>es igual a  <var>p</var>.
El grado de <var>p_i</var> es mayor que 1 para <var>i</var> menor que <var>n</var>.
</p>
<p>Esta descomposición no es única.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>La siguiente función compone <code>L = [e_1, ..., e_n]</code> como funciones de <code>x</code>;
se trata de la inversa de <code>polydecomp</code>:
</p>
<pre class="example">compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
</pre>
<p>Se vuelve a obtener el resultado del ejemplo de más arriba haciendo uso de <code>compose</code>:
</p>
<pre class="example">(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>Nótese que aunque <code>compose (polydecomp (<var>p</var>, <var>x</var>), <var>x</var>)</code>
devuelve siempre <var>p</var> (sin expandir),
<code>polydecomp (compose ([<var>p_1</var>, ..., <var>p_n</var>], <var>x</var>), <var>x</var>)</code>  <i>no</i>
devuelve necesariamente <code>[<var>p_1</var>, ..., <var>p_n</var>]</code>:
</p>
<pre class="example">(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>polymod</b><i> (<var>p</var>)</i>
<a name="IDX637"></a>
</dt>
<dt><u>Función:</u> <b>polymod</b><i> (<var>p</var>, <var>m</var>)</i>
<a name="IDX638"></a>
</dt>
<dd><p>Convierte el polinomio <var>p</var> a una representación modular respecto del módulo actual, que es el valor almacenado en la variable <code>modulus</code>.  
</p>
<p>La llamada <code>polymod (<var>p</var>, <var>m</var>)</code> especifica un módulo <var>m</var> para ser utilizado en lugar de valor almacenado en <code>modulus</code>.
</p>
<p>Véase <code>modulus</code>.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>powers</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX639"></a>
</dt>
<dd><p>Devuelve las potencias de <var>x</var> dentro de <var>expr</var>.
</p>
<p>La instrucción <code>load (powers)</code> carga esta función.
</p>

</dd></dl>



<dl>
<dt><u>Función:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX640"></a>
</dt>
<dt><u>Función:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX641"></a>
</dt>
<dd><p>Devuelve el polinomio <var>p_1</var> dividido por el polinomio <var>p_2</var>. Los argumentos <var>x_1</var>, ..., <var>x_n</var> se interpretan como en la función <code>ratvars</code>.
</p>
<p>La función <code>quotient</code> devuelve el primer elemento de la lista devuelta por <code>divide</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>rat</b><i> (<var>expr</var>)</i>
<a name="IDX642"></a>
</dt>
<dt><u>Función:</u> <b>rat</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX643"></a>
</dt>
<dd><p>Convierte <var>expr</var> al formato canónico racional (canonical rational expression o CRE) expandiendo y combinando todos los términos sobre un denominador común y cancelando el máximo común divisor del numerador y denominador, así como convirtiendo números decimales en coma flotante a números racionales dentro de la tolerancia indicada por <code>ratepsilon</code>. Las variables se ordenan de acuerdo a <var>x_1</var>, ..., <var>x_n</var> si se han especificado, como en la función <code>ratvars</code>.
</p>
<p>En general, <code>rat</code> no simplifica otras funciones que no sean la suma <code>+</code>, resta <code>-</code>, multiplicación <code>*</code>, división <code>/</code> y exponenciación de exponente entero, mientras que <code>ratsimp</code> sí lo hace.
Nótese que los átomos (números y variables) en expresiones en formato CRE no son los mismos que en el formato general.
Por ejemplo, <code>rat(x)- x</code> devuelve <code>rat(0)</code>, que tiene una representación interna diferente de 0.
</p>

<p>Si <code>ratprint</code> vale <code>false</code> no aparecerán mensajes informando al usuario sobre la conversión de números decimales en coma flotante a números racionales.
</p>
<p>Si <code>keepfloat</code> vale <code>true</code> no se convertirán números decimales en coma flotante a números racionales.
</p>
<p>Véanse también <code>ratexpand</code> y  <code>ratsimp</code>.
</p>
<p>Ejemplos:
</p><pre class="example">(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
         / (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratalgdenom</b>
<a name="IDX644"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratalgdenom</code> vale <code>true</code>, se permite la racionalización de denominadores eliminando radicales.
La variable <code>ratalgdenom</code> sólo tiene efecto cuando expresiones en formato canónico (CRE) están siendo utilizadas en modo algebraico.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX645"></a>
</dt>
<dt><u>Función:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX646"></a>
</dt>
<dd><p>Devuelve el coeficiente de la expresión <code><var>x</var>^<var>n</var></code> dentro de la expresión <var>expr</var>. Si se omite, <var>n</var> se considera igual a 1.
</p>
<p>El valor devuelto está libre de las variables en <var>x</var>, excepto quizás en un sentido no racional. Si no existe un coeficiente de este tipo se devuelve 0.
</p>
<p>La función <code>ratcoef</code> expande y simplifica racionalmente su primer argumento, por lo que puede dar una respuesta diferente a la dada por la función <code>coeff</code>, la cual tiene un carácter puramente sintáctico.
Así, <code>ratcoef ((x + 1)/y + x, x)</code> devuelve <code>(y + 1)/y</code>, 
mientras que <code>coeff</code> devuelve 1.
</p>
<p>La llamada <code>ratcoef (<var>expr</var>, <var>x</var>, 0)</code>, siendo <var>expr</var> una suma, devuelve una suma formada por los términos que no contienen <var>x</var>.
</p>
<p>Puesto que <var>expr</var> se simplifica racionalmente antes de ser examinada, algunos coeficientes puede que no aparezcan como en la expresión original.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ratdenom</b><i> (<var>expr</var>)</i>
<a name="IDX647"></a>
</dt>
<dd><p>Devuelve el denominador de <var>expr</var>, después de transformar <var>expr</var> al formato canónico (CRE). El valor retornado está también en formato CRE.
</p>
<p>El argumento <var>expr</var> se transforma al formato CRE por la función <code>rat</code>, a menos que ya esté en este formato.
Esta conversión puede cambiar la forma de <var>expr</var> colocando todos sus términos sobre un denominador común.
</p>
<p>La función <code>denom</code> es parecida, pero devuelve una expresión general en lugar de una CRE. Tampoco <code>denom</code> intenta colocar todos sus términos sobre un denominador común, de manera que algunas expresiones que son consideradas como divisiones por <code>ratdenom</code>, no son tales para <code>denom</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratdenomdivide</b>
<a name="IDX648"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratdenomdivide</code> vale <code>true</code>, la función <code>ratexpand</code> expande una fracción en la que el numerador es una suma en una suma de divisiones. En otro caso, <code>ratexpand</code> reduce una suma de divisiones a una única fracción, cuyo numerador es la suma de los denominadores de cada fracción.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>ratdiff</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX649"></a>
</dt>
<dd><p>Deriva la expresión racional <var>expr</var> con respecto a <var>x</var>.
El argumento <var>expr</var> debe ser una fracción algebraica o un polinomio en <var>x</var>.
El argumento <var>x</var> puede ser una variable o una subexpresión de <var>expr</var>.
</p>
<p>El resultado equivale al devuelto por <code>diff</code>, aunque es posible que se obtenga en una forma diferente.
La función <code>ratdiff</code> puede ser más rápida que <code>diff</code> en expresiones racionales.
</p>
<p>La función <code>ratdiff</code> devuelve una expresión en formato canónico o CRE si <code>expr</code> es también una expresión CRE. En otro caso, <code>ratdiff</code> devuelve una expresión general.
</p>
<p>La función <code>ratdiff</code> considera únicamente la dependencia de <var>expr</var> respecto de <var>x</var>, ignorando cualquier dependencia establecida por <code>depends</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ratdisrep</b><i> (<var>expr</var>)</i>
<a name="IDX650"></a>
</dt>
<dd><p>Devuelve su argumento como una expresión general.
Si <var>expr</var> es una expresión general, se devuelve sin cambios.
</p>
<p>Normalmente se invoca a <code>ratdisrep</code> a fin de convertir una expresión en formato canónico (CRE) al formato general, lo que puede ser utilizado si se quiere parar el contagio que produce el formato CRE, o para utilizar funciones racionales en contextos no racionales.
</p>
<p>Véase también <code>totaldisrep</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>ratexpand</b><i> (<var>expr</var>)</i>
<a name="IDX651"></a>
</dt>
<dt><u>Variable opcional:</u> <b>ratexpand</b>
<a name="IDX652"></a>
</dt>
<dd><p>Expande <var>expr</var> multiplicando productos de sumas y sumas con exponentes, combinando fracciones con común denominador, cancelando el máximo común divisor del numerador y del denominador y luego dividiendo los sumandos del numerador por el denominador.
</p>
<p>El valor que devuelve <code>ratexpand</code> es una expresión general, incluso cuando <var>expr</var> está en formato canónico o CRE.
</p>
<p>Si la variable <code>ratexpand</code> vale <code>true</code> hará que las expresiones CRE se expandan completamente cuando se conviertan al formato general o se muestren en el terminal, mientras que si vale <code>false</code> se mostrarán de forma recursiva. Véase también <code>ratsimp</code>.
</p>
<p>Si <code>ratdenomdivide</code> vale <code>true</code>,
<code>ratexpand</code> expande una fracción en la que el numerador es una suma en una suma de fracciones, todas ellas con denominador común. En otro caso, <code>ratexpand</code> reduce una suma de fracciones en una única fracción, cuyo numerador es la suma de los numeradores de cada fracción.
</p>
<p>Si <code>keepfloat</code> vale <code>true</code>, los números decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato canónico racional (CRE).
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratfac</b>
<a name="IDX653"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratfac</code> vale <code>true</code>, las expresiones canónicas (CRE) se manipulan en una forma parcialmente factorizada.
</p>
<p>Durante las operaciones racionales, las expresiones se mantienen completamente factorizadas tanto como sea posible sin llamar a <code>factor</code>. Esto debería ahorrar espacio y tiempo en algunos cálculos. El numerador y denominador se hacen primos relativos, por ejemplo <code>rat ((x^2 - 1)^4/(x + 1)^2)</code> devuelve <code>(x - 1)^4 (x + 1)^2)</code>, pero los factores dentro de cada parte pueden no ser primos relativos.
</p>
<p>En el paquete <code>ctensr</code> sobre manipulación de tensores por componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la curvatura escalar se factorizan automáticamente si <code>ratfac</code> vale <code>true</code>; 
<i><code>ratfac</code> debe activarse únicamente en aquellos casos en los que se sabe que el número de términos de las componentes tensoriales es pequño.</i>
</p>
<p>Nota: Los esquemas de comportamiento basados en <code>ratfac</code> y <code>ratweight</code> son incompatibles y no se debe  pretender usarlos al mismo tiempo.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ratnumer</b><i> (<var>expr</var>)</i>
<a name="IDX654"></a>
</dt>
<dd><p>Devuelve el numerador de <var>expr</var>, después de reducir <var>expr</var> a su forma canónica (CRE).
El valor retornado está también en formato CRE.
</p>
<p>El argumento <var>expr</var> se transforma al formato CRE por la función <code>rat</code>, a menos que ya esté en este formato.
Esta conversión puede cambiar la forma de <var>expr</var> colocando todos sus términos sobre un denominador común.
</p>
<p>Es parecida a la función <code>num</code>, pero devuelve una expresión general en lugar de una CRE.
Además, <code>num</code> no intenta colocar todos los términos sobre un denominador común, de manera que algunas expresiones que son consideradas fracciones por <code>ratnumer</code> no se consideran como tales por <code>num</code>.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>ratp</b><i> (<var>expr</var>)</i>
<a name="IDX655"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una expresión canónica racional (canonical rational expression o CRE) o una CRE extendida, en caso contrario devuelve <code>false</code>.
</p>
<p>Las expresiones CRE son creadas por <code>rat</code> y funciones asociadas. Las CRE extendidas son creadas por <code>taylor</code> y funciones asociadas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratprint</b>
<a name="IDX656"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>ratprint</code> vale <code>true</code>, se muestra al usuario un mensaje dando cuenta de la conversión de números decimales en coma flotante a formato racional.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX657"></a>
</dt>
<dt><u>Función:</u> <b>ratsimp</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX658"></a>
</dt>
<dd><p>Simplifica la expresión <var>expr</var> y todas sus subexpresiones, incluyendo los argumentos de funciones no racionales. El resultado es un cociente de dos polinomios en una forma recursiva, esto es, los coeficientes de la variable principal son polinomios respecto de las otras variables. Las variables pueden incluir funciones no racionales, como <code>sin (x^2 + 1)</code>, y los argumentos de tales funciones son también racionalmente simplificados.
</p>
<p>La llamada <code>ratsimp (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code> permite la simplificación racional con la especificación del orden de las variables, como en <code>ratvars</code>.
</p>
<p>Si <code>ratsimpexpons</code> vale <code>true</code>, <code>ratsimp</code> se aplica a los exponentes de las expresiones durante la simplificación.
</p>
<p>Véase también <code>ratexpand</code>. Nótese que <code>ratsimp</code> se ve afectada por algunas de las variables globales que controlan a <code>ratexpand</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratsimpexpons</b>
<a name="IDX659"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratsimpexpons</code> vale <code>true</code>, <code>ratsimp</code> se aplica a los exponentes de las expresiones durante la simplificación.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>radsubstflag</b>
<a name="IDX660"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>radsubstflag</code> vale <code>true</code> se permite a <code>ratsubst</code> hacer la sustitución <code>u</code> por <code>sqrt (x)</code> in <code>x</code>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>ratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX661"></a>
</dt>
<dd><p>Sustituye <var>b</var> por <var>a</var> en <var>c</var> y devuelve la expresión resultante.
El argumento <var>b</var> puede ser una suma, un producto, una potencia, etc.
</p>
<p>La función <code>ratsubst</code> reconoce el significado de las expresiones, mientras que <code>subst</code> tan solo realiza sustituciones sintácticas. Así por ejemplo, <code>subst (a, x + y, x + y + z)</code> devuelve <code>x + y + z</code>
cuando <code>ratsubst</code> devuelve <code>z + a</code>.
</p>
<p>Si <code>radsubstflag</code> vale <code>true</code>,
<code>ratsubst</code> sustituye radicales en expresiones que no los contienen explícitamente.
</p>
<p><code>ratsubst</code> ignora el valor <code>true</code> de la variable 
opcional <code>keepfloat</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>ratvars</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX662"></a>
</dt>
<dt><u>Función:</u> <b>ratvars</b><i> ()</i>
<a name="IDX663"></a>
</dt>
<dt><u>Variable del sistema:</u> <b>ratvars</b>
<a name="IDX664"></a>
</dt>
<dd><p>Declara como variables principales <var>x_1</var>, ..., <var>x_n</var> en expresiones racionales. Si <var>x_n</var> está presente en una expresión racional, se considerará como variable principal. Si no está presente, entonces se considerará principal a la variable <var>x_[n-1]</var> si aparece en la expresión, se continúa así hasta <var>x_1</var>, que se considerará como variable principal sólo si ninguna de las variables que le siguen está presente en la expresión.
</p>
<p>Si una variable de la expresión racional no está presente en la lista <code>ratvars</code>, se le dará una prioridad inferior a la de <var>x_1</var>.
</p>
<p>Los argumentos de <code>ratvars</code> pueden ser tanto variables como funciones no racionales como <code>sin(x)</code>.
</p>
<p>La variable <code>ratvars</code> es una lista que contiene los argumentos pasados a la función <code>ratvars</code> la última vez que fue invocada. Cada llamada a la función <code>ratvars</code> reinicializa la lista. La llamada <code>ratvars ()</code> vacía la lista.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>ratvarswitch</b>
<a name="IDX665"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Maxima almacena una lista interna en la variable Lisp <code>VARLIST</code> cuyo
contenido son las variables principales de las expresiones racionales. Cuando <code>ratvarswitch</code>
vale <code>true</code>, su valor por defecto, cada evaluación comienza con la lista
<code>VARLIST</code> vacía. En caso contrario, las variables principales
de las expresiones anteriores se mantienen en la lista <code>VARLIST</code>.
</p>
<p>Las variables principales declaradas con la función <code>ratvars</code> no se
ven afectadas por la opción <code>ratvarswitch</code>.
</p>
<p>Ejemplos:
</p>
<p>Cuando <code>ratvarswitch</code> vale <code>true</code>, su valor por defecto, cada 
evaluación comienza con la lista <code>VARLIST</code> vacía.
</p>
<pre class="example">(%i1) ratvarswitch:true$

(%i2) rat(2*x+y^2);
                             2
(%o2)/R/                    y  + 2 x
(%i3) :lisp varlist
($X $Y)

(%i3) rat(2*a+b^2);
                             2
(%o3)/R/                    b  + 2 a

(%i4) :lisp varlist
($A $B)
</pre>
<p>Cuando <code>ratvarswitch</code> vale <code>false</code>, las variables principales
de las expresiones anteriores se mantienen en lista <code>VARLIST</code>.
</p>
<pre class="example">(%i4) ratvarswitch:false$

(%i5) rat(2*x+y^2);
                             2
(%o5)/R/                    y  + 2 x
(%i6) :lisp varlist
($X $Y)

(%i6) rat(2*a+b^2);
                             2
(%o6)/R/                    b  + 2 a

(%i7) :lisp varlist
($A $B $X $Y)
</pre>
</dd></dl>





<dl>
<dt><u>Función:</u> <b>ratweight</b><i> (<var>x_1</var>, <var>w_1</var>, ..., <var>x_n</var>, <var>w_n</var>)</i>
<a name="IDX666"></a>
</dt>
<dt><u>Función:</u> <b>ratweight</b><i> ()</i>
<a name="IDX667"></a>
</dt>
<dd><p>Asigna un peso <var>w_i</var> a la variable <var>x_i</var>. Un término será reemplazado por 0 si su peso excede el valor de la variable <code>ratwtlvl</code> (por defecto no se realiza el truncamiento). El peso de un término es la suma de los productos de los pesos de las variables que lo forman multiplicados por sus exponentes. Por ejemplo, el peso de <code>3 x_1^2 x_2</code> es <code>2 w_1 + w_2</code>. El truncamiento basado en <code>ratwtlvl</code> solamente se lleva a cabo cuando se multiplican o se elevan a potencias expresiones canónicas (CRE).
</p>
<p>La llamada <code>ratweight ()</code> devuelve la lista acumulada de asignaciones de pesos.
</p>
<p>Nota: Los esquemas de comportamiento basados en <code>ratfac</code> y <code>ratweight</code> son incompatibles y no se debe  pretender usarlos al mismo tiempo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
</pre>
</dd></dl>

<dl>
<dt><u>Variable del sistema:</u> <b>ratweights</b>
<a name="IDX668"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>ratweights</code> es una lista que contiene los pesos asignados por <code>ratweight</code>.
Las lista es acumulativa, en el sentido de que cada llamada a <code>ratweight</code> añade nuevos elementos a la lista.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratwtlvl</b>
<a name="IDX669"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>ratwtlvl</code> se utiliza en combinación con la función <code>ratweight</code> para controlar el truncamiento de expresiones racionales canónicas (CRE). Con el valor por defecto, <code>false</code>, no se produce truncamiento alguno.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX670"></a>
</dt>
<dt><u>Función:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX671"></a>
</dt>
<dd><p>Devuelve el resto de la división del polinomio <var>p_1</var> entre <var>p_2</var>. Los argumentos <var>x_1</var>, ..., <var>x_n</var> se interpretan como en <code>ratvars</code>.
</p>
<p>La función <code>remainder</code> devuelve el segundo elemento de la lista retornada por <code>divide</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>resultant</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x</var>)</i>
<a name="IDX672"></a>
</dt>
<dd><p>Calcula la resultante de los dos polinomios <var>p_1</var> y <var>p_2</var>, eliminando
la variable <var>x</var>. La resultante es un determinante de los coeficientes de <var>x</var>
en <var>p_1</var> y <var>p_2</var>, que es igual a cero si sólo si <var>p_1</var> y <var>p_2</var>
tienen un factor común no constante.
</p>
<p>Si <var>p_1</var> o <var>p_2</var> pueden ser factorizados, puede ser necesario llamar a 
<code>factor</code> antes que invocar a <code>resultant</code>.
</p>
<p>La variable opcional <code>resultant</code> controla qué algoritmo será utilizado para calcular la resultante.
Véanse <code>option_resultant</code> y <code>resultant</code>.
</p>
<p>La función <code>bezout</code> toma los mismos argumentos que <code>resultant</code> y devuelve una matriz.
El determinante del valor retornado es la resultante buscada.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
(%o1)                           8
(%i2) resultant(x+1, x+1, x);
(%o2)                           0
(%i3) resultant((x+1)*x, (x+1), x);
(%o3)                           0
(%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                         2
(%o4)                   c  - 2 b c + 4 a

(%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                        [ 2 a  2 b - c ]
(%o5)                   [              ]
                        [  c      2    ]
(%i6) determinant(%);
(%o6)                   4 a - (2 b - c) c
</pre></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>resultant</b>
<a name="IDX673"></a>
</dt>
<dd><p>Valor por defecto: <code>subres</code>
</p>
<p>La variable opcional <code>resultant</code> controla qué algoritmo será utilizado para
calcular la resultante con la función <code>resultant</code>. Los  valores posibles son:
</p>
<dl compact="compact">
<dt> <code>subres</code></dt>
<dd><p>para el algoritmo PRS (<i>polynomial remainder sequence</i>) subresultante,
</p></dd>
<dt> <code>mod</code></dt>
<dd><p>para el algoritmo resultante modular y
</p></dd>
<dt> <code>red</code></dt>
<dd><p>para el algoritmo PRS (<i>polynomial remainder sequence</i>) reducido.
</p></dd>
</dl>

<p>En la mayor parte de problemas, el valor por defecto, <code>subres</code>, es el
más apropiado. Pero en el caso de problemas bivariantes o univariantes
de grado alto, puede ser mejor utilizar <code>mod</code>.
</p></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>savefactors</b>
<a name="IDX674"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>savefactors</code> vale <code>true</code>, los factores de una expresión producto se almacenan por ciertas funciones a fin de acelerar posteriores factorizaciones de expresiones que contengan algunos de estos factores.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>showratvars</b><i> (<var>expr</var>)</i>
<a name="IDX675"></a>
</dt>
<dd><p>Devuelve una lista de las variables de expresiones canónicas racionales (CRE) en la expresión <code>expr</code>.
</p>
<p>Véase también <code>ratvars</code>.
</p>
</dd></dl>





<dl>
<dt><u>Función:</u> <b>tellrat</b><i> (<var>p_1</var>, ..., <var>p_n</var>)</i>
<a name="IDX676"></a>
</dt>
<dt><u>Función:</u> <b>tellrat</b><i> ()</i>
<a name="IDX677"></a>
</dt>
<dd><p>Añade al anillo de enteros algebraicos conocidos por Maxima los elementos que son soluciones de los polinomios <var>p_1</var>, ..., <var>p_n</var>. Cada argumento <var>p_i</var> es un polinomio de coeficientes enteros.
</p>
<p>La llamada <code>tellrat (<var>x</var>)</code> hace que se sustituya 0 por <var>x</var> en las funciones racionales.
</p>
<p>La llamada <code>tellrat ()</code> devuelve una lista con las sustituciones actuales.
</p>
<p>A la variable <code>algebraic</code> se le debe asignar el valor <code>true</code> a fin de poder realizar la simplificación de enteros algebraicos.
</p>
<p>Maxima reconoce la unidad imaginaria <code>%i</code> y todas las raíces de los enteros.
</p>
<p>La instrucción <code>untellrat</code> borra todas las propiedades de <code>tellrat</code>.
</p>
<p>Es ambiguo aplicar <code>tellrat</code> a un polinomio multivariante tal como <code>tellrat (x^2 - y^2)</code>, pues no se sabe si sustituir <code><var>y</var>^2</code> por <code><var>x</var>^2</code> o al revés. Maxima sigue un cierto orden, pero si el usuario quiere especificar uno en concreto, puede hacerlo mediante la sintaxis <code>tellrat (y^2 = x^2)</code>, que indica que se ponga <code><var>x</var>^2</code> en lugar de <code><var>y</var>^2</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>totaldisrep</b><i> (<var>expr</var>)</i>
<a name="IDX678"></a>
</dt>
<dd><p>Convierte cada subexpresión  de <var>expr</var> del formato canónico (CRE) al general y devuelve el resultado.
Si <var>expr</var> está en formato CRE entonces <code>totaldisrep</code> es idéntico a <code>ratdisrep</code>.
</p>
<p>La función <code>totaldisrep</code> puede ser útil para modificar expresiones como las ecuaciones, listas, matrices, etc., que tienen algunas subexpresiones en formato CRE.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>untellrat</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX679"></a>
</dt>
<dd><p>Elimina de <var>x_1</var>, ..., <var>x_n</var> las propiedades relacionadas con <code>tellrat</code>.
</p>
</dd></dl>












































<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_15.html#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>octubre, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
