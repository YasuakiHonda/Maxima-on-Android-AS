<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on octubre, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.41.0: 36. Definición de Funciones</title>

<meta name="description" content="Manual de Maxima 5.41.0: 36. Definición de Funciones">
<meta name="keywords" content="Manual de Maxima 5.41.0: 36. Definición de Funciones">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Definici_00f3n-de-Funciones"></a>
<a name="SEC197"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_35.html#SEC196" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC198" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 36. Definición de Funciones </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC198">36.1 Introducción a la definición de funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC199">36.2 Funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC202">36.3 Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC203">36.4 Funciones y variables para la definición de funciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-la-definici_00f3n-de-funciones"></a>
<a name="SEC198"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC197" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC199" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.1 Introducción a la definición de funciones </h2>

<hr size="6">
<a name="Funciones"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC198" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC200" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC199"></a>
<h2 class="section"> 36.2 Funciones </h2>
<hr size="6">
<a name="SEC200"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC199" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC201" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC199" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.1 Funciones ordinarias </h3>

<p>Para definir una función en Maxima es necesario utilizar el operador ':='.
</p>
<p>Por ejemplo,
</p>
<pre class="example">f(x) := sin(x)
</pre>

<p>define una función <code>f</code>. También se pueden definir funciones anónimas utilizando <code>lambda</code>; por ejemplo,
</p>
<pre class="example">lambda ([i, j], ...)
</pre>

<p>puede utilizarse en lugar de <code>f</code> donde
</p>
<pre class="example">f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
</pre>

<p>devolvería una lista con todos sus elementos aumentados en una unidad.
</p>
<p>También se puede definir una función con un número variable de argumentos, sin más que añadir un argumento final al que se le asigna una lista con todos los argumentos adicionales.:
</p>
<pre class="example">(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
</pre>
<p>El miembro derecho de una función debe ser una expresión. Así, si se quiere una secuencia de expresiones, se debe hacer
</p>
<pre class="example">f(x) := (expr1, expr2, ...., exprn);
</pre>
<p>siendo el valor que alcance exprn el devuelto por la función.
</p>
<p>Si se quiere hacer un <code>return</code> desde alguna de las expresiones de la función, se debe utilizar la estructura  <code>block</code> junto con <code>return</code>. Por ejemplo,
</p>
<pre class="example">block ([], expr1, ..., if (a &gt; 10) then return(a), ..., exprn)
</pre>
<p>es una expresión de pleno derecho, por lo que puede ocupar el lado derecho de la definición de una función. Aquí puede ocurrir que el retorno se produzca antes que se alcance la última expresión.
</p>
<p>Los primeros corchetes del bloque (<code>[]</code>) pueden contener una lista de variables junto con posibles asignaciones, tal como <code>[a: 3, b, c: []]</code>, lo que provocará que las tres variables <code>a</code>,<code>b</code> y <code>c</code> se consideren locales y sean independientes de otras globales con el mismo nombre; las variables locales sólo estarán activas mientras se ejecute el código que está dentro de la estructura <code>block</code>, o dentro de funciones que son llamadas desde dentro de <code>block</code>. A esto se le llama asignación dinámica, pues las variables sobreviven desde el inicio del bloque hasta que éste deje de estar operativo. Una vez se salga del bloque los valores originales de las variables, si es que los había, quedan restaurados. Es recomendable proteger las variables de esta forma. Se tendrá en cuenta que las asignaciones a las variables del bloque se hacen en paralelo, lo que significa que si como en el ejemplo anterior se hace <code>c: a</code> en el momento de entrar en el bloque, el valor de <code>c</code> será el que tenía <code>a</code> antes de entrar en el bloque, es decir, antes de la asignación <code>a: 3</code>. Así, haciendo lo siguiente
</p>

<pre class="example">block ([a: a], expr1, ... a: a+3, ..., exprn)
</pre>
<p>se prevendría de que el valor externo de <code>a</code> fuese alterado, pero permitiría acceder a él desde dentro del bloque. La parte derecha de las asignaciones se evalúa dentro de su contexto antes de hacer efectiva la asignación. Utilizando únicamente <code>block([x],..</code> haría que <code>x</code> se tuviese a sí misma como valor, justo como si se acabase de iniciar una nueva sesión de Maxima.
</p>
<p>Los valores de los argumentos de una funcón se tratan exactamente de la misma forma que las variables de un bloque. Así, con
</p>
<pre class="example">f(x) := (expr1, ..., exprn);
</pre>
<p>y
</p>
<pre class="example">f(1);
</pre>
<p>se estaría en un contexto similar para la evaluación de las expresiones como si se hubiera hecho
</p>
<pre class="example">block ([x: 1], expr1, ..., exprn)
</pre>
<p>Dentro de las funciones, cuando el lado derecho de la definición deba ser evaluado será útil hacer uso de <code>define</code> y posiblemente de <code>buildq</code>. 
</p>
<hr size="6">
<a name="SEC201"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC200" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC202" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC199" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.2 Funciones array </h3>

<p>Una función array almacena el valor de la función la primera
vez que es invocada con un argumento dado, devolviendo el valor
almacenado sin recalcularlo cuando es llamada con ese mismo argumento.
Estas funciones reciben también el nombre de <i>funciones memorizadoras</i>.
</p>
<p>Los nombres de las funciones array son añadidos a la lista global 
<code>arrays</code>, no a la lista global <code>functions</code>.
La función <code>arrayinfo</code> devuelve la lista de argumentos para
los que hay valores almacenados y <code>listarray</code> devuelve precisamente
estos valores almacenados.
Las funciones <code>dispfun</code> y <code>fundef</code> devuelven la definición
de la función array.
</p>
<p>La función <code>arraymake</code> construye una llamada a una función array,
de forma similar a como lo hace <code>funmake</code> para las funciones 
ordinarias. Por otro lado, <code>arrayapply</code> aplica una función array
a sus argumentos, tal como lo hace <code>apply</code> con las funciones
ordinarias. No existe para las funciones array nada similar a <code>map</code>,
aunque <code>map(lambda([<var>x</var>], <var>a</var>[<var>x</var>]), <var>L</var>)</code> o
<code>makelist(<var>a</var>[<var>x</var>], <var>x</var>, <var>L</var>)</code>,
siendo <var>L</var> una lista, podrían suplantar esta
carencia.
</p>
<p>La función <code>remarray</code> borra la definición de una función array,
así como cualesquiera valores almacenados que tenga asociados,
tal como <code>remfunction</code> lo hace con las funciones ordinarias.
</p>
<p>La llamada <code>kill(<var>a</var>[<var>x</var>])</code> borra el valor de la función array
<var>a</var> almacenado para el argumento <var>x</var>;
la próxima vez que se llame a <var>a</var> con el argumento <var>x</var>,
se recalculará el valor correspondiente.
Sin embargo, no hay forma de borrar todos los valores almacenados de
una sola vez, excepto mediante <code>kill(<var>a</var>)</code> o <code>remarray(<var>a</var>)</code>,
con lo que se borra también la definición de la propia función.
</p>
<hr size="6">
<a name="Macros"></a>
<a name="SEC202"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC201" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC203" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.3 Macros </h2>


<dl>
<dt><u>Función:</u> <b>buildq</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX1474"></a>
</dt>
<dd><p>Sustituye en paralelo las variables nombradas en la lista <var>L</var> en la expresión <var>expr</var>, sin evaluar ésta.
La expresión resultante se simplifica pero no se evalúa hasta que <code>buildq</code> termine de hacer las sustituciones.
</p>
<p>Los elementos de <var>L</var> son símbolos o expresiones de asignación del tipo <code><var>symbol</var>: <var>value</var></code>,
evaluadas en paralelo. Esto es, el valor de una variable en la parte derecha de una asignación es el valor que toma dicha variable en el contexto desde el que se invoca a <code>buildq</code>. En caso de que a una variable de <var>L</var> no se le haga una signación explícita, su valor en <code>buildq</code> es el mismo que tiene en el contexto desde el que se llama a <code>buildq</code>.
</p>
<p>Las variables referenciadas en <var>L</var> se sustituyen en <var>expr</var> en paralelo. Esto es, la sustitución para cada variable se determina antes de que se hagan las sustituciones, de forma que la sustitución de una variable no tiene efecto alguno sobre las otras.
</p>
<p>Si alguna variable <var>x</var> aparece como <code>splice (<var>x</var>)</code> en <var>expr</var>, entonces a <var>x</var> se le debe asignar una lista, la cual será interpolada en <var>expr</var> en lugar de hacer una simple sustitución; ver ejemplo más abajo.
</p>
<p>Cualesquiera otras variables de <var>expr</var> que no aparezcan en <var>L</var> se traspasan al resultado tal cual, incluso cuando tienen asignados valores en el contexto desde el que se llama a <code>buildq</code>.
</p>
<p>Ejemplos:
</p>
<p><code>a</code> queda asociada explícitamente a <code>x</code>, mientras que <code>b</code> tiene la misma asociación (29) que en el contexto de llamada y <code>c</code> es traspasado al resultado sin ser sustituido. La expresión resultante no se evalúa hasta que no se le obligue a ello mediante la evaluación explícita <code>''%</code>.
</p>
<pre class="example">(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
</pre>
<p>En este ejemplo, <code>e</code> se asocia a una lista, la cual aparece como tal en los argumentos de <code>foo</code> e interpolada en los argumentos de <code>bar</code>.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
</pre>
<p>Como se ve a continuación, el resultado se simplifica tras las sustituciones. Si la simplificación se realizase antes que las sustituciones, ambos resultados serían iguales.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
</pre>
<p>Las variables de <var>L</var> se asocian en paralelo; si se hiciese secuencialmente, el primer resultado sería <code>foo (b, b)</code>. Las sustituciones se llevan a cabo en paralelo. Compárese el segundo resultado con el resultado de <code>subst</code>, que hace las sustituciones de forma secuencial.
</p>
<pre class="example">(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
              bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
             bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
</pre>
<p>Se construye a continuación un sistema de ecuaciones con algunas variables o expresiones en el lado izquierdo y sus valores en el derecho; <code>macroexpand</code> muestra la expresión devuelta por <code>show_values</code>.
</p>
<pre class="example">(%i1) show_values ([L]) ::= buildq ([L], map (&quot;=&quot;, 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map(&quot;=&quot;, 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
</pre>
<p>Dada una función con varios argumentos, se crea otra función
en la cual algunos argumentos son fijos.
</p>

<pre class="example">(%i1) curry (f, [a]) :=
        buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
(%i2) by3 : curry (&quot;*&quot;, 3);
(%o2)        lambda([[x]], apply(*, append([3], x)))
(%i3) by3 (a + b);
(%o3)                       3 (b + a)
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>macroexpand</b><i> (<var>expr</var>)</i>
<a name="IDX1475"></a>
</dt>
<dd><p>Devuelve la macroexpansión de <var>expr</var>, sin evaluarla,
cuando <code>expr</code> es una llamada a una función macro; en caso contrario,
<code>macroexpand</code> devuelve <var>expr</var>.
</p>
<p>Si la expansión de <var>expr</var> devuelve otra llamada a una función macro, esta llamada también se expande.
</p>
<p>La función <code>macroexpand</code> no evalúa su argumento.
Sin embargo, si la expansión de una llamada a función macro tiene efectos laterales, éstos se ejecutan.
</p>
<p>Véanse también <code>::=</code>, <code>macros</code> y <code>macroexpand1</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>macroexpand1</b><i> (<var>expr</var>)</i>
<a name="IDX1476"></a>
</dt>
<dd><p>Devuelve la macroexpansión de <var>expr</var>, sin evaluarla,
cuando <code>expr</code> es una llamada a una función macro; en caso contrario,
<code>macroexpand1</code> devuelve <var>expr</var>.
</p>
<p>La función <code>macroexpand1</code> no evalúa su argumento.
Sin embargo, si la expansión de una llamada a función macro tiene efectos laterales, éstos se ejecutan.
</p>
<p>Si la expansión de <var>expr</var> devuelve otra llamada a una función macro, esta llamada no se expande.
</p>
<p>Véanse también <code>::=</code>, <code>macros</code> y <code>macroexpand</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Variable global:</u> <b>macros</b>
<a name="IDX1477"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>macros</code> es la lista de las funciones macro definidas por el usuario.
El operador de definición de funciones macro <code>::=</code> coloca la nueva función macro en esta lista,
mientras que  <code>kill</code>, <code>remove</code> y <code>remfunction</code> eliminan las funciones macro de la lista.
</p>
<p>Véase también <code>infolists</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>splice</b><i> (<var>a</var>)</i>
<a name="IDX1478"></a>
</dt>
<dd><p>Interpola la lista nombrada por el átomo  <var>a</var> dentro de una expresión, pero sólo si <code>splice</code> aparece dentro de <code>buildq</code>; en otro caso, <code>splice</code> se considera una función no definida. Si <var>a</var> aparece dentro de <code>buildq</code> sin <code>splice</code>, entonces queda sustituida por una lista dentro del resultado. El argumento de <code>splice</code> debe ser un átomo, no pudiendo ser una lista literal ni una expresión que devuelva una lista.
</p>
<p>Normalmente <code>splice</code> suministra los argumentos para una función u operador. Para una función <code>f</code>, la expresión <code>f (splice (<var>a</var>))</code> dentro de <code>buildq</code> se convierte en <code>f (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>. Dado un operador <code>o</code>, la expresión <code>&quot;o&quot; (splice (<var>a</var>)</code> dentro de <code>buildq</code> se convierte en 
<code>&quot;o&quot; (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>, donde <code>o</code> puede ser cualquier tipo de operador, normalmente uno que admita varios argumentos. Nótese que el operador debe ir encerrado entre comillas dobles <code>&quot;</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], &quot;/&quot; (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix (&quot;&lt;&gt;&quot;, &quot;&lt;&gt;&quot;);
(%o3)                          &lt;&gt;
(%i4) buildq ([x: [1, %pi, z - y]], &quot;&lt;&gt;&quot; (splice (x)));
(%o4)                   &lt;&gt;1, %pi, z - y&lt;&gt;
</pre>
</dd></dl>

<hr size="6">
<a name="Funciones-y-variables-para-la-definici_00f3n-de-funciones"></a>
<a name="SEC203"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC202" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.4 Funciones y variables para la definición de funciones </h2>

<dl>
<dt><u>Función:</u> <b>apply</b><i> (<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX1479"></a>
</dt>
<dd><p>Construye y evalúa la expresión <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
</p>
<p>La función <code>apply</code> no hace distinciones entre funciones array y 
funciones ordinarias; cuando <var>F</var> es el nombre de una función array,
<code>apply</code> evalúa <code><var>F</var>(...)</code>, esto es, hace una llamada con
paréntesis en lugar de corchetes. La función <code>arrayapply</code>
evalúa una llamada a función con corchetes para estos casos.
</p>
<p>Ejemplos:
</p>
<p>La función <code>apply</code> evalúa sus argumentos.
En este ejemplo, <code>min</code> se aplica al valor de <code>L</code>.
</p>
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre>
<p>La función <code>apply</code> evalúa sus argumentos,
incluso cuando la función <var>F</var> no lo hace.
</p>
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre>
<p>La función <code>apply</code> evalúa el nombre de función <var>F</var>.
La comilla simple <code>'</code> evita la evaluación.
El nombre <code>demoivre</code> corresponde a una variable global y
también a una función.
</p>
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>block</b><i> ([<var>v_1</var>, ..., <var>v_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1480"></a>
</dt>
<dt><u>Función:</u> <b>block</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1481"></a>
</dt>
<dd><p>La función <code>block</code> evalúa <var>expr_1</var>, ..., <var>expr_n</var> secuencialmente y devuelve el valor de la última expresión evaluada. La secuencia puede alterarse con las funciones <code>go</code>, <code>throw</code> y <code>return</code>. La última expresión es <var>expr_n</var> a menos que <code>return</code> o una expresión que contenga un <code>throw</code> sea evaluada. Las variables <var>v_1</var>, ..., <var>v_m</var> son locales en el bloque; éstas se distiguen de las globales que tengan el mismo nombre. Si no se declaran variables locales entonces se puede omitir la lista. Dentro del bloque, cualquier otra variable distinta de <var>v_1</var>, ..., <var>v_m</var> se considera global.
</p>
<p>La función <code>block</code> guarda los valores actuales de las variables <var>v_1</var>, ..., <var>v_m</var>, si los tienen, a la entrada del bloque y luego las evalúa a sí mismas, es decir les saca el valor temporalmente. A las variables locales se les puede asignar cualquier valor dentro del bloque, pero al salir de éste, los valores inicialmente almacenados quedan restaurados, al tiempo que los asignados dentro del bloque se pierden.
</p>
<p>La declaración <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los símbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de símbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto sólo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendrían un efecto global que afectarían al exterior de <code>block</code>.
</p>
<p>Un <code>block</code> puede aparecer dentro de otro <code>block</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque. Las variables locales de un bloque se consideran globales dentro de otro anidado dentro del primero. Si una variable es no local dentro de un bloque, su valor es el que le corresponde en el bloque superior. Este criterio se conoce con el nombre de &quot;alcance dinámico&quot;.
</p>
<p>El valor del bloque es el de la última sentencia o el argumento de la función <code>return</code>, que puede utilizarse para salir del bloque. La función <code>go</code> puede usarse para transferir el control a la sentencia del bloque que esté etiquetada con el argumento de <code>go</code>. Para etiquetar una sentencia basta que vaya precedida de un argumento atómico como cualquier otra sentencia dentro del bloque. Por ejemplo, <code>block ([x], x:1, tururu, x: x+1, ..., go(tururu), ...)</code>.  El argumento de <code>go</code> debe ser el nombre de una etiqueta colocada dentro del bloque. No se puede utilzar <code>go</code> para trasladarse a una etiqueta de un bloque que no sea el que contenga a <code>go</code>.
</p>
<p>Normalmente los bloques aparecerán al lado derecho de las definiciones de funciones, pero también pueden utilizarse en otros contextos.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>break</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1482"></a>
</dt>
<dd><p>Calcula e imprime <var>expr_1</var>, ..., <var>expr_n</var> para luego provocar la detención de Maxima, de modo que el usuario pueda examinar y cambiar el entorno de ejecución. Pulsando posteriormente <code>exit;</code> el cálculo se reanuda.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>catch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1483"></a>
</dt>
<dd><p>Evalúa <var>expr_1</var>, ..., <var>expr_n</var> una a una;  si alguna de ellas conlleva la evaluación de una expresión de la forma <code>throw (arg)</code>, entonces el valor de <code>catch</code> es el de <code>throw (arg)</code> y ya no se evalúan más expresiones. Esta respuesta pasa todos los niveles de anidamiento hasta el <code>catch</code> más próximo. Si no hay ningún <code>catch</code>  que contenga un <code>throw</code> se emite un mensaje de error.
</p>
<p>Si la evaluación de los argumentos no conlleva la evaluación de ningún <code>throw</code>, entonces el valor de <code>catch</code> es el devuelto por <var>expr_n</var>.
</p>
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre>
<p>La función <code>g</code> devuelve las imágenes por <code>f</code> de todos los elementos de la lista <code>l</code> si ésta contiene únicamente números no negativos; si no es este el caso, entonces <code>g</code> captura el primer negativo que encuentra y lo devuelve por medio del <code>throw</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</i>
<a name="IDX1484"></a>
</dt>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, functions)</i>
<a name="IDX1485"></a>
</dt>
<dt><u>Function:</u> <b>compfile</b><i> (<var>filename</var>, all)</i>
<a name="IDX1486"></a>
</dt>
<dd><p>Traduce funciones de Maxima a código Lisp, guardándolo 
luego en el fichero <var>filename</var>.
</p>
<p>Con la llamada <code>compfile(<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</code>
se traducen las funciones especificadas, mientras que 
<code>compfile(<var>filename</var>, functions)</code> y
<code>compfile(<var>filename</var>, all)</code> traducen las funciones definidas por
el usuario.
</p>
<p>El código Lisp traducido no se evalúa, ni el fichero 
de salida es procesado por el compilador de Lisp.
La función <code>translate</code> crea y evalúa las traducciones Lisp, mientras que
<code>compile_file</code> traduce primero de Maxima a Lisp y luego
ejecuta el compilador Lisp. 
</p>
<p>Véanse también <code>translate</code>, <code>translate_file</code> y <code>compile_file</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>compile</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1487"></a>
</dt>
<dt><u>Función:</u> <b>compile</b><i> (functions)</i>
<a name="IDX1488"></a>
</dt>
<dt><u>Función:</u> <b>compile</b><i> (all)</i>
<a name="IDX1489"></a>
</dt>
<dd><p>Traduce las funciones de Maxima <var>f_1</var>, ..., <var>f_n</var> a Lisp, evaluando el código resultante, y llama a la función Lisp <code>COMPILE</code> para cada función traducida. La función <code>compile</code> devuelve una lista con los nombres de las funciones compiladas.
</p>
<p>Las llamadas <code>compile (all)</code> o <code>compile (functions)</code> compilan todas las funciones definidas por el usuario.
</p>
<p>La función <code>compile</code> no evalúa sus argumentos, pero con el operador comilla-comilla (<code>''</code>) sí lo hace.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>define</b><i> (<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>), <var>expr</var>)</i>
<a name="IDX1490"></a>
</dt>
<dt><u>Función:</u> <b>define</b><i> (<var>f</var>[<var>x_1</var>, ..., <var>x_n</var>], <var>expr</var>)</i>
<a name="IDX1491"></a>
</dt>
<dt><u>Función:</u> <b>define</b><i> (funmake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1492"></a>
</dt>
<dt><u>Función:</u> <b>define</b><i> (arraymake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1493"></a>
</dt>
<dt><u>Función:</u> <b>define</b><i> (ev (<var>expr_1</var>), <var>expr_2</var>)</i>
<a name="IDX1494"></a>
</dt>
<dd><p>Define una función de nombre <var>f</var> con argumentos <var>x_1</var>, ..., <var>x_n</var> y cuerpo <var>expr</var>.
<code>define</code> evalúa siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple. La función así
definida puede ser una función ordinaria de Maxima (con sus argumentos
encerrados entre paréntesis) o una función array (con sus argumentos encerrados
entre corchetes).
</p>
<p>Cuando el último o único argumento <var>x_n</var> es una lista de un solo 
elemento, la función definida por <code>define</code> acepta un número variable
de argumentos. Los valores de los argumentos se van asignando uno a uno a 
<var>x_1</var>, ..., <var>x_(n - 1)</var>, y los que queden, si los hay, se asignan 
a <var>x_n</var> en forma de lista.
</p>
<p>Cuando el primer argumento de <code>define</code> es una expresión de la
forma <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> o
<code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>, se evalúan los argumentos de la función,
pero no <var>f</var>, incluso cuando se trate de una función o variable ya existente 
con ese nombre.
</p>
<p>Cuando el primer argumento es una expresión con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se evalúa este primer argumento, lo que
permite calcular la función.
</p>
<p>Todas las definiciones de funciones aparecen en el mismo espacio
de nombres; definiendo una función <code>f</code> dentro de otra
función <code>g</code> no limita automáticamente el alcance de <code>f</code> a <code>g</code>.
Sin embargo, <code>local(f)</code> hace que la definición de la función <code>f</code>
sea efectiva sólo dentro del bloque o expresión compuesta en el que
aparece <code>local</code>.
</p>
<p>Si un argumento formal <var>x_k</var> es un símbolo afectado
por el operador comilla simple (expresión nominal), la función definida por
<code>define</code> no evalúa el correspondiente valor de argumento.
En cualquier otro caso, los argumentos que se pasan son evaluados.
</p>
<p>Véanse también <code>:=</code> y <code>::=</code>.
</p>
<p>Ejemplos:
</p>
<p><code>define</code> evalúa siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple.
</p>
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre>
<p>La función así
definida puede ser una función ordinaria de Maxima o una función array.
</p>
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre>
<p>Cuando el último o único argumento <var>x_n</var> es una lista de un solo 
elemento, la función definida por <code>define</code> acepta un número variable
de argumentos.
</p>
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre>
<p>Cuando el primer argumento es una expresión con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se evalúa este primer argumento.
</p>
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>define_variable</b><i> (<var>name</var>, <var>default_value</var>, <var>mode</var>)</i>
<a name="IDX1495"></a>
</dt>
<dd><p>Introduce una variable global en el entorno de Maxima. La función 
<code>define_variable</code> puede ser útil en los paquetes escritos por
los usuarios que vayan a ser compilados o traducidos con frecuencia.
</p>
<p>La función <code>define_variable</code> ejecuta los siguientes pasos:
</p>
<ol>
<li>
<code>mode_declare (<var>name</var>, <var>mode</var>)</code> declara el modo de <var>name</var> al traductor.
Véase <code>mode_declare</code> para ver la lista de modos aceptables.

</li><li>
Si aún no tiene asignación, se le da a la variable <var>default_value</var> el valor <var>name</var>.

</li><li>
<code>declare (<var>name</var>, special)</code> la declara como especial.

</li><li>
Asocia <var>name</var> a una función de comprobación para asegurar que
a <var>name</var> sólo se le asignan valores del modo declarado.
</li></ol>



<p>La propiedad <code>value_check</code> se puede asociar a cualquier variable que haya
sido definida mediante <code>define_variable</code> en cualquiera de los modos diferentes
a <code>any</code>. La propiedad <code>value_check</code> puede ser una expresión lambda o
una función de una variable, que será invocada al intentar asignar un valor a la
variable; el argumento pasado a la función <code>value_check</code> es el valor que
se le quiere asignar a la variable.
</p>
<p>La función <code>define_variable</code> evalúa <code>default_value</code> pero no
<code>name</code> ni <code>mode</code>; el valor que devuelve es el valor actual de 
<code>name</code>, el cual es <code>default_value</code> si a <code>name</code> no se le ha
aplicado ninguna asignación, o el valor de dicha asignación en caso
contrario.
</p>
<p>Ejemplos:
</p>
<p><code>foo</code> es una variable booleana con valor inicial <code>true</code>.
</p><pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre>
<p><code>bar</code> es una variable entera, cuyo valor habrá de ser primo.
</p><pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := 
         if not primep(y) then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre>
<p><code>baz_quux</code> es una variable a la que no se le podrá asignar valor alguno.
El modo <code>any_check</code> es como <code>any</code>, 
pero <code>any_check</code> activa el mecanismo <code>value_check</code>, cosa que <code>any</code>
no hace.
</p><pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
             error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>dispfun</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1496"></a>
</dt>
<dt><u>Función:</u> <b>dispfun</b><i> (all)</i>
<a name="IDX1497"></a>
</dt>
<dd><p>Muestra la deficnión de las funciones de usuario <var>f_1</var>, ..., <var>f_n</var>. Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una función ordinaria (definida mediante <code>:=</code> o <code>define</code>), una función arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una función de subíndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre paréntesis  <code>( )</code>), una función de subíndice seleccionada por un subíndice variable, o una función de subíndice definida con un subíndice constante.
</p>
<p>La llamada <code>dispfun (all)</code> muestra todas las funciones de usuario tal como las dan las listas <code>functions</code>, <code>arrays</code> y <code>macros</code>, omitiendo las funciones con subíndices definidas con subíndices constantes.
</p>
<p>La función <code>dispfun</code> crea una etiqueta (<code>%t1</code>, <code>%t2</code>, etc.) para cada función mostrada, y asigna la definición de la función a la etiqueta. En contraste, <code>fundef</code> devuelve las definiciones de las funciones.
</p>
<p>La función <code>dispfun</code> no evalúa sus argumentos; el operador de comilla-comilla <code>''</code> permite la evaluación.
</p>
<p>La función <code>dispfun</code> devuelve la lista de etiquetas de expresiones intermedias correspondientes a las funciones mostradas.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>fullmap</b><i> (<var>f</var>, <var>expr_1</var>, ...)</i>
<a name="IDX1498"></a>
</dt>
<dd><p>Similar a <code>map</code>, pero conservará el mapeado
descendente de todas las subexpresiones hasta que los operadores
principales ya no sean los mismos.
</p>
<p>La función <code>fullmap</code> es utilizada por el simplificador de Maxima
en algunas transformaciones matriciales, por lo que Maxima generará en algunas ocasiones mensajes de error relacionados con <code>fullmap</code> aunque el usuario no haya invocado explícitamente esta función.
</p>
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fullmapl</b><i> (<var>f</var>, <var>list_1</var>, ...)</i>
<a name="IDX1499"></a>
</dt>
<dd><p>Similar a <code>fullmap</code>, pero <code>fullmapl</code> sólo hace mapeo
sobre listas y matrices.
</p>
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre>
</dd></dl>


<dl>
<dt><u>Variable del sistema:</u> <b>functions</b>
<a name="IDX1500"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>functions</code> es una lista que contiene los nombres de las funciones ordinarias de Maxima. Una función ordinaria es aquella que ha sido construida mediante cualquiera de los métodos <code>define</code> o <code>:=</code> y que es invocada utilizando paréntesis. Una función puede definirse durante una sesión de Maxima o en un fichero que posteriormente será cargado en memoria por <code>load</code> o <code>batch</code>.
</p>
<p>Las funciones array, que son invocadas con corchetes (<code>F[x]</code>),
y las funciones subindicadas, que son las invocadas con corchetes y
paréntesis (<code>F[x](y)</code>) se registran en la variable global <code>arrays</code>,
no en <code>functions</code>.
</p>
<p>Las funciones Lisp no se registran en ninguna lista.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fundef</b><i> (<var>f</var>)</i>
<a name="IDX1501"></a>
</dt>
<dd><p>Devuelve la definición de la función <var>f</var>.
</p>
<p>Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una función ordinaria (definida mediante <code>:=</code> o <code>define</code>), una función arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una función de subíndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre paréntesis  <code>( )</code>), una función de subíndice seleccionada por un subíndice variable, o una función de subíndice definida con un subíndice constante.
</p>
<p>La función <code>fundef</code> no evalúa sus argumentos; el operador comilla-comilla <code>''</code> permite la evaluación.
</p>
<p>La llamada de función <code>fundef (<var>f</var>)</code> devuelve la definición de <var>f</var>. Por el contrario, <code>dispfun (<var>f</var>)</code> crea una etiqueta intermedia y le asigna la definición a la etiqueta.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>funmake</b><i> (<var>F</var>, [<var>arg_1</var>, ..., <var>arg_n</var>])</i>
<a name="IDX1502"></a>
</dt>
<dd><p>Devuelve una expresión <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
El valor así retornado es simplificado pero no evaluado,
de forma que la función <var>F</var> no es invocada, incluso cuando exista.
</p>
<p>La función <code>funmake</code> no hace distinciones entre funciones array
y funciones ordinarias; cuando <var>F</var> es el nombre de una función array,
<code>funmake</code> devuelve <code><var>F</var>(...)</code>,
esto es, una llamada a función con paréntesis en lugar de corchetes.
La función <code>arraymake</code> devuelve una llamada a función con
corchetes para estos casos.
</p>
<p>La función <code>funmake</code> evalúa sus argumentos.
</p>
<p>Ejemplos:
</p>
<p>La función <code>funmake</code> aplicada a una función ordinaria de Maxima.
</p>
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre>
<p>La función <code>funmake</code> aplicada a una macro.
</p>
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre>
<p>La función <code>funmake</code> aplicada a una función subindicada.
</p>
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre>
<p>La función <code>funmake</code> aplicada a un símbolo
que no está asociado a función alguna.
</p>
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre>
<p>La función <code>funmake</code> evalúa sus argumentos,
pero no el valor retornado.
</p>
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre>
<p>Maxima simplifica el valor retornado de <code>funmake</code>.
</p>
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1503"></a>
</dt>
<dt><u>Function:</u> <b>lambda</b><i> ([[<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1504"></a>
</dt>
<dt><u>Function:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1505"></a>
</dt>
<dd><p>Define y devuelve una expresión lambda (es decir, una función anónima).
La función puede tener argumentos <var>x_1</var>, ..., <var>x_m</var> y/o argumentos
opcionales <var>L</var>, que aparecerán dentro del cuerpo de la función como una lista.
El valor que devuelve la función es <var>expr_n</var>.
Una expresión lambda puede asignarse a una variable y ser evaluada como si fuese una función ordinaria. Además, puede aparecer en algunos contextos en los que sea necesario un nombre de función.
</p>
<p>Cuando se evalúa la función, se crean las variables <var>x_1</var>, ..., <var>x_m</var> sin asignación de valores. Una función <code>lambda</code> puede aparecer dentro de un <code>block</code> o de otra <code>lambda</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque o de otra función <code>lambda</code>. Las variables locales se consideran globales dentro de un bloque o función <code>lambda</code> anidado dentro del primero. Si una variable es no local dentro de un bloque o función <code>lambda</code>, su valor es el que le corresponde en el bloque o función <code>lambda</code> superior. Este criterio se conoce con el nombre de &quot;alcance dinámico&quot;.
</p>
<p>Una vez establecidas las variables locales <var>expr_1</var> a <var>expr_n</var> son secuencialmente evaluadas. La variable especial  <code>%%</code> representa el valor de la expresión inmediata anterior. Las sentencias <code>throw</code> y <code>catch</code> pueden aparecer también en la lista de expresiones.
</p>
<p>La función <code>return</code> no puede aparecer en una expresión <code>lambda</code> a menos que se encuentre acotada dentro de un bloque (<code>block</code>), en cuyo caso <code>return</code> establece el valor de retorno del bloque, pero no de la expresión <code>lambda</code>, a menos que el bloque resulte ser precisamente <var>expr_n</var>. De igual manera, <code>go</code> no puede aparecer en una expresión <code>lambda</code> si no es dentro de un <code>block</code>.
</p>
<p>Las funciones <code>lambda</code> no evalúan sus argumentos;  el operador comilla-comilla <code>''</code> permite su evaluación.
</p>
<p>Ejemplo:
</p>
<ul>
<li>
Una función lambda puede asignarse a una variable y ser evaluada como si fuese una función ordinaria.
</li></ul>
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre><ul>
<li>
Una expresión lambda puede aparecer en algunos contextos en los que sea necesario un nombre de función.
</li></ul>
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre><ul>
<li>
Los argumentos son variables locales. Otras variables se consideran globales. Las variables globales son evaluadas en el momento que lo es la expresión, a menos que la evaluación de las mismas sea forzada, como cuando se hace uso de <code>''</code>.
</li></ul>
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre><ul>
<li>
Las expresiones lambda pueden anidarse. Las variables locales de expresiones lambda exteriores se consideran globales en expresiones internas, a menos que se enmascaren con variables locales de igual nombre.
</li></ul>
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre><ul>
<li>
Puesto que <code>lambda</code> no evalúa sus argumentos, la expresión lambda <code>i</code> de más abajo no define una función del tipo &quot;multiplicar por <code>a</code>&quot;. Tal tipo de función se puede definir a través de <code>buildq</code>, como en la expresión lambda <code>i2</code> de más abajo.
</li></ul>
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre><ul>
<li>
Una expresión lambda puede tener un número variable de argumentos,
los cuales se indican mediante <code>[<var>L</var>]</code>, bien sea solo o como un
último argumento. Estos argumentos aparecerán dentro del cuerpo de
la función en forma de lista.
</li></ul>
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></dd></dl>

<dl>
<dt><u>Función:</u> <b>local</b><i> (<var>v_1</var>, ..., <var>v_n</var>)</i>
<a name="IDX1506"></a>
</dt>
<dd><p>La declaración <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los símbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
</p>
<p>Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de símbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto sólo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendrían un efecto global que afectarían al exterior de <code>block</code>.
</p>
<p>La función <code>local</code> sólo puede usarse dentro de un <code>block</code>, en el
cuerpo de definición de funciones o de expresiones <code>lambda</code> o en la
función <code>ev</code>, siéndole permitido aparecer una sóla vez en cada una de ellas.
</p>
<p>La función <code>local</code> no evalúa sus argumentos y devuelve <code>done</code>.
</p>
<p>Ejemplo:
</p>
<p>Definición local de una función.
</p>
<pre class="example">(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
</pre></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>macroexpansion</b>
<a name="IDX1507"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>macroexpansion</code> controla si la expansión (esto es, el valor de retorno) de una función macro se sustituye por la llamada a la función macro. Una sustitución puede acelerar futuras evaluaciones de la expresión, bajo el coste que implica tener que almacenar la expansión.
</p>
<dl compact="compact">
<dt> <code>false</code></dt>
<dd><p>La expansión de una función macro no se sustituye por la llamada a la función macro.
</p></dd>
<dt> <code>expand</code></dt>
<dd><p>La primera vez que se evalúa una llamada a función macro se almacena la expansión. De esta manera la expansión no se recalcula en llamadas posteriores; cualesquiera efectos laterales (como <code>print</code> o asignaciones a variables globales)
tan solo tienen lugar la primera vez que la función macro es evaluada. La expansión en una expresión no afecta a otras expresiones que llamen a la misma función macro.
</p></dd>
<dt> <code>displace</code></dt>
<dd><p>La primera vez que se evalúa una llamada a una función macro, la expansión se sustituye por la llamada, modificando así la expresión desde la que se hizo la llamada a la función macro. La expansión no se recalcula en llamadas posteriores; cualesquiera efectos laterales tan solo tienen lugar la primera vez que la función macro es evaluada. La expansión en una expresión no afecta a otras expresiones que llamen a la misma función macro.
</p></dd>
</dl>

<p>Ejemplos:
</p>
<p>Si <code>macroexpansion</code> vale <code>false</code>,
una función macro es llamada cada vez que la expresión de llamada es evaluada.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Si <code>macroexpansion</code> vale <code>expand</code>, una función macro tan solo es llamada una vez.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Si <code>macroexpansion</code> vale <code>expand</code>, una función macro es llamada una vez y la expresión de llamada se modifica.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_checkp</b>
<a name="IDX1508"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_checkp</code> vale <code>true</code>, <code>mode_declare</code> chequea los modos de las variables con valores asignados.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_check_errorp</b>
<a name="IDX1509"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>mode_check_errorp</code> vale <code>true</code>, <code>mode_declare</code> llama a error.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>mode_check_warnp</b>
<a name="IDX1510"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_check_warnp</code> vale <code>true</code>, se detallan los errores de modo.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>mode_declare</b><i> (<var>y_1</var>, <var>modo_1</var>, ..., <var>y_n</var>, <var>modo_n</var>)</i>
<a name="IDX1511"></a>
</dt>
<dd><p>La función <code>mode_declare</code> se utiliza para declarar los modos de variables y funciones para la ulterior traducción a Lisp o compilación de funciones. Se coloca habitualmente al comienzo de la definición de una función, de un script en Maxima o se ejecuta en tiempo real.
</p>
<p>Los argumentos de <code>mode_declare</code> son pares formados por una variable y un modo, el cual debe ser <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code> o <code>float</code>. Cada variable puede ser sustituida por una lista de variables, en cuyo caso todas ellas tendrán el mismo modo.
</p>

<p>Código numérico que utilice arreglos puede ejecutarse más rápido declarando el tamaño que va a ocupar el arreglo, como en:
</p>
<pre class="example">mode_declare (array (a [10, 10]), float)
</pre>
<p>para un arreglo de números en coma flotante de dimensiones 10 x 10.
</p>
<p>Se puede declarar el modo del resultado de una función poniendo <code>function (f_1, f_2, ...)</code> como argumento;
aquí <code>f_1</code>, <code>f_2</code>, ... son los nombres de las funciones. Por ejemplo, la expresión
</p>
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre>
<p>declara que el valor a devolver por  <code>f_1</code>, <code>f_2</code>, ... son enteros de modo &quot;single-word&quot;.
</p>
<p>El nombre <code>modedeclare</code> es sinónimo de <code>mode_declare</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>mode_identity</b><i> (<var>arg_1</var>, <var>arg_2</var>)</i>
<a name="IDX1512"></a>
</dt>
<dd><p>Es una forma especial usada con <code>mode_declare</code> y <code>macros</code> para declarar, por ejemplo, una lista de listas de números. 
</p>

</dd></dl>



<dl>
<dt><u>Función:</u> <b>remfunction</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1513"></a>
</dt>
<dt><u>Función:</u> <b>remfunction</b><i> (all)</i>
<a name="IDX1514"></a>
</dt>
<dd><p>Desliga las definiciones de función de sus símbolos <var>f_1</var>, ..., <var>f_n</var>.
Los argumentos pueden ser nombres de funciones ordinarias 
(creadas con <code>:=</code> o <code>define</code>) o de funciones macro (creadas con <code>::=</code>).
</p>
<p>La instrucción <code>remfunction (all)</code> desliga todas las definiciones de funciones.
</p>
<p>La función <code>remfunction</code> no evalúa sus argumentos.
</p>
<p>La función <code>remfunction</code> devuelve una lista con los
símbolos para los que la definición de función
fue desligada. Devuelve <code>false</code> en el lugar de cualquier 
símbolo para el que no hay función definida.
</p>
<p>La función <code>remfunction</code> no se puede aplicar a arrays de funciones ni a
funciones subindicadas. Sí es aplicable en tales casos la 
función <code>remarray</code>.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>savedef</b>
<a name="IDX1515"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>savedef</code> vale <code>true</code>, se mantiene la versión Maxima de una función definida por el usuario cuando ésta se traduce, lo que permite mostrar su código con <code>dispfun</code> y que la función pueda ser editada.
</p>
<p>Si <code>savedef</code> vale <code>false</code>, los nombres de las funciones traducidas se eliminan de la lista <code>functions</code>.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>transcompile</b>
<a name="IDX1516"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transcompile</code> vale <code>true</code>, <code>translate</code> y <code>translate_file</code> generan declaraciones para hacer el código traducido más apto para la compilación.
</p>
<p>La función <code>compfile</code> hace la asignación <code>transcompile: true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>translate</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1517"></a>
</dt>
<dt><u>Función:</u> <b>translate</b><i> (functions)</i>
<a name="IDX1518"></a>
</dt>
<dt><u>Función:</u> <b>translate</b><i> (all)</i>
<a name="IDX1519"></a>
</dt>
<dd><p>Traduce las funciones definidas por el usuario <var>f_1</var>, ..., <var>f_n</var> del lenguaje de Maxima a Lisp y evalúa las traducciones Lisp. Normalmente las funciones traducidas se ejecutan más rapidamente que las originales.
</p>
<p>Las llamadas <code>translate (all)</code> o <code>translate (functions)</code> traducen todas las funciones de usuario.
</p>
<p>Las funciones a ser traducidas deberían incluir una llamada a <code>mode_declare</code> al comienzo siempre que sea posible, a fin de producir código más eficiente. Por ejemplo:
</p>
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, modo_1, v_2, modo_2, ...), ...)
</pre>


<p>donde <var>x_1</var>, <var>x_2</var>, ... son los parámetros que se pasan a la función y <var>v_1</var>, <var>v_2</var>, ... son las variables locales.
</p>
<p>Los nombres de las funciones traducidas son eliminados de la lista <code>functions</code> si <code>savedef</code> vale <code>false</code> (ver más abajo) y son añadidos a las listas <code>props</code>.
</p>
<p>Las funciones no deberían ser traducidas hasta no estar completamente depuradas.
</p>
<p>Se supone que las expresiones están simplificadas; en caso de no estarlo, se generará código correcto pero ineficiente. Así, el usuario no debería asignar a <code>simp</code> el valor <code>false</code>, el cual inhibe la simplificación de la expresión a ser traducida.
</p>
<p>Cuando la variable <code>translate</code> vale <code>true</code>, se traducen automáticamente las funciones de usuario a Lisp.
</p>
<p>Nótese que las funciones traducidas puede que no se ejecuten exactamente igual a como lo hacían antes de la traducción, debido a posibles incompatibilidades entre las versiones de Maxima y Lisp. En general, la función <code>rat</code> con más de un argumento y la función <code>ratvars</code> no deberían utilizarse si algunas de las variables son declaradas como expresiones racionales canónicas (CRE) mediante <code>mode_declare</code>. Además, la asignación  <code>prederror: false</code> no traducirá.
</p>
<p>Si <code>savedef</code> vale <code>true</code>, entonces la versión de Maxima de una función de usuario permanecerá cuando la función sea traducida por <code>translate</code>. Con esto se hace posible que se muestre la definición llamando a <code>dispfun</code> y que la función sea editada.
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces las versiones interpretadas de todas las funciones serán ejecutadas en lugar de las versiones traducidas.
</p>
<p>El resultado devuelto por <code>translate</code> es una lista con los nombres de las funciones traducidas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>translate_file</b><i> (<var>nombre_fichero_maxima</var>)</i>
<a name="IDX1520"></a>
</dt>
<dt><u>Función:</u> <b>translate_file</b><i> (<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</i>
<a name="IDX1521"></a>
</dt>
<dd><p>Traduce un fichero en código Maxima a un fichero en código Lisp. La función <code>translate_file</code> devuelve una lista con los nombres de tres ficheros: el nombre del ficheero en Maxima, el nombre del fichero en Lisp y el nombre del fichero que contiene información adicional sobre la traducción. La función <code>translate_file</code> evalúa sus argumentos.
</p>
<p>La llamada <code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code> es lo mismo que <code>batch (&quot;foo.mac&quot;)</code>, excepto por la presencia de ciertas restricciones, como el uso de <code>''</code> y <code>%</code>, por ejemplo.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>)</code> traduce un fichero en Maxima, <var>nombre_fichero_maxima</var>, a otro en Lisp de nombre similar. Por ejemplo, <code>foo.mac</code> se traduce en <code>foo.LISP</code>. El nombre del fichero en Maxima puede incluir el nombre de un directorio, en cuyo caso el fichero de salida Lisp se guardará en el mismo directorio desde el que se leyó la fuente Maxima.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</code> traduce el fichero Maxima  <var>nombre_fichero_maxima</var> en el fichero Lisp <var>nombre_fichero_lisp</var>. La función <code>translate_file</code> ignora la extensión del fichero, en caso de que exista, de <code>nombre_fichero_lisp</code>; la extensión del fichero de salida Lisp  será invariablemente <code>LISP</code>. El nombre del fichero Lisp puede incluir la ruta del directorio, en cuyo caso se almacenará en el directorio especificado.
</p>
<p>La función <code>translate_file</code> también escribe un fichero de mensajes de avisos del traductor con diversos niveles de gravedad. La extensión de este fichero es <code>UNLISP</code>. Este fichero puede contener información valiosa, aunque de difícil interpretación, para detectar fallos en el código traducido. El fichero <code>UNLISP</code> se guarda siempre en el mismo directorio desde el que se leyó la fuente de Maxima.
</p>
<p>La función <code>translate_file</code> emite código Lisp que incluye algunas declaraciones y definiciones que entran en efecto tan pronto como el código Lisp es compilado. Véase <code>compile_file</code> para más información sobre este particular.
</p>
<p>Véanse también <code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>, 
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>, 
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>, 
<code>tr_semicompile</code>,
<code>tr_state_vars</code>, 
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>, 
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>,
y <code>tr_warn_undefined_variable</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>transrun</b>
<a name="IDX1522"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces se ejecutarán las versiones interpretadas de todas las funciones, en lugar de las versiones traducidas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_array_as_ref</b>
<a name="IDX1523"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>translate_fast_arrays</code> vale <code>false</code>, referencias de arreglos en el código Lisp creadas por  <code>translate_file</code> se ven afectadas por <code>tr_array_as_ref</code>.
</p>
<p>El valor de la variable <code>tr_array_as_ref</code> no tiene ningún efecto cuando <code>translate_fast_arrays</code> vale <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_bound_function_applyp</b>
<a name="IDX1524"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>tr_bound_function_applyp</code> vale <code>true</code>, Maxima envía un aviso si encuentra una variable con valor asignado que está siendo utilizada como una función. <code>tr_bound_function_applyp</code> no influye en el código generado bajo estas circunstancias.
</p>
<p>Por ejemplo, una expresión como <code>g (f, x) := f (x+1)</code> provocará un mensaje de esta naturaleza.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_file_tty_messagesp</b>
<a name="IDX1525"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_file_tty_messagesp</code> vale <code>true</code>, los mensajes generados por <code>translate_file</code> durante la traducción de un fichero se muestran en la consola y se insertan en el fichero UNLISP.  Si vale <code>false</code>, los mensajes sobre la traducción del fichero sólo se incorporan al fichero UNLISP.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_float_can_branch_complex</b>
<a name="IDX1526"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Le dice al traductor de Maxima a Lisp que las funciones <code>acos</code>, <code>asin</code>, <code>asec</code> y <code>acsc</code> pueden devolver valores complejos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_function_call_default</b>
<a name="IDX1527"></a>
</dt>
<dd><p>Valor por defecto: <code>general</code>
</p>
<p>El valor <code>false</code> significa llama a <code>meval</code>, <code>expr</code> significa que Lisp asignó los argumentos de la función,  <code>general</code>, el valor por defecto, devuelve código apropiado para <code>mexprs</code> y <code>mlexprs</code> pero no para <code>macros</code>. La opción <code>general</code> asegura que las asignaciones de las variables son correctas en el código compilado. En modo <code>general</code>, cuando se traduce F(X), si F es una variable con valor, entonces se entiende que se quiere calcular <code>apply (f, [x])</code>, y como tal se traduce, con el apropiado aviso. No es necesario desactivar esto. Con los valores por defecto la falta de mensajes de aviso implica compatibilidad completa entre el código traducido y compilado con el interpretado por Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_numer</b>
<a name="IDX1528"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_numer</code> vale <code>true</code> se utilizan las propiedades numéricas en aquellos átomos que las posean, como en  <code>%pi</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_optimize_max_loop</b>
<a name="IDX1529"></a>
</dt>
<dd><p>Valor por defecto: 100
</p>
<p>El valor de <code>tr_optimize_max_loop</code> es el número máximo de veces que el traductor repetirá la macro-expansión y la optimización en el tratamiento de una expresión.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_semicompile</b>
<a name="IDX1530"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_semicompile</code> vale <code>true</code>, las salidas de <code>translate_file</code> y <code>compfile</code> serán macro-expandidas pero no compiladas a código máquina por el compilador de Lisp.
</p>
</dd></dl>

<dl>
<dt><u>Variable del sistema:</u> <b>tr_state_vars</b>
<a name="IDX1531"></a>
</dt>
<dd><p>Valor por defecto:
</p>
<pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre>
<p>Es la lista de variables que afectan la forma en que se obtiene la salida del código traducido. Esta información es útil para desarrolladores que pretendan corregir posibles fallos del traductor. Comparando el código traducido con el que se debería obtener bajo unas ciertas condiciones, es posible hacer el seguimiento de los fallos.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>tr_warnings_get</b><i> ()</i>
<a name="IDX1532"></a>
</dt>
<dd><p>Devuelve una lista con los avisos dados por el traductor.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_bad_function_calls</b>
<a name="IDX1533"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Devuelve un aviso cuando se hacen llamadas a funciones que quizás no sean correctas debido a declaraciones inapropiadas realizadas durante la traducción.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_fexpr</b>
<a name="IDX1534"></a>
</dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si se encuentra con alguna FEXPR. Las FEXPR no deberían aparecer en el código traducido.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_meval</b>
<a name="IDX1535"></a>
</dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si la función <code>meval</code> es llamada.  Si <code>meval</code> es invocada, es señal de la presencia de problemas en la traducción.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_mode</b>
<a name="IDX1536"></a>
</dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando a las variables se les asignan valores incompatibles con su modo.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_undeclared</b>
<a name="IDX1537"></a>
</dt>
<dd><p>Valor por defecto: <code>compile</code>
</p>
<p>Determina cuando enviar mensajes sobre variables no declaradas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>tr_warn_undefined_variable</b>
<a name="IDX1538"></a>
</dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando se detectan variables globales no definidas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>compile_file</b><i> (<var>nombre_fich</var>)</i>
<a name="IDX1539"></a>
</dt>
<dt><u>Función:</u> <b>compile_file</b><i> (<var>nombre_fich</var>, <var>nombre_fich_compilado</var>)</i>
<a name="IDX1540"></a>
</dt>
<dt><u>Función:</u> <b>compile_file</b><i> (<var>nombre_fich</var>, <var>nombre_fich_compilado</var>, <var>nombre_fich_lisp</var>)</i>
<a name="IDX1541"></a>
</dt>
<dd><p>Traduce el fichero Maxima <var>nombre_fich</var> a Lisp, ejecuta el compilador de Lisp y, en caso de ser exitosa la compilación, carga el código compilado en Maxima.
</p>
<p>La función <code>compile_file</code> devuelve una lista con los nombres de tres ficheros: el fichero original en Maxima, la traducción Lisp, notas sobre la traducción y el código compilado. Si la compilación falla, el cuarto elemento es  <code>false</code>.
</p>
<p>Algunas declaraciones y definiciones entran en efecto tan pronto como el código Lisp es compilado (sin cargar el código compilado). Éstas incluyen funciones definidas con el operador <code>:=</code>, macros definidas con el operador <code>::=</code>, <code>alias</code>, <code>declare</code>, <code>define_variable</code>,  <code>mode_declare</code> y <code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code> y <code>compfile</code>.
</p>
<p>Asignaciones y llamadas a funciones no se evalúan hasta que el código compilado es cargado. En particular, dentro del fichero Maxima, asignaciones a los controles (&quot;flags&quot;) de traducción (<code>tr_numer</code>, etc.) no tienen efecto durante la traducción.
</p>
<p>El <var>nombre_fich</var> no puede contener sentencias del tipo <code>:lisp</code>.
</p>
<p>La función <code>compile_file</code> evalúa sus argumentos.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>declare_translated</b><i> (<var>f_1</var>, <var>f_2</var>, ...)</i>
<a name="IDX1542"></a>
</dt>
<dd><p>Cuando se traduce un fichero de código Maxima a Lisp, es importante para el traductor saber qué funciones de las que están en el fichero van a ser llamadas como traducidas o compiladas, y cuáles son simplemente funciones Maxima o que no están definidas. Se genera el código <code>(MFUNCTION-CALL fn arg1 arg2 ...)</code> cuando el traductor no sabe si <code>fn</code> va a ser una función lisp.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC204" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>octubre, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
