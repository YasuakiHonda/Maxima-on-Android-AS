<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on octubre, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.41.0: 29. Teoría de Números</title>

<meta name="description" content="Manual de Maxima 5.41.0: 29. Teoría de Números">
<meta name="keywords" content="Manual de Maxima 5.41.0: 29. Teoría de Números">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Teor_00eda-de-N_00fameros"></a>
<a name="SEC173"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_28.html#SEC172" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC174" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_30.html#SEC175" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 29. Teoría de Números </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC174">29.1 Funciones y variables para teoría de números</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Funciones-y-variables-para-teor_00eda-de-n_00fameros"></a>
<a name="SEC174"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC173" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_30.html#SEC175" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC173" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC173" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_30.html#SEC175" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.1 Funciones y variables para teoría de números </h2>


<dl>
<dt><u>Función:</u> <b>bern</b><i> (<var>n</var>)</i>
<a name="IDX1255"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-ésimo número de Bernoulli del entero <var>n</var>.
Los números de Bernoulli iguales a cero son suprimidos si <code>zerobern</code> vale <code>false</code>.
</p>
<p>Véase también <code>burn</code>.
</p>
<pre class="example">(%i1) zerobern: true$
(%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1       1      1        1
(%o2)           [1, - -, -, 0, - --, 0, --, 0, - --]
                      2  6       30     42       30
(%i3) zerobern: false$
(%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   1     1   5     691   7
(%o4)           [1, - -, -, - --, --, - --, --, - ----, -]
                      2  6    30  42    30  66    2730  6
</pre>


</dd></dl>

<dl>
<dt><u>Función:</u> <b>bernpoly</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1256"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-ésimo polinomio de Bernoulli de variable <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>bfzeta</b><i> (<var>s</var>, <var>n</var>)</i>
<a name="IDX1257"></a>
</dt>
<dd><p>Devuelve la función zeta de Riemann para el argumento <var>s</var>. El valor que devuelve es del tipo &quot;big float&quot; (bfloat) y 
<var>n</var>  es su número de dígitos.
</p>
<p>Es necesario cargar en memoria esta función haciendo <code>load (&quot;bffac&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>bfhzeta</b><i> (<var>s</var>, <var>h</var>, <var>n</var>)</i>
<a name="IDX1258"></a>
</dt>
<dd><p>Devuelve la función zeta de Hurwitz para los argumentos <var>s</var> y <var>h</var>. El valor que devuelve es del tipo &quot;big float&quot; (bfloat) y <var>n</var>  es su número de dígitos.
</p>
<p>La función zeta de Hurwitz se define como
</p>
<pre class="example">                        inf
                        ====
                        \        1
         zeta (s,h)  =   &gt;    --------
                        /            s
                        ====  (k + h)
                        k = 0
</pre>
<p>Ejecútese <code>load (bffac)</code> antes de hacer uso de esta función.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>burn</b><i> (<var>n</var>)</i>
<a name="IDX1259"></a>
</dt>
<dd><p>Siendo <var>n</var> entero, Devuelve un número racional que aproxima el 
<var>n</var>-ésimo número de Bernoulli. La función <code>burn</code> aprovecha
el hecho de que los números de Bernoulli racionales se pueden aproximar
con notable precisión gracias a 
</p>
<pre class="example">                   n - 1  1 - 2 n
              (- 1)      2        zeta(2 n) (2 n)!
     B(2 n) = ------------------------------------
                                2 n
                             %pi
</pre>
<p>La función <code>burn</code> puede ser más eficiente que <code>bern</code> cuando 
<var>n</var> es un número grande, ya que <code>bern</code> calcula todos los números
de Bernoulli hasta el <var>n</var>-ésimo. Por el contrario, <code>burn</code> hace 
uso de la aproximación para enteros pares <var>n</var> &gt; 255. En caso de
enteros impares y <var>n</var> &lt;= 255, se hace uso de la función <code>bern</code>.
</p>
<p>Para utilizar esta función hay que cargarla antes en memoria escribiendo
<code>load (&quot;bffac&quot;)</code>. Véase también <code>bern</code>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>chinese</b><i> ([<var>r_1</var>, &hellip;, <var>r_n</var>], [<var>m_1</var>, &hellip;, <var>m_n</var>])</i>
<a name="IDX1260"></a>
</dt>
<dd><p>Resulve el sistema de congruencias <code>x = r_1 mod m_1</code>, &hellip;, <code>x = r_n mod m_n</code>.
Los restos <var>r_n</var> pueden ser enteros arbitrarios, mientras que los módulos <var>m_n</var>
deben ser positivos y primos dos a dos. 
</p>
<pre class="example">(%i1) mods : [1000, 1001, 1003, 1007];
(%o1)                   [1000, 1001, 1003, 1007]
(%i2) lreduce('gcd, mods);
(%o2)                               1
(%i3) x : random(apply(&quot;*&quot;, mods));
(%o3)                         685124877004
(%i4) rems : map(lambda([z], mod(x, z)), mods);
(%o4)                       [4, 568, 54, 624]
(%i5) chinese(rems, mods);
(%o5)                         685124877004
(%i6) chinese([1, 2], [3, n]);
(%o6)                    chinese([1, 2], [3, n])
(%i7) %, n = 4;
(%o7)                              10
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>cf</b><i> (<var>expr</var>)</i>
<a name="IDX1261"></a>
</dt>
<dd><p>Calcula aproximaciones con fracciones continuas. <var>expr</var> es una expresión
que contiene fracciones continuas, raíces cuadradas de enteros,
y números reales (enteros, racionales, decimales en coma flotante y decimales de
precisión arbitraria). <code>cf</code> calcula expansiones exactas de números 
racionales, pero las expansiones de nÃºmeros decimales de coma flotante se truncan
de acuerdo con el valor de <code>ratepsilon</code>, y la de los de decimales de precisión
arbitraria (bigfloats) lo hacen respecto de <code>10^(-fpprec)</code>.
</p>
<p>En las expresiones se pueden combinar operandos con operadores aritméticos.
Maxima no conoce operaciones con fracciones continuas más allá de
la función <code>cf</code>.
</p>
<p>La función <code>cf</code> evalúa sus argumentos después de asignar a la 
variable <code>listarith</code> el valor <code>false</code>, retornando una fracción
continua en forma de lista.
</p>
<p>Una fracción continua <code>a + 1/(b + 1/(c + ...))</code> se representa como la
lista <code>[a, b, c, ...]</code>, donde los elementos <code>a</code>, <code>b</code>, <code>c</code>, ... 
se evalúan como enteros. La expresión <var>expr</var> puede contener también  
<code>sqrt (n)</code> donde <code>n</code> es un entero; en tal caso, <code>cf</code> devolverá 
tantos términos de la fracción continua como indique el valor de la variable 
<code>cflength</code> multiplicado por el período.
</p>
<p>Una fracción continua puede reducirse a un número evaluando la representación 
aritmética que devuelve <code>cfdisrep</code>. Véase también  <code>cfexpand</code>, 
que es otra alternativa para evaluar fracciones continuas.
</p>
<p>Véanse asimismo <code>cfdisrep</code>, <code>cfexpand</code> y <code>cflength</code>.
</p>
<p>Ejemplos:
</p>
<ul>
<li>
La expresión <var>expr</var> contiene fracciones continuas y raíces
cuadradas de enteros.

<pre class="example">(%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
(%o1)               [59, 17, 2, 1, 1, 1, 27]
(%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
(%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]
</pre>
</li><li>
La variable <code>cflength</code> controla cuantos períodos de la fracción 
continua se calculan para números irracionales algebraicos.

<pre class="example">(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
</pre>
</li><li>
Una fracción continua puede calcularse evaluando la representación aritmética 
que devuelve <code>cfdisrep</code>.

<pre class="example">(%i1) cflength: 3$
(%i2) cfdisrep (cf (sqrt (3)))$
(%i3) ev (%, numer);
(%o3)                   1.731707317073171
</pre>
</li><li>
Maxima no sabe sobre operaciones con fracciones continuas más de lo que aporta 
la función <code>cf</code>.

<pre class="example">(%i1) cf ([1,1,1,1,1,2] * 3);
(%o1)                     [4, 1, 5, 2]
(%i2) cf ([1,1,1,1,1,2]) * 3;
(%o2)                  [3, 3, 3, 3, 3, 6]
</pre>
</li></ul>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>cfdisrep</b><i> (<var>lista</var>)</i>
<a name="IDX1262"></a>
</dt>
<dd><p>Construye y devuelve una expresión aritmética ordinaria de la forma  <code>a + 1/(b + 1/(c + ...))</code> a partir de la representación en formato lista de la fracción continua  <code>[a, b, c, ...]</code>.
</p>
<pre class="example">(%i1) cf ([1, 2, -3] + [1, -2, 1]);
(%o1)                     [1, 1, 1, 2]
(%i2) cfdisrep (%);
                                  1
(%o2)                     1 + ---------
                                    1
                              1 + -----
                                      1
                                  1 + -
                                      2
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>cfexpand</b><i> (<var>x</var>)</i>
<a name="IDX1263"></a>
</dt>
<dd><p>Devuelve la matriz con los numeradores y denominadores de la última (columna 1) y penúltima (columna 2) convergentes de la fracción continua <var>x</var>.
</p>
<pre class="example">(%i1) cf (rat (ev (%pi, numer)));

`rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
(%o1)                  [3, 7, 15, 1, 292]
(%i2) cfexpand (%); 
                         [ 103993  355 ]
(%o2)                    [             ]
                         [ 33102   113 ]
(%i3) %[1,1]/%[2,1], numer;
(%o3)                   3.141592653011902
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>cflength</b>
<a name="IDX1264"></a>
</dt>
<dd><p>Valor por defecto: 1
</p>
<p>La variable <code>cflength</code> controla el número de términos de la fracción continua que devuelve la función <code>cf</code>, que será <code>cflength</code> multiplicado por el período. Así, el valor por defecto será el de un período.
</p>
<pre class="example">(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>divsum</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1265"></a>
</dt>
<dt><u>Función:</u> <b>divsum</b><i> (<var>n</var>)</i>
<a name="IDX1266"></a>
</dt>
<dd><p>La llamada <code>divsum (<var>n</var>, <var>k</var>)</code> devuelve la suma de los divisores de <var>n</var> elevados a la <var>k</var>-ésima potencia.
</p>
<p>La llamada <code>divsum (<var>n</var>)</code> devuelve la suma de los divisores de <var>n</var>.
</p>
<pre class="example">(%i1) divsum (12);
(%o1)                          28
(%i2) 1 + 2 + 3 + 4 + 6 + 12;
(%o2)                          28
(%i3) divsum (12, 2);
(%o3)                          210
(%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
(%o4)                          210
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>euler</b><i> (<var>n</var>)</i>
<a name="IDX1267"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-ésimo número de Euler del entero no negativo <var>n</var>.
Los número de Euler iguales a cero se eliminan si <code>zerobern</code> vale <code>false</code>.
</p>
<p>Para la constante de Euler-Mascheroni, véase <code>%gamma</code>.
</p>
<pre class="example">(%i1) zerobern: true$
(%i2) map (euler, [0, 1, 2, 3, 4, 5, 6]);
(%o2)               [1, 0, - 1, 0, 5, 0, - 61]
(%i3) zerobern: false$
(%i4) map (euler, [0, 1, 2, 3, 4, 5, 6]);
(%o4)               [1, - 1, 5, - 61, 1385, - 50521, 2702765]
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>factors_only</b>
<a name="IDX1268"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Controla el resultado devuelto por <code>ifactors</code>. El valor por defecto
<code>false</code> hace que <code>ifactors</code> no dé información sobre las
multiplicidades de los factores primos calculados. Cuando <code>factors_only</code>
vale <code>true</code>, <code>ifactors</code> solo devuelve la lista de factores primos.
</p>
<p>Para ejemplos, véase <code>ifactors</code>.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>fib</b><i> (<var>n</var>)</i>
<a name="IDX1269"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-ésimo número de Fibonacci. La llamada <code>fib(0)</code> 
devuelve 0, <code>fib(1)</code> devuelve 1 y <code>fib (-<var>n</var>)</code> es igual a 
<code>(-1)^(<var>n</var> + 1) * fib(<var>n</var>)</code>.
</p>
<p>Después de llamar a <code>fib</code>, la variable <code>prevfib</code> toma el valor 
<code>fib (<var>n</var> - 1)</code>, que es el número de Fibonacci que precede al último calculado.
</p>
<pre class="example">(%i1) map (fib, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
(%o1)           [- 3, 2, - 1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>fibtophi</b><i> (<var>expr</var>)</i>
<a name="IDX1270"></a>
</dt>
<dd><p>Expresa los números de Fibonacci en <var>expr</var> en términos de la razón áurea <code>%phi</code>,
que es <code>(1 + sqrt(5))/2</code>, aproximadamente 1.61803399.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) fibtophi (fib (n));
                           n             n
                       %phi  - (1 - %phi)
(%o1)                  -------------------
                           2 %phi - 1
(%i2) fib (n-1) + fib (n) - fib (n+1);
(%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
(%i3) fibtophi (%);
            n + 1             n + 1       n             n
        %phi      - (1 - %phi)        %phi  - (1 - %phi)
(%o3) - --------------------------- + -------------------
                2 %phi - 1                2 %phi - 1
                                          n - 1             n - 1
                                      %phi      - (1 - %phi)
                                    + ---------------------------
                                              2 %phi - 1
(%i4) ratsimp (%);
(%o4)                           0
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>ifactors</b><i> (<var>n</var>)</i>
<a name="IDX1271"></a>
</dt>
<dd><p>Devuelve la factorización del entero positivo <var>n</var>. Si <code>n=p1^e1..pk^nk</code> es
la descomposición de <var>n</var> en números primos, <code>ifactors</code> devuelve 
<code>[[p1, e1], ... , [pk, ek]]</code>.
</p>
<p>Los métodos de factorización se basan en divisiones tentativas con números primos
hasta 9973, en los métodos rho y p-1 de Pollard y en curvas elípticas.
</p>
<p>La respuesta que se obtiene de <code>ifactors</code> está controlada por la variable opcional
<code>factors_only</code>. El valor por defecto <code>false</code> hace que <code>ifactors</code> no 
dé información sobre las multiplicidades de los factores primos calculados. 
Cuando <code>factors_only</code> vale <code>true</code>, <code>ifactors</code> solo devuelve la lista 
de factores primos.
</p>
<pre class="example">(%i1) ifactors(51575319651600);
(%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
(%i2) apply(&quot;*&quot;, map(lambda([u], u[1]^u[2]), %));
(%o2)                        51575319651600
(%i3) ifactors(51575319651600), factors_only : true;
(%o3)                   [2, 3, 5, 1583, 9050207]
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>igcdex</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1272"></a>
</dt>
<dd><p>Devuelve la lista <code>[<var>a</var>, <var>b</var>, <var>u</var>]</code>, donde <var>u</var> es
el máximo común divisor de <var>n</var> y <var>k</var>, siendo <var>u</var>
igual a <code><var>a</var> <var>n</var> + <var>b</var> <var>k</var></code>. Los argumentos
<var>n</var> y <var>k</var> deben ser enteros.
</p>
<p><code>igcdex</code> implementa el algoritmo de Euclides. Véase también <code>gcdex</code>.
</p>
<p>La instrucción <code>load(gcdex)</code> carga esta función.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) load(gcdex)$

(%i2) igcdex(30,18);
(%o2)                      [- 1, 2, 6]
(%i3) igcdex(1526757668, 7835626735736);
(%o3)            [845922341123, - 164826435, 4]
(%i4) igcdex(fib(20), fib(21));
(%o4)                   [4181, - 2584, 1]
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>inrt</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1273"></a>
</dt>
<dd><p>Devuelve la raíz entera <var>n</var>-ésima del valor absoluto de  <var>x</var>.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], inrt (10^a, 3)), l);
(%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>inv_mod</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1274"></a>
</dt>
<dd><p>Calcula el inverso de <var>n</var> módulo <var>m</var>. 
La llamada <code>inv_mod (n,m)</code> devuelve <code>false</code>
si <var>n</var> es un divisor nulo módulo <var>m</var>.
</p>
<pre class="example">(%i1) inv_mod(3, 41);
(%o1)                           14
(%i2) ratsimp(3^-1), modulus = 41;
(%o2)                           14
(%i3) inv_mod(3, 42);
(%o3)                          false
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>isqrt</b><i> (<var>x</var>)</i>
<a name="IDX1275"></a>
</dt>
<dd><p>Devuelve la &quot;raíz cuadrada entera&quot;
del valor absoluto de <var>x</var>,
el cual debe ser un entero.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>jacobi</b><i> (<var>p</var>, <var>q</var>)</i>
<a name="IDX1276"></a>
</dt>
<dd><p>Devuelve el símbolo de Jacobi para <var>p</var> y <var>q</var>.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], jacobi (a, 9)), l);
(%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>lcm</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1277"></a>
</dt>
<dd><p>Devuelve el mínimo común múltiplo de sus argumentos. 
Los argumentos pueden ser tanto expresiones en general como enteros.
</p>
<p>Es necesario cargar en memoria esta función haciendo <code>load (&quot;functs&quot;)</code>.
</p>
</dd></dl>





<dl>
<dt><u>Función:</u> <b>lucas</b><i> (<var>n</var>)</i>
<a name="IDX1278"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-ésimo número de Lucas.
<code>lucas(0)</code> es igual a 2, <code>lucas(1)</code> es igual a 1 y 
<code>lucas(-<var>n</var>)</code> es igual a <code>(-1)^(-<var>n</var>) * lucas(<var>n</var>)</code>.
</p>
<pre class="example">(%i1) map (lucas, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
(%o1)             [7, - 4, 3, - 1, 2, 1, 3, 4, 7, 11, 18, 29, 47]
</pre>
<p>Después de llamar a <code>lucas</code>, la variable global <code>next_lucas</code>
es igual a <code>lucas (<var>n</var> + 1)</code>, el número de Lucas que sigue al
último que se ha devuelto. El ejemplo muestra como los números de
Fibonacci se pueden calcular mediante  <code>lucas</code> y <code>next_lucas</code>.
</p>
<pre class="example">(%i1) fib_via_lucas(n) := 
         block([lucas : lucas(n)],
         signum(n) * (2*next_lucas - lucas)/5 )$
(%i2) map (fib_via_lucas, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
(%o2)             [- 3, 2, - 1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21]
</pre></dd></dl>






<dl>
<dt><u>Función:</u> <b>mod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX1279"></a>
</dt>
<dd><p>Si <var>x</var> e <var>y</var> son números reales e <var>y</var> es distinto de cero,
devuelve <code><var>x</var> - <var>y</var> * floor(<var>x</var> / <var>y</var>)</code>.
Para todos los reales <var>x</var>, se tiene <code>mod (<var>x</var>, 0) = <var>x</var></code>. Para información sobre la definición de  <code>mod (<var>x</var>, 0) = <var>x</var></code>, véase la sección 3.4 de &quot;Concrete Mathematics&quot;, 
by Graham, Knuth, and Patashnik. La función <code>mod (<var>x</var>, 1)</code> es de diente de sierra con periodo unidad y con <code>mod (1, 1) = 0</code> y <code>mod (0, 1) = 0</code>.
</p>
<p>Para encontrar el argumento principal (un número del intervalo <code>(-%pi, %pi]</code>) de un número complejo, hágase uso de la función <code><var>x</var> |-&gt; %pi - mod (%pi - <var>x</var>, 2*%pi)</code>, donde <var>x</var> es un argumento.
</p>
<p>Si <var>x</var> e <var>y</var> son expresiones constantes (por ejemplo, <code>10 * %pi</code>), <code>mod</code> utiliza el mismo esquema de evaluación basado en números grandes en coma flotante (big floats) que <code>floor</code> y <code>ceiling</code>. También es posible, pero improbable, que <code>mod</code> pueda retornar un valor erróneo en tales casos.
</p>
<p>Para argumentos no numéricos <var>x</var> o <var>y</var>, <code>mod</code> aplica algunas reglas de simplificación:
</p>
<pre class="example">(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>next_prime</b><i> (<var>n</var>)</i>
<a name="IDX1280"></a>
</dt>
<dd><p>Devuelve el menor de los primos mayores que <var>n</var>.
</p>
<pre class="example">(%i1) next_prime(27);
(%o1)                       29
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>partfrac</b><i> (<var>expr</var>, <var>var</var>)</i>
<a name="IDX1281"></a>
</dt>
<dd><p>Expande la expresión <var>expr</var> en fracciones parciales respecto de la variable principal <var>var</var>. La función <code>partfrac</code> hace una descomposición completa en fracciones parciales. El algoritmo que se utiliza se basa en el hecho de que los denominadores de la expansión en fracciones parciales (los factores del denominador original) son primos relativos. Los numeradores se pueden escribir como combinaciones lineales de los denominadores.
</p>
<pre class="example">(%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                      2       2        1
(%o1)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
(%i2) ratsimp (%);
                                 x
(%o2)                 - -------------------
                         3      2
                        x  + 4 x  + 5 x + 2
(%i3) partfrac (%, x);
                      2       2        1
(%o3)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>power_mod</b><i> (<var>a</var>, <var>n</var>, <var>m</var>)</i>
<a name="IDX1282"></a>
</dt>
<dd><p>Utiliza un algoritmo modular para calcular <code>a^n mod m</code>,
siendo <var>a</var> y <var>n</var> enteros cualesquiera y <var>m</var> un entero positivo.
Si <var>n</var> es negativo, se utilizará <code>inv_mod</code> para encontrar el
inverso modular.
</p>
<pre class="example">(%i1) power_mod(3, 15, 5);
(%o1)                          2
(%i2) mod(3^15,5);
(%o2)                          2
(%i3) power_mod(2, -1, 5);
(%o3)                          3
(%i4) inv_mod(2,5);
(%o4)                          3
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>primep</b><i> (<var>n</var>)</i>
<a name="IDX1283"></a>
</dt>
<dd><p>Comprueba si el número entero <var>n</var> es o no primo, devolviendo <code>true</code>
o <code>false</code> según el caso.
</p>
<p>Cuando el resultado de <code>primep (<var>n</var>)</code> es <code>false</code>, <var>n</var> es un
número compuesto, y si es <code>true</code>, <var>n</var> es primo con alta probabilidad.
</p>
<p>Si <var>n</var> es menor que 341550071728321, se utiliza una versión 
determinística de la prueba de Miller-Rabin. En tal caso,
si <code>primep (<var>n</var>)</code> devuelve <code>true</code>, entonces <var>n</var> es un número primo.
</p>
<p>Para <var>n</var> mayor que 341550071728321 <code>primep</code> realiza 
<code>primep_number_of_tests</code> pruebas de seudo-primalidad de Miller-Rabin y una 
prueba de seudo-primalidad de Lucas. La probabilidad de que un número compuesto 
<var>n</var> pase una prueba de Miller-Rabin es menor que 1/4. Con el valor por defecto de 
<code>primep_number_of_tests</code>, que es 25, la probabilidad de que <var>n</var>
sea compuesto es menor que 10^-15.
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>primep_number_of_tests</b>
<a name="IDX1284"></a>
</dt>
<dd><p>Valor por defecto: 25
</p>
<p>Número de pruebas de Miller-Rabin a realizar por <code>primep</code>.
</p></dd></dl>

<dl>
<dt><u>Función:</u> <b>prev_prime</b><i> (<var>n</var>)</i>
<a name="IDX1285"></a>
</dt>
<dd><p>Devuelve el mayor de los primos menores que <var>n</var>.
</p>
<pre class="example">(%i1) prev_prime(27);
(%o1)                       23
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>qunit</b><i> (<var>n</var>)</i>
<a name="IDX1286"></a>
</dt>
<dd><p>Devuelve la unidad principal de <code>sqrt (<var>n</var>)</code>, siendo <var>n</var> un entero; consiste en la resolución de la ecuación de Pell  <code>a^2 - <var>n</var> b^2 = 1</code>.
</p>
<pre class="example">(%i1) qunit (17);
(%o1)                     sqrt(17) + 4
(%i2) expand (% * (sqrt(17) - 4));
(%o2)                           1
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>totient</b><i> (<var>n</var>)</i>
<a name="IDX1287"></a>
</dt>
<dd><p>Devuelve el número de enteros menores o iguales a <var>n</var> que son primos relativos con <var>n</var>.
</p></dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>zerobern</b>
<a name="IDX1288"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>zerobern</code> vale <code>false</code>, <code>bern</code> excluye los números de Bernoulli
y <code>euler</code> excluye los números de Euler que sean iguales a cero.
Véase <code>bern</code> y <code>euler</code>.
</p></dd></dl>




<dl>
<dt><u>Función:</u> <b>zeta</b><i> (<var>n</var>)</i>
<a name="IDX1289"></a>
</dt>
<dd><p>Devuelve la función zeta de Riemann. Si <var>n</var> es entero negativo,
0 o número par positivo, la función zeta de Riemann devuelve un
valor exacto; en el caso de número par positivo, la variable opcional
<code>zeta%pi</code>, además, tiene que tener el valor <code>true</code> 
(véase <code>zeta%pi</code>). 
Cuando el argumento es un número decimal o bigfloat,
entonces la función zeta de Riemann se calcula numéricamente.
Maxima devuelve una forma nominal <code>zeta (<var>n</var>)</code> para
cualesquiera otros argumentos, incluidos los racionales no enteros,
los números complejos y los enteros pares si <code>zeta%pi</code> vale
<code>false</code>.
</p>
<p><code>zeta(1)</code> no está definida, pero Maxima conce el límite 
de <code>limit(zeta(x), x, 1)</code> por ambos lados.
</p>
<p>La función zeta de Riemann se distribuye sobre las listas, matrices
y ecuaciones.
</p>
<p>Véanse también <code>bfzeta</code> y <code>zeta%pi</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) zeta([-2,-1,0,0.5,2,3,1+%i]);
                                              2
             1     1                       %pi
(%o1)  [0, - --, - -, - 1.460354508809587, ----, zeta(3), zeta(%i + 1)]
             12    2                        6 

(%i2) limit(zeta(x),x,1,plus);
(%o2)                                 inf
(%i3) limit(zeta(x),x,1,minus);
(%o3)                                minf
</pre>
</dd></dl>





<dl>
<dt><u>Variable opcional:</u> <b>zeta%pi</b>
<a name="IDX1290"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>zeta%pi</code> vale <code>true</code>, <code>zeta</code> devuelve una expresión proporcional a <code>%pi^n</code> si <code>n</code> es un número par positivo. En caso contrario, <code>zeta</code> no se evalúa y devuelve la forma nominal <code>zeta (n)</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) zeta%pi: true$
(%i2) zeta (4);
                                 4
                              %pi
(%o2)                         ----
                               90
(%i3) zeta%pi: false$
(%i4) zeta (4);
(%o4)                        zeta(4)
</pre>
</dd></dl>






<dl>
<dt><u>Función:</u> <b>zn_add_table</b><i> (<var>n</var>) </i>
<a name="IDX1291"></a>
</dt>
<dd><p>Muestra la tabla de la suma de todos los elementos de (Z/<var>n</var>Z).
</p>
<p>Véanse también <code>zn_mult_table</code> y <code>zn_power_table</code>.
</p>
</dd></dl>







<dl>
<dt><u>Función:</u> <b>zn_determinant</b><i> (<var>matrix</var>, <var>p</var>) </i>
<a name="IDX1292"></a>
</dt>
<dd><p>Utiliza el procedimiento de la descomposición LU para calcular el determinante
de <var>matrix</var> sobre (Z/<var>p</var>Z). El argumento <var>p</var> debe ser un número primo.
</p>
<p>Si el determinante es igual a cero, el procedimiento puede fallar, en cuyo caso
<code>zn_determinant</code> calcula el determinante no modular y luego reduce.
</p>
<p>Véase también <code>zn_invert_by_lu</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) m : matrix([1,3],[2,4]);
                                [ 1  3 ]
(%o1)                           [      ]
                                [ 2  4 ]
(%i2) zn_determinant(m, 5);
(%o2)                               3
(%i3) m : matrix([2,4,1],[3,1,4],[4,3,2]);
                               [ 2  4  1 ]
                               [         ]
(%o3)                          [ 3  1  4 ]
                               [         ]
                               [ 4  3  2 ]
(%i4) zn_determinant(m, 5);
(%o4)                               0
</pre>
</dd></dl>





<dl>
<dt><u>Función:</u> <b>zn_invert_by_lu</b><i> (<var>matrix</var>, <var>p</var>) </i>
<a name="IDX1293"></a>
</dt>
<dd><p>Utiliza el procedimiento de la descomposición LU para calcular la inversa
modular de <var>matrix</var> sobre (Z/<var>p</var>Z). El argumento <var>p</var> debe ser 
un número primo y <var>matrix</var> invertible. La función <code>zn_invert_by_lu</code>
devuelve <code>false</code> si <var>matrix</var> no es invertible.
</p>
<p>Véase <code>zn_determinant</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) m : matrix([1,3],[2,4]);
                                [ 1  3 ]
(%o1)                           [      ]
                                [ 2  4 ]
(%i2) zn_determinant(m, 5);
(%o2)                               3
(%i3) mi : zn_invert_by_lu(m, 5);
                                [ 3  4 ]
(%o3)                           [      ]
                                [ 1  2 ]
(%i4) matrixmap(lambda([a], mod(a, 5)), m . mi);
                                [ 1  0 ]
(%o4)                           [      ]
                                [ 0  1 ]
</pre>
</dd></dl>






<dl>
<dt><u>Función:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>) </i>
<a name="IDX1294"></a>
</dt>
<dt><u>Función:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1295"></a>
</dt>
<dd><p>Calcula el logaritmo discreto. Sea (Z/<var>n</var>Z)* un grupo cíclico,
<var>g</var> una raíz primitiva módulo <var>n</var> y <var>a</var> un miembro
de este grupo, entonces <code>zn_log (a, g, n)</code> calcula la congruencia <code>g^x = a mod n</code>.
</p>
<p>El algoritmo que se aplica necesita una factorización prima de <code>totient(n)</code>. Esta 
factorización puede requerir mucho tiempo de cálculo, por lo que en ciertos casos puede
ser aconsejable factorizar primero y luego pasar la lista de factores a <code>zn_log</code> como
cuarto argumento. La lista debe ser de la misma forma que las lista devuelta por 
<code>ifactors(totient(n))</code> utilizando la opción por defecto <code>factors_only : false</code>.
</p>
<p>El algoritmo utiliza la reducción de Pohlig-Hellman y el método Rho de Pollard
para los logaritmos discretos. El tiempo de ejecución de <code>zn_log</code> depende en
primer lugar del número de bits del mayor factor primo del totient.
</p>
<p>Véanse también <code>zn_primroot</code>, <code>zn_order</code>, <code>ifactors</code> y <code>totient</code>.
</p>
<p>Ejemplos:
</p>
<p><code>zn_log (a, g, n)</code> resuelve la congruencia <code>g^x = a mod n</code>.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) ord_7 : zn_order(7, n);
(%o3)                              10
(%i4) powers_7 : makelist(power_mod(g, x, n), x, 0, ord_7 - 1);
(%o4)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i5) zn_log(21, g, n);
(%o5)                               5
(%i6) map(lambda([x], zn_log(x, g, n)), powers_7);
(%o6)                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
<p>El cuarto argumento opcional debe ser de la misma forma que la lista devuelta por
<code>ifactors(totient(n))</code>. 
</p>
<pre class="example">(%i1) (p : 2^127-1, primep(p));
(%o1)                             true
(%i2) ifs : ifactors(p - 1)$
(%i3) g : zn_primroot(p, ifs);
(%o3)                              43
(%i4) a : power_mod(g, 1234567890, p)$
(%i5) zn_log(a, g, p, ifs);
(%o5)                          1234567890
(%i6) time(%o5);  
(%o6)                            [1.204]
(%i7) f_max : last(ifs);
(%o7)                       [77158673929, 1]
(%i8) slength( printf(false, &quot;~b&quot;, f_max[1]) );
(%o8)                              37
</pre>
</dd></dl>






<dl>
<dt><u>Función:</u> <b>zn_mult_table</b><i> (<var>n</var>) </i>
<a name="IDX1296"></a>
</dt>
<dt><u>Función:</u> <b>zn_mult_table</b><i> (<var>n</var>, all)</i>
<a name="IDX1297"></a>
</dt>
<dd><p>Sin el argumento opcional <var>all</var>, <code>zn_mult_table(n)</code> 
muestra la tabla de multiplicación de los elementos de (Z/<var>n</var>Z)*,
que son todos elementos invertibles módulo <var>n</var>.
</p>
<p>El argumento opcional <var>all</var> hace que la tabla se genere para todos los 
elementos no nulos.
</p>
<p>Véanse también <code>zn_add_table</code> y <code>zn_power_table</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) zn_mult_table(4);
                                [ 1  3 ]
(%o1)                           [      ]
                                [ 3  1 ]
(%i2) zn_mult_table(4, all);
                               [ 1  2  3 ]
                               [         ]
(%o2)                          [ 2  0  2 ]
                               [         ]
                               [ 3  2  1 ]
</pre>
</dd></dl>







<dl>
<dt><u>Función:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1298"></a>
</dt>
<dt><u>Función:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1299"></a>
</dt>
<dd><p>Devuelve el orden de <var>x</var> si es una unidad del grupo finito (Z/<var>n</var>Z)*, o devuelve <code>false</code>.
<var>x</var> una unidad módulo <var>n</var> si es coprimo con <var>n</var>.
</p>
<p>El algoritmo que se aplica necesita una factorización prima de <code>totient(n)</code>. Esta 
factorización puede requerir mucho tiempo de cálculo, por lo que en ciertos casos puede
ser aconsejable factorizar primero y luego pasar la lista de factores a <code>zn_log</code> como
tercer argumento. La lista debe ser de la misma forma que las lista devuelta por 
<code>ifactors(totient(n))</code> utilizando la opción por defecto <code>factors_only : false</code>.
</p>
<p>Véanse también <code>zn_primroot</code>, <code>ifactors</code> y <code>totient</code>.
</p>
<p>Ejemplos:
</p>
<p><code>zn_order</code> calcula el orden de la unidad <var>x</var> en (Z/<var>n</var>Z)*.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) units_22 : sublist(makelist(i,i,1,21), lambda([x], gcd(x, n) = 1));
(%o3)              [1, 3, 5, 7, 9, 13, 15, 17, 19, 21]
(%i4) (ord_7 : zn_order(7, n)) = totient(n);
(%o4)                            10 = 10
(%i5) powers_7 : makelist(power_mod(g,i,n), i,0,ord_7 - 1);
(%o5)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i6) map(lambda([x], zn_order(x, n)), powers_7);
(%o6)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i7) map(lambda([x], ord_7/gcd(x, ord_7)), makelist(i, i,0,ord_7 - 1));
(%o7)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i8) totient(totient(n));
(%o8)                               4
</pre>
<p>El tercer argumento opcional debe ser de la misma forma que la lista devuelta
por <code>ifactors(totient(n))</code>.
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) is( (ord_3 : zn_order(g, p, ifs)) = totient(p) );
(%o4)                             true
(%i5) map(lambda([x], ord_3/zn_order(x, p, ifs)), makelist(i,i,2,15));
(%o5)        [22, 1, 44, 10, 5, 2, 22, 2, 8, 2, 1, 1, 20, 1]
</pre>
</dd></dl>





<dl>
<dt><u>Función:</u> <b>zn_power_table</b><i> (<var>n</var>) </i>
<a name="IDX1300"></a>
</dt>
<dt><u>Función:</u> <b>zn_power_table</b><i> (<var>n</var>, all)</i>
<a name="IDX1301"></a>
</dt>
<dd><p>Sin el argumento opcional <var>all</var>, <code>zn_power_table(n)</code> 
muestra la tabla de potencias de los elementos de (Z/<var>n</var>Z)*,
que son todos elementos invertibles módulo <var>n</var>. El exponente 
se obtiene con un bucle desde <code>1</code> hasta <code>totient(n)</code>
y la tabla termina con una columna de unos al lado derecho.
</p>
<p>El argumento opcional <var>all</var> hace que la tabla se genere para todos los 
elementos no nulos. En este caso, el exponente se calcula con un bucle desde
<code>1</code> hasta <code>totient(n) + 1</code> y la última columna es por lo tanto 
igual a la primera.
</p>
<p>Véanse también <code>zn_add_table</code> y <code>zn_mult_table</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) zn_power_table(6);
                                [ 1  1 ]
(%o1)                           [      ]
                                [ 5  1 ]
(%i2) zn_power_table(6, all);
                               [ 1  1  1 ]
                               [         ]
                               [ 2  4  2 ]
                               [         ]
(%o2)                          [ 3  3  3 ]
                               [         ]
                               [ 4  4  4 ]
                               [         ]
                               [ 5  1  5 ]
</pre>
</dd></dl>






<dl>
<dt><u>Función:</u> <b>zn_primroot</b><i> (<var>n</var>) </i>
<a name="IDX1302"></a>
</dt>
<dt><u>Función:</u> <b>zn_primroot</b><i> (<var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1303"></a>
</dt>
<dd><p>Si el grupo multiplicativo es cíclico, <code>zn_primroot</code>
calcula la menor raíz primitiva de módulo <var>n</var>. (Z/<var>n</var>Z)* es
cíclico si <var>n</var> es igual a <code>2</code>, <code>4</code>, <code>p^k</code> o <code>2*p^k</code>,
siendo <code>p</code> primo y mayor que <code>2</code> y <code>k</code> un número natural.
Si a la variable opcional <code>zn_primroot_pretest</code>, cuyo valor por defecto es
<code>false</code>, se le da el valor <code>true</code>, entonces <code>zn_primroot</code> 
realiza una prueba previa. En cualquier caso, el cálculo está limitado por la
cota superior <code>zn_primroot_limit</code>.
</p>
<p>Si (Z/<var>n</var>Z)* no es cíclico o si no tiene raíces
primitivas menores que <code>zn_primroot_limit</code>, <code>zn_primroot</code> devuelve
<code>false</code>.
</p>
<p>El algoritmo que se aplica necesita una factorización prima de <code>totient(n)</code>. Esta 
factorización puede requerir mucho tiempo de cálculo, por lo que en ciertos casos puede
ser aconsejable factorizar primero y luego pasar la lista de factores a <code>zn_log</code> como
argumento adicional. La lista debe ser de la misma forma que las lista devuelta por 
<code>ifactors(totient(n))</code> utilizando la opción por defecto <code>factors_only : false</code>.
</p>
<p>Véanse también <code>zn_primroot_p</code>, <code>zn_order</code>, <code>ifactors</code> y <code>totient</code>.
</p>
<p>Ejemplos:
</p>
<p><code>zn_primroot</code> calcula la menor raíz primitiva de módulo <var>n</var> o
devuelve <code>false</code>.
</p>
<pre class="example">(%i1) n : 14$
(%i2) g : zn_primroot(n);
(%o2)                               3
(%i3) zn_order(g, n) = totient(n);
(%o3)                             6 = 6
(%i4) n : 15$
(%i5) zn_primroot(n);
(%o5)                             false
</pre>
<p>El argumento opcional debe ser de la misma forma que la lista devuelta
por <code>ifactors(totient(n))</code>.
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) [time(%o2), time(%o3)];
(%o4)                    [[15.556972], [0.004]]
(%i5) is(zn_order(g, p, ifs) = p - 1);
(%o5)                             true
(%i6) n : 2^142 + 216$
(%i7) ifs : ifactors(totient(n))$
(%i8) zn_primroot(n, ifs), 
      zn_primroot_limit : 200, zn_primroot_verbose : true;
`zn_primroot' stopped at zn_primroot_limit = 200
(%o8)                             false
</pre>
</dd></dl>






<dl>
<dt><u>Option variable:</u> <b>zn_primroot_limit</b>
<a name="IDX1304"></a>
</dt>
<dd><p>Valor por defecto: <code>1000</code> 
</p>
<p>Si <code>zn_primroot</code> no puede encontrar una raíz primitiva,
entonces se para en esta cota superior. Si a la variable opcional 
<code>zn_primroot_verbose</code> se le da el valor <code>true</code>, se imprimirá un
mensaje cuando <code>zn_primroot_limit</code> sea alcanzado.
</p>
</dd></dl>







<dl>
<dt><u>Función:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1305"></a>
</dt>
<dt><u>Función:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1306"></a>
</dt>
<dd><p>Comprueba si <var>x</var> es una raíz primitiva en el 
grupo multiplizativo (Z/<var>n</var>Z)*.
</p>
<p>El algoritmo que se aplica necesita una factorización prima de <code>totient(n)</code>. Esta 
factorización puede requerir mucho tiempo de cálculo, por lo que en ciertos casos puede
ser aconsejable factorizar primero y luego pasar la lista de factores a <code>zn_log</code> como
tercer argumento. La lista debe ser de la misma forma que las lista devuelta por 
<code>ifactors(totient(n))</code> utilizando la opción por defecto <code>factors_only : false</code>.
</p>
<p>Véanse también <code>zn_primroot</code>, <code>zn_order</code>, <code>ifactors</code> y <code>totient</code>.
</p>
<p>Ejemplos:
</p>
<p><code>zn_primroot_p</code> como función de predicado.
</p>
<pre class="example">(%i1) n : 14$
(%i2) units_14 : sublist(makelist(i,i,1,13), lambda([i], gcd(i, n) = 1));
(%o2)                     [1, 3, 5, 9, 11, 13]
(%i3) zn_primroot_p(13, n);
(%o3)                            false
(%i4) sublist(units_14, lambda([x], zn_primroot_p(x, n)));
(%o4)                            [3, 5]
(%i5) map(lambda([x], zn_order(x, n)), units_14);
(%o5)                      [1, 6, 6, 3, 3, 2]
</pre>
<p>El tercer argumento opcional debe ser de la misma forma que la lista
devuelta por <code>ifactors(totient(n))</code>.
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) sublist(makelist(i,i,1,50), lambda([x], zn_primroot_p(x, p, ifs)));
(%o3)      [3, 12, 13, 15, 21, 24, 26, 27, 29, 33, 38, 42, 48]
(%i4) [time(%o2), time(%o3)];
(%o4)                   [[7.748484], [0.036002]]
</pre>
</dd></dl>






<dl>
<dt><u>Option variable:</u> <b>zn_primroot_pretest</b>
<a name="IDX1307"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code> 
</p>
<p>El grupo multiplicativo (Z/<var>n</var>Z)* es cíclico si if <var>n</var>
es igual a <code>2</code>, <code>4</code>, <code>p^k</code> o <code>2*p^k</code>, siendo <code>p</code>
un número primo mayor que <code>2</code> y <code>k</code> es un número natural.
</p>
<p>La variable <code>zn_primroot_pretest</code> controla si <code>zn_primroot</code> debe
comprobar si sucede alguna de estas situaciones antes de calcular la menor
raíz primitiva. Solo se realizará esta comprobación si
<code>zn_primroot_pretest</code> toma el valor <code>true</code>.
</p>
</dd></dl>







<dl>
<dt><u>Option variable:</u> <b>zn_primroot_verbose</b>
<a name="IDX1308"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code> 
</p>
<p>Controla si <code>zn_primroot</code> imprime un mensaje cuando alcanza <code>zn_primroot_limit</code>.
</p>
</dd></dl>





<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC173" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_30.html#SEC175" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>octubre, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
