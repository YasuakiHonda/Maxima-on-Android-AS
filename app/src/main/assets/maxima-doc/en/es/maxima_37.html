<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on octubre, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.41.0: 37. Programación</title>

<meta name="description" content="Manual de Maxima 5.41.0: 37. Programación">
<meta name="keywords" content="Manual de Maxima 5.41.0: 37. Programación">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Programaci_00f3n"></a>
<a name="SEC204"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_36.html#SEC203" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC205" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 37. Programación </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC205">37.1 Lisp y Maxima</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC206">37.2 Recolector de basura</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC207">37.3 Introducción a la programación</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC208">37.4 Funciones y variables para la programación</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Lisp-y-Maxima"></a>
<a name="SEC205"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC204" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC206" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC204" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC204" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 37.1 Lisp y Maxima </h2>

<p>Maxima fue escrito en Lisp, y es muy fácil tener acceso a funciones y variables Lisp desde Maxima y viceversa. 
Los símbolos Lisp y los símblos Maxima están claramente diferenciados por medio de una convención de nombres. 
Un símblo Lisp el cual comienza con un signo pesos <code>$</code> corresponde a un símbolo Maxima sin el signo pesos. 
Un símbolo Maxima el cual comienza con un signo de cierre de interrogación <code>?</code> corresponde a un símbolo Lisp sin dicho signo.
Por ejemplo, el símbolo Maxima <code>foo</code> corresponde a el símbolo Lisp <code>$FOO</code>, 
mientras que el símbolo Maxima <code>?foo</code> corresponde a el símbolo Lisp <code>FOO</code>, 
tenga en cuenta que <code>?foo</code> esta escrito sin espacio entre <code>?</code> y <code>foo</code>; 
de otra manera se estaría invocando a <code>describe (&quot;foo&quot;)</code>. 
</p>
<p>El guión <code>-</code>, asterisco <code>*</code>, u otros carácteres especiales en símbolos Lisp deben ser escritos mediante un backslash <code>\</code> si aparecen en código Maxima. 
Por ejemplo, el identificador Lisp <code>*foo-bar*</code> se debe escribir <code>?\*foo\-bar\*</code> en Maxima. 
</p>
<p>Se puede ejecutar código Lisp desde una sesión de Maxima. 
Una línea Lisp (que contenga una o más formas) puede ser ejecutada
por medio de un comando especial <code>:lisp</code>. Por ejemplo, 
</p>
<pre class="example">(%i1) :lisp (foo $x $y)
</pre>

<p>se llama a la función Lisp <code>foo</code> con variables Maxima <code>x</code> y
<code>y</code> como argumentos. 
La instrucción <code>:lisp</code> puede aparecer en el prompt interactivo
o en un archivo que sea procesado por <code>batch</code> o <code>demo</code>, pero no
en un archivo que sea procesado por <code>load</code>, <code>batchload</code>, <code>translate_file</code> o <code>compile_file</code>. 
</p>
<p>La función <code>to_lisp()</code> abre una sesión interactiva con el interprete Lisp. 
Escribiendo <code>(to-maxima)</code> se cierra la sesión con Lisp y se retorna a Maxima. 
</p>

<p>Las funciones y variables Lisp las cuales esten para ser visibles en Maxima como funciones y variables con nombres oridinarios (sin una puntuación especial), deben tener nombres tipo Lisp que comiencen con el signo pesos 
<code>$</code>. 
</p>
<p>Maxima distingue entre letras minúsculas y mayúsculas en identificadores. 
Existen algunas reglas que gobiernan la traducción de nombres entre Lisp y Maxima. 
</p>
<ol>
<li>
Un identificador Lisp que no se encuentra encerrado en barras verticales
corresponde a un identificador Maxima en minúscula. 
Que el idenficador Lisp esté en mayúscula, minúscula o una combinación
de ambas, no afecta en nada. 
Por ejemplo, los identificadores Lisp <code>$foo</code>, <code>$FOO</code>, y <code>$Foo</code>,
todos corresponden al identificador Maxima <code>foo</code>. Esto es así
porque <code>$foo</code>, <code>$FOO</code> y  <code>$Foo</code> se convierten por defecto al
símbolo <code>$FOO</code> de Lisp.

</li><li>
Un identificador Lisp el cual se encuentre todo en mayúscula o todo en minúscula y encerrado entre barras verticales corresponde a un identicador Maxima con el caso contrario. 
Esto es, de mayúsculas cambia a minúsculas y de minúsculas cambia a mayúsculas. 
E.g., el identificador Lisp <code>|$FOO|</code> y <code>|$foo|</code>
corresponden los identificadores Maxima <code>foo</code> y <code>FOO</code>, respectivamente. 
</li><li>
Un identificador Lisp el cual esta escrito mezclando letras mayúsculas y minúsculas y se encuentra entre barras verticales corresponde a un identificador Maxima con la misma escritura. 
E.g., el identificador Lisp <code>|$Foo|</code> corresponde a el identificador Maxima <code>Foo</code>. 
</li></ol>

<p>La macro Lisp <code>#$</code> permite el uso de expresiones Maxima dentro de código Lisp. <code>#$<var>expr</var>$</code> extiende a una expresión Lisp equivalente a la expresión Maxima <var>expr</var>.   
</p>
<pre class="example">(msetq $foo #$[x, y]$)
</pre>

<p>Esto tiene el mismo efecto que: 
</p>
<pre class="example">(%i1) foo: [x, y];
</pre>

<p>La función Lisp <code>displa</code> imprime una expresión en formato Maxima.
</p>
<pre class="example">(%i1) :lisp #$[x, y, z]$ 
((MLIST SIMP) $X $Y $Z)
(%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
[x, y, z]
NIL
</pre>
<p>Las funciones definidas en Maxima no son funciones Lisp ordinarias. 
La función Lisp <code>mfuncall</code> llama a una función Maxima. 
Por ejemplo: 
</p>
<pre class="example">(%i1) foo(x,y) := x*y$
(%i2) :lisp (mfuncall '$foo 'a 'b)
((MTIMES SIMP) A B)
</pre>
<p>Algunas funciones Lisp son compartidas en el paquete Maxima, las cuales se listan a continuación: 
</p>
<p><code>complement</code>,
<code>continue</code>,
<code>//</code>,
<code>float</code>,
<code>functionp</code>,
<code>array</code>,
<code>exp</code>,
<code>listen</code>,
<code>signum</code>,
<code>atan</code>,
<code>asin</code>,
<code>acos</code>,
<code>asinh</code>,
<code>acosh</code>,
<code>atanh</code>,
<code>tanh</code>,
<code>cosh</code>,
<code>sinh</code>,
<code>tan</code>,
<code>break</code>,
y <code>gcd</code>.
</p>





<hr size="6">
<a name="Recolector-de-basura"></a>
<a name="SEC206"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC205" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC207" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC204" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC204" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 37.2 Recolector de basura </h2>

<p>La computación simbólica tiende a crear una buena cantidad de basura
(resultados temporales que ya no serán utilizados),
y un manejo efectivo de esto puede ser crucial para el término exitoso de
algunos programas. 
</p>
<p>Bajo GCL (GNU Common Lisp), en aquellos sistemas UNIX donde la llamada al sistema
mprotect está disponible (incluyendo SUN OS 4.0 y algunas variantes de BSD)
se dispone de un recolector de basura estratificado. Véase la documentación
de GCL para ALLOCATE y GBC. A nivel Lisp, ejecutando (setq si::*notify-gbc* t) 
pemitirá determinar qué áreas necesitan más espacio.
</p>
<p>En cuanto al resto de Lisps bajo los que funciona Maxima, se remite
al lector a la documentación correspondiente para controlar la
recolección de basura.
</p>





<hr size="6">
<a name="Introducci_00f3n-a-la-programaci_00f3n"></a>
<a name="SEC207"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC206" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC208" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC204" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC204" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 37.3 Introducción a la programación </h2>

<p>Maxima dispone de los bucles <code>do</code> para hacer iteraciones, así como estructuras más primitivas del estilo de <code>go</code>.
</p>

<hr size="6">
<a name="Funciones-y-variables-para-la-programaci_00f3n"></a>
<a name="SEC208"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC207" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC204" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC204" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 37.4 Funciones y variables para la programación </h2>

<dl>
<dt><u>Función:</u> <b>backtrace</b><i> ()</i>
<a name="IDX1543"></a>
</dt>
<dt><u>Función:</u> <b>backtrace</b><i> (<var>n</var>)</i>
<a name="IDX1544"></a>
</dt>
<dd><p>Devuelve la pila de llamadas, esto es, la lista de funciones que han llamado a la función actualmente activa.
</p>
<p>La llamada a <code>backtrace()</code> devuelve la pila completa de llamadas.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre>
<p>La llamada <code>backtrace (<var>n</var>)</code> devuelve las <var>n</var> funciones más recientes, incluyendo a la función actualmente activa.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>do</b>
<a name="IDX1545"></a>
</dt>
<dd><p>La sentencia <code>do</code> se utiliza para realizar iteraciones.  Debido a su generalidad la sentencia <code>do</code> se describirá en dos partes. En primer lugar se mostrará su forma más usual, análoga a la de otros lenguajes de programación (Fortran, Algol, PL/I, etc.); después se mencionarán otras formas de uso.
</p>
<p>Hay tres variantes de esta sentencia que se diferencian entre sí únicamente por las condiciones de fin de bucle. Son las siguientes:
</p>
<ul>
<li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>límite</var> do <var>cuerpo</var></code>
</li><li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condición</var> do <var>cuerpo</var></code>
</li><li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condición</var> do <var>cuerpo</var></code>
</li></ul>

<p>El <var>valor_inicial</var>, el <var>incremento</var>, el <var>límite</var> y el <var>cuerpo</var> pueden ser cualquier tipo de expresión válida de Maxima. Si el incremento es igual a la unidad (1) entonces &quot;<code>step 1</code>&quot; puede omitirse.
</p>
<p>La ejecución de la sentencia <code>do</code> se realiza asignando el valor_inicial a la variable (llamada de aquí en adelante variable-control). A continuación: (1) si la variable-control ha excedido el límite de la especificación dada por un <code>thru</code>, o si la condición impuesta por <code>unless</code> es verdadera (<code>true</code>), o si la condición dada por <code>while</code> es falsa (<code>false</code>) entonces la iteración <code>do</code> termina. (2) El cuerpo se evalúa.  (3) El incremento es sumado a la variable-control. El proceso de (1) a (3) se repite hasta que la condición de fin de iteración se satisfaga. También es posible especificar varias condiciones de terminación del bucle, en cuyo caso <code>do</code> terminará cuando se satisfaga alguna de ellas.
</p>
<p>En general la condición <code>thru</code> se satisfará cuando la variable-control sea mayor que el límite si el incremento es no negativo, o cuando la variable-control sea menor que el límite cuando el incremento es negativo. El incremento y el límite pueden ser expresiones no numéricas, tanto en cuanto esta desigualdad pueda quedar determinada. Sin embargo, a menos que el incremento sea un número negativo en el momento de comenzar el cómputo de <code>do</code>, Maxima supondrá que se evaluará a una cantidad positiva. En caso de no ser efectivamente positivo, la sentencia <code>do</code> puede dar un resultado inesperado.
</p>
<p>Nótese que el límite, el incremento y la condición de terminación se evalúan en cada iteración del bucle. Así, si alguna de expresiones necesitan de muchos cálculos y devuelven un resultado que no va a cambiar durante toda la ejecución del cuerpo, será más eficiente dar este valor a una variable antes de comenzar la sentencia <code>do</code> y utilizarla luego durante su ejecución.
</p>
<p>El valor que habitualmente devuelva la sentencia <code>do</code> será el átomo <code>done</code>. Sin embargo, la función <code>return</code> puede usarse dentro del cuerpo para salir de <code>do</code> de forma prematura retornando un valor determinado.
Nótese no obstante que un <code>return</code> dentro de un <code>do</code> que está dentro de un bloque (<code>block</code>) provocará una salida de <code>do</code> pero no de <code>block</code>. Repárese también en que la función <code>go</code> no puede usarse para salir de <code>do</code> e ir a algún lugar de <code>block</code>.
</p>
<p>La variable-control es siempre local respecto de <code>do</code>, por lo que se puede utilizar cualquier nombre de variable sin afectar el valor de cualquier otra variable externa a <code>do</code> y que tenga el mismo nombre. La variable-control no tendrá asignado ningún valor una vez se haya concluido el <code>do</code>.
</p>
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre>
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre>

<p>Nótese que la condición <code>while i &lt;= 10</code> es equivalente a <code>unless i &gt; 10</code> y a <code>thru 10</code>.
</p>
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre>
<p>lo que da ocho términos del desarrollo de Taylor de la función <code>e^sin(x)</code>.
</p>
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre>
<p>Este ejemplo calcula la raíz cuadrada negativa de 10 haciendo 10 iteraciones del método de Newton-Raphson. De no haberse alcanzado el criterio de convergencia el valor devuelto hubiese sido <code>done</code>.
</p>
<p>En lugar de añadir siempre una cantidad a la variable-control a veces se puede querer que cambie en cada iteración siguiendo algún otro criterio. En tal caso se puede hacer uso de <code>next <var>expresión</var></code> en lugar de <code>step <var>incremento</var></code>. Esto hará que a la variable-control se le asigne el resultado de evaluar la expresión en cada iteración del bucle.
</p>
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre>
<p>En ocasiones puede interesar realizar una iteración en la que la variable-control no se utilice nunca. Se podrá entonces dar únicamente las condiciones de terminación del bucle omitiendo la inicialización y actualizando la información, tal como se hace en el siguiente ejemplo para calcular la raíz cuadrada de 5 utilizando un valor inicial alejado de la solución.
</p>
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre>
<p>Si así se quiere, incluso es posible omitir las condiciones de terminación completamente y escribir únicamente <code>do <var>body</var></code>, lo que provocará entrar en un bucle infinito. En tal caso, debería usarse la función <code>return</code> a fin de terminar con la ejecución de <code>do</code>.
</p>
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre>
<p>(En este ejemplo, cuando se ejecuta <code>return</code> obliga a que sea <code>x</code> el valor devuelto por <code>do</code>. Al salirse del bloque, <code>x</code> es también el valor que devuelve <code>block</code> por ser <code>do</code> la última sentencia del bloque.)
</p>
<p>Hay todavía otra forma de <code>do</code> en Maxima. Su sintaxis es:
</p>
<pre class="example">for <var>variable</var> in <var>lista</var> <var>test_de_parada</var> do <var>cuerpo</var>
</pre>
<p>Los elementos de <var>list</var> son cualesquiera expresiones que se irán asignando sucesivamente a la variable en cada repetición del cuerpo. El test de parada <var>end_tests</var> (que es opcional) puede usarse para terminar la ejecución de <code>do</code>; de otro modo las iteraciones se pararán cuando la lista se haya agotado o cuando se ejecute un <code>return</code> dentro del cuerpo.  (De hecho, la lista puede ser cualquier expresión no atómica, de la cual se irán extrayendo de forma sucesiva sus diferentes partes.)
</p>
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>errcatch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1546"></a>
</dt>
<dd><p>Evalúa las expresiones <var>expr_1</var>, ..., <var>expr_n</var> una a una y devuelve <code>[<var>expr_n</var>]</code> (una lista) en caso de que no ocurra ningún error. En caso de aparecer algún error durante el cálculo de alguno de los argumentos, <code>errcatch</code> evita que el error se propague y devuelve la lista vacía <code>[]</code> sin evaluar más argumentos.
</p>
<p>La función <code>errcatch</code> es útil en ficheros <code>batch</code> donde se sospeche que pueda aparecer algún error, el cual provocaría la terminación de la ejecución del <code>batch</code> de no ser previamente detectado.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>error</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1547"></a>
</dt>
<dt><u>Variable del sistema:</u> <b>error</b>
<a name="IDX1548"></a>
</dt>
<dd><p>Calcula y devuelve <var>expr_1</var>, ..., <var>expr_n</var>, enviando posteriormente una seãl de error a Maxima o al <code>errcatch</code> más cercano. 
</p>
<p>A la variable <code>error</code> se le asigna una lista con la descripción del error. El primer elemento de <code>error</code> es una cadena de formato, la cual une todas las cadenas de los argumentos <var>expr_1</var>, ..., <var>expr_n</var>, siendo los demás elementos de la lista los valores de los argumentos que no son cadenas.
</p>
<p>La llamada a <code>errormsg()</code> formatea e imprime <code>error</code>. Se reimprime así el mensaje de error más reciente.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>error_size</b>
<a name="IDX1549"></a>
</dt>
<dd><p>Valor por defecto: 10
</p>
<p>La variable <code>error_size</code> modifica los mensajes de error de acuerdo con el tamaño de las expresiones que aparecen en él. Si el tamaño de una expresión (tal como lo determina la función Lisp <code>ERROR-SIZE</code>)
es mayor que <code>error_size</code>, la expresión se reemplaza en el mensaje por un símbolo, asignándole a éste una expresión. Los símbolos se toman de la lista <code>error_syms</code>.
</p>
<p>En caso contrario, si la expresión es menor que <code>error_size</code>, la expresión se muestra en el propio mensaje.
</p>
<p>Véanse también <code>error</code> y <code>error_syms</code>.
</p>
<p>Ejemplo:
</p>
<p>El tamaño de <code>U</code>, tal como lo determina <code>ERROR-SIZE</code>, es 24.
</p>
<pre class="example">(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error (&quot;Example expression is&quot;, U);

Example expression is errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error (&quot;Example expression is&quot;, U);

                         E
                        D
                       C   + B + A
Example expression is --------------
                      cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>error_syms</b>
<a name="IDX1550"></a>
</dt>
<dd><p>Valor por defecto: <code>[errexp1, errexp2, errexp3]</code>
</p>
<p>En los mensajes de error, las expresiones mayores que <code>error_size</code> son reemplazadas por símbolos a los cuales se les asignas estas expresiones.  Los símbolos se toman de la lista <code>error_syms</code>. La primera expresión que resulte ser demasiado larga se reemplaza por <code>error_syms[1]</code>, la segunda por <code>error_syms[2]</code> y así sucesivamente.
</p>
<p>Si hay más expresiones largas que elementos en <code>error_syms</code>, los símbolos se construyen automáticamente, siendo el <var>n</var>-ésimo símbolo equivalente a <code>concat ('errexp, <var>n</var>)</code>.
</p>
<p>Véanse también <code>error</code> y <code>error_size</code>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>errormsg</b><i> ()</i>
<a name="IDX1551"></a>
</dt>
<dd><p>Reimprime el mensaje de error más reciente. La variable <code>error</code> guarda el mensaje y <code>errormsg</code> lo formatea e imprime.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>errormsg</b>
<a name="IDX1552"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>errormsg</code> vale <code>false</code> se suprimen los contenidos
de los mensajes de error.
</p>
<p>La variable <code>errormsg</code> no se puede asignar a un valor local dentro
de un bloque. El valor global de <code>errormsg</code> está siempre presente.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) errormsg;
(%o1)                                true
(%i2) sin(a,b);
Wrong number of arguments to sin
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg:false;
(%o3)                                false
(%i4) sin(a,b);

 -- an error. To debug this try: debugmode(true);
</pre>
<p>La variable <code>errormsg</code> no se puede asignar a un valor local dentro
de un bloque.
</p>
<pre class="example">(%i1) f(bool):=block([errormsg:bool], 
                     print (&quot;value of errormsg is&quot;,errormsg))$
(%i2) errormsg:true;
(%o2)                                true
(%i3) f(false);
value of errormsg is true 
(%o3)                                true
(%i4) errormsg:false;
(%o4)                                false
(%i5) f(true);
value of errormsg is false 
(%o5)                                false
</pre></dd></dl>



<dl>
<dt><u>Operador especial:</u> <b>for</b>
<a name="IDX1553"></a>
</dt>
<dd><p>Utilizado en las iteraciones. Véase <code>do</code> para una descripción de las técnicas de iteración en Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>go</b><i> (<var>etiqueta</var>)</i>
<a name="IDX1554"></a>
</dt>
<dd><p>Se utiliza dentro de un bloque (<code>block</code>) para transferir el control a la sentencia del bloque que esté etiquetada con el argumento de <code>go</code>. Una sentencia queda etiquetada cuando está precedida por un argumento de tipo átomo como cualquier otra sentencia de <code>block</code>.  Por ejemplo:
</p>
<pre class="example">block ([x], x:1, tururu, x+1, ..., go(tururu), ...)
</pre>
<p>El argumento de <code>go</code> debe ser el nombre de una etiqueta que aparezca en el mismo bloque (<code>block</code>). No se puede utilizar <code>go</code> para transferir el control a un bloque que no sea aquel que contenga la sentencia <code>go</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>if</b>
<a name="IDX1555"></a>
</dt>
<dd><p>Evaluación condicionada. Se reconocen varias formas de expresiones <code>if</code>.
</p>
<p>La expresión <code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
devuelve <var>expr_1</var> si <var>cond_1</var> vale <code>true</code>,
en caso contrario la respuesta es <code>expr_0</code>.
</p>
<p>La expresión <code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var>
then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
devuelve <var>expr_k</var> si <var>cond_k</var> vale <code>true</code> y todas las
condiciones anteriores toman el valor <code>false</code>.
Si ninguna de las condiciones vale <code>true</code>, la respuesta es <code>expr_0</code>.
</p>
<p>La falta de un <code>else</code> final se interpreta como un <code>else false</code>;
esto es, la expresión <code>if <var>cond_1</var> then <var>expr_1</var></code>
equivale a <code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
y <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
equivale a su vez a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>Las alternativas <var>expr_0</var>, ..., <var>expr_n</var> pueden ser expresiones
válidas de Maxima, incluidas expresiones <code>if</code> anidadas.
Las alternativas ni se simplifican ni se evalúan, a menos que su
condición asociada valga <code>true</code>.
</p>
<p>Las condiciones <var>cond_1</var>, ..., <var>cond_n</var> deben ser expresiones 
capaces de dar como resultado <code>true</code> o <code>false</code> al ser
evaluadas. Si en un momento dado una condición no da como resultado 
un valor de verdad (<code>true</code> o <code>false</code>), el comportamiento de <code>if</code> se controla
con la variable global <code>prederror</code>. Si <code>prederror</code> vale <code>true</code>,
se considera un error que la condición evaluada no dé como resultado
un valor de verdad; en caso contrario, las condiciones que no
den como resultado un valor de verdad se aceptan, dándose el
resultado como una expresión condicional.
</p>
<p>Las condiciones pueden contener operadores lógicos y relacionales, 
así como otros elementos, tal como se indica a continuación:
</p>

<pre class="example">Operación               Símbolo     Tipo
 
menor que               &lt;           operador relacional infijo
menor o igual que       &lt;=          operador relacional infijo
igualdad (sintáctica)   =           operador relacional infijo
negación de =           #           operador relacional infijo
igualdad (por valor)    equal       operador relacional infijo
negación de equal       notequal    operador relacional infijo
mayor o igual que       &gt;=          operador relacional infijo
mayor que               &gt;           operador relacional infijo
y                       and         operador lógico infijo
o                       or          operador lógico infijo
no                      not         operador lógico prefijo
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>map</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1556"></a>
</dt>
<dd><p>Devuelve una expresión cuyo operador principal es el mismo 
que aparece en las expresiones <var>expr_1</var>, ..., <var>expr_n</var> 
pero cuyas subpartes son los resultados de aplicar <var>f</var> 
a cada una de las subpartes de las expresiones;  <var>f</var> puede ser 
tanto el nombre de una función de <em>n</em> argumentos como
una expresión <code>lambda</code> de <em>n</em> argumentos.
</p>
<p>Uno de los usos que tiene <code>map</code> es la de aplicar (o mapear)
una función (por ejemplo, <code>partfrac</code>) sobre cada término
de una expresión extensa en la que normalmente no se 
podría utilizar la función debido a insuficiencias 
en el espacio de almacenamiento durante el curso de un cálculo.
</p>
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]
</pre>
<p>Véase también <code>maperror</code> .
</p></dd></dl>

<dl>
<dt><u>Función:</u> <b>mapatom</b><i> (<var>expr</var>)</i>
<a name="IDX1557"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo <var>expr</var> es tratado por las rutinas de mapeo como un átomo.
</p></dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>maperror</b>
<a name="IDX1558"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>maperror</code> toma el valor <code>false</code>, 
hace que todas las funciones de mapeo, como por ejemplo
</p>
<pre class="example">map (f, <var>expr_1</var>, <var>expr_2</var>, ...)
</pre>
<p>(1) paren cuando hayan terminado de procesar la <var>expr_i</var> más corta,
a menos que todas ellas sean del mismo tamaño y (2) apliquen  <code>f</code>
a <code>[expr_1, expr_2, ...]</code> si es el caso que las <code>expr_i</code>
no son todas del mismo tipo de objeto.
</p>
<p>Cuando <code>maperror</code> toma el valor <code>true</code> entonces se emite un mensaje de error cuando se presenta cualquiera de los dos casos anteriores.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>mapprint</b>
<a name="IDX1559"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>mapprint</code> vale <code>true</code>, se producirán ciertos mensajes
por parte de las funciones <code>map</code>, <code>mapl</code> y <code>fullmap</code>
en determinadas situaciones, como cuando <code>map</code> hace uso de
<code>apply</code>.
</p>
<p>Si <code>mapprint</code> vale <code>false</code>, no se emitirán tales mensajes.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>maplist</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1560"></a>
</dt>
<dd><p>Devuelve una lista con las aplicaciones de <var>f</var> a las partes de las expresiones <var>expr_1</var>, ..., <var>expr_n</var>; <var>f</var> es el nombre de una función ou una expresión lambda.
</p>
<p>La función <code>maplist</code> difiere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>, la cual devuelve una expresión con el mismo operador principal que tenga <var>expr_i</var>, excepto en simplificaciones y en el caso en el que <code>map</code> hace un <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>prederror</b>
<a name="IDX1561"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>prederror</code> toma el valor <code>true</code>, se emite un mensaje de error siempre que el predicado de una sentencia  <code>if</code> o de una función <code>is</code> no se pueda evaluar ni a verdadero (<code>true</code>) ni  a falso (<code>false</code>).
</p>
<p>Si toma el valor <code>false</code>, se devuelve bajo las mismas circunstancias anteriores el valor <code>unknown</code>. El modo <code>prederror: false</code> no está soportado en el código traducido; sin embargo, <code>maybe</code> está soportado en código traducido.
</p>
<p>Véanse también <code>is</code> y <code>maybe</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>return</b><i> (valor)</i>
<a name="IDX1562"></a>
</dt>
<dd><p>Puede utilizarse para salir de un bloque, devolviendo su argumento.
Véase <code>block</code> para más información.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>)</i>
<a name="IDX1563"></a>
</dt>
<dt><u>Función:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>, bottomup)</i>
<a name="IDX1564"></a>
</dt>
<dd><p>Aplica recursivamente <var>f</var> sobre <var>expr</var>, de arriba hacia abajo. Esto es más útil cuando se busca una factorización completa, por ejemplo:
</p>
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre>
<p>Nótese que cómo <code>scanmap</code> aplica la función dada <code>factor</code> a las subexpresiones que forman a <var>expr</var>; si se presenta otra forma de <var>expr</var> a <code>scanmap</code> entonces el resultado puede ser diferente. Así, <code>%o2</code> no se restaura cuando <code>scanmap</code> se aplica a la forma expandida de exp:
</p>
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre>
<p>Aquí hay otro ejemplo de la forma en que <code>scanmap</code> aplica recursivamente una función dada a todas las subexpresiones, incluyendo exponentes:
</p>
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre>
<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de abajo hacia arriba. Por ejemplo, para <code>f</code> no definida,
</p>
<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre>
<p>En este caso se obtiene la misma respuesta por cualquiera de los dos métodos.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>throw</b><i> (<var>expr</var>)</i>
<a name="IDX1565"></a>
</dt>
<dd><p>Evalúa <var>expr</var> y devuelve el valor del <code>catch</code> más reciente. La función <code>throw</code> se utiliza junto con <code>catch</code> como un mecanismo de retorno no local.
</p>
</dd></dl>


<dl>
<dt><u>Operador especial:</u> <b>while</b>
<a name="IDX1566"></a>
</dt>
<dt><u>Operador especial:</u> <b>unless</b>
<a name="IDX1567"></a>
</dt>
<dd><p>Véase <code>do</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>outermap</b><i> (<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1568"></a>
</dt>
<dd><p>Aplica la función <var>f</var> a cada uno de los elementos del producto vectorial <var>a_1</var> por <var>a_2</var> ... por <var>a_n</var>.
</p>
<p>El argumento <var>f</var> debe ser el nombre de una función de <em>n</em> argumentos,
o una expresión lambda de <em>n</em> argumentos.
Cada uno de los argumentos <var>a_k</var> puede ser una lista, una lista anidada, 
una matriz o cualquier otro tipo de expresión.
</p>
<p>El valor devuelto por <code>outermap</code> es una estructura anidada. Si <var>x</var> es la
respuesta dada por <code>outermap</code>, entonces tiene la misma estructura que la primera lista,
lista anidada o matriz, <code><var>x</var>[i_1]...[i_m]</code> tiene la misma estructura que la
segunda lista, lista anidada o matriz, <code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tiene 
la misma estructura que la tercera lista, lista anidada o matriz, y así
sucesivamente, siendo <var>m</var>, <var>n</var>, ... los números índice
necesarios para acceder a los elementos de cada argumento: uno para las listas,
dos para las matrices y uno o más para las listas anidadas. 
Aquellos argumentos que no sean listas ni matrices no tienen efecto alguno sobre
la estructura del valor retornado.
</p>
<p>Nótese que el efecto producido por <code>outermap</code> es diferente del que
se obtiene al aplicar <var>f</var> a cada uno de los elementos del producto
devuelto por <code>cartesian_product</code>. La función <code>outermap</code>
mantiene la estructura de los argumentos en la respuesta, miemtras que
<code>cartesian_product</code> no lo hace.
</p>
<p>La función <code>outermap</code> evalúa sus argumentos.
</p>
<p>Véanse también <code>map</code>, <code>maplist</code> y <code>apply</code>.
</p>
<p>Ejemplos:
</p>
<p>Ejemplos elementales de uso de <code>outermap</code>.
Con el fin de mostrar con mayor claridad las combinaciones del argumento,
se mantiene sin definir <code>F</code>.
</p>

<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre>
<p>El siguiente ejemplo permite hacer un análisis más profundo del valor
retornado por <code>outermap</code>.
Los tres primeros argumentos son una matriz, una lista y otra matriz, en este
orden. El valor devuelto es una matriz, cuyos elementos son listas y
cada elemento de cada una de estas listas es a su vez una matriz.
</p>
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                   arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre>
<p>La función <code>outermap</code> mantiene la estructura de los argumentos en su respuesta,
mientras que <code>cartesian_product</code> no lo hace.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre>
</dd></dl>




<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC204" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC209" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>octubre, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
