<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima 5.41.0: 69. stringproc</title>

<meta name="description" content="Manual do Maxima 5.41.0: 69. stringproc">
<meta name="keywords" content="Manual do Maxima 5.41.0: 69. stringproc">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="stringproc"></a>
<a name="SEC256"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_68.html#SEC255" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC257" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_68.html#SEC254" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 69. stringproc </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC257">69.1 Introdução a manipulação de sequências de caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC258">69.2 Definições para entrada e saída</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC259">69.3 Definições para caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC260">69.4 Definições para sequências de caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-manipula_00e7_00e3o-de-sequ_00eancias-de-caracteres"></a>
<a name="SEC257"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC256" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC258" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC256" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC256" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 69.1 Introdução a manipulação de sequências de caracteres </h2>

<p>O ficheiro <code>stringproc.lisp</code> amplia a compatibilidade do Maxima de trabalhar com sequências de caracteres 
e adiciona algumas funções úteis a entrada e saída de dados.
</p>
<p>Para esclarecimentos e erros por favor mande um e-mail para van.nek at arcor.de .
</p>
<p>Para disponibilizar <code>stringproc.lisp</code> para uso digite <code>load(&quot;stringproc&quot;);</code>.
</p>
<p>No Maxima uma sequência de caracteres é facilmente contruída digitando &quot;texto&quot; (qualquer texto desejado entre aspas duplas).
Note que sequências de caracteres do Maxima não são sequências de caracteres do Lisp e vice-versa.
Testes podem ser concluídos com <code>stringp</code> e <code>lstringp</code>.
Se por alguma razão tiver um valor,
que é uma sequência de caracteres do Lisp, talvez quando estiver usando a função <code>sconcat</code> do Maxima, poderá converter via <code>sunlisp</code>. 
</p>

<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) m: &quot;text&quot;;
(%o2)                         text
(%i3) [stringp(m),lstringp(m)];
(%o3)                     [true, false]
(%i4) l: sconcat(&quot;text&quot;);
(%o4)                         text
(%i5) [stringp(l),lstringp(l)];
(%o5)                     [false, true]
(%i6) stringp( sunlisp(l) );
(%o6)                         true
</pre>
<p>Todas as funções em <code>stringproc.lisp</code>, que retornarem sequências de caracteres, retornam sequências de caracteres do Maxima.
</p>
<p>Caracteres são introduzidos como sequências de caracteres do Maxima de comprimento 1.
Com certeza, esses caracteres não são caracteres do Lisp.
Testes podem ser realizados com <code>charp</code> ( <code>lcharp</code> e conversões do Lisp para o Maxima com <code>cunlisp</code>).
</p>

<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) c: &quot;e&quot;;
(%o2)                           e
(%i3) [charp(c),lcharp(c)];
(%o3)                     [true, false]
(%i4) supcase(c);
(%o4)                           E
(%i5) charp(%);
(%o5)                         true
</pre>
<p>Novamente, todas as funções em <code>stringproc.lisp</code>, que
retornam caracteres, retornam caracteres do Maxima.  devido a esse
facto, que os caracteres introduzidos são sequências de caracteres
de comprimento 1, pode usar muitas das funções de sequência de
caracteres também para caracteres. Como visto, <code>supcase</code> é um
exemplo.
</p>
<p>É importante saber,
que o primeiro caractere em uma sequência de caracteres do Maxima éstá na posição 1.
Isso é designado devido ao facto de o primeiro elemento em uma lista do Maxima está na posição 1 também.
Veja definições de <code>charat</code> e de <code>charlist</code> para obter exemplos.
</p>
<p>Em aplicações fnções de sequência de caractere são
muitas vezes usadas quando estamos trabalhando com ficheiros.  Poderá
encontrará algumas funções úteis de fluxo e de impressão em
<code>stringproc.lisp</code>.  O seguinte exemplo mostra algumas das
funções aqui introduzidas no trabalho.
</p>
<p>Exemplo: 
</p>
<p><code>openw</code> retorna um fluxo de saída para um ficheiro,
<code>printf</code> então permite escrita formatada para esse ficheiro. Veja
<code>printf</code> para detalhes.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: openw(&quot;E:/file.txt&quot;);
(%o2)                    #&lt;output stream E:/file.txt&gt;
(%i3) for n:0 thru 10 do printf( s, &quot;~d &quot;, fib(n) );
(%o3)                                done
(%i4) printf( s, &quot;~%~d ~f ~a ~a ~f ~e ~a~%&quot;, 
              42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
(%o4)                                false
(%i5) close(s);
(%o5)                                true
</pre>
<p>Após fechar o fluxo pode abrí-lo novamente, dessa vez
com direção de entrada.  <code>readline</code> retorna a linha completa
como uma sequência de caracteres. O pacote <code>stringproc</code> agora
oferece muitas funções para manipulação de sequências de
caracteres. A troca de indicações/fichas pode ser realizada por
<code>split</code> ou por <code>tokens</code>.
</p>
<pre class="example">(%i6) s: openr(&quot;E:/file.txt&quot;);
(%o6)                     #&lt;input stream E:/file.txt&gt;
(%i7) readline(s);
(%o7)                     0 1 1 2 3 5 8 13 21 34 55 
(%i8) line: readline(s);
(%o8)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
(%i9) list: tokens(line);
(%o9)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
(%i10) map( parsetoken, list );
(%o10)           [42, 1.234, false, false, 0.01, 0.01, false]
</pre>
<p><code>parsetoken</code> somente analiza números inteiros e em ponto flutuante. A análise de símbolos ou grandes números em ponto flutuante 
precisa de <code>parse_string</code>, que pode ser disponibilizada para uso através de <code>eval_string.lisp</code>.
</p>
<pre class="example">(%i11) load(&quot;eval_string&quot;)$
(%i12) map( parse_string, list );
(%o12)           [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
(%i13) float(%);
(%o13) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01, 0.01, 0.01]
(%i14) readline(s);
(%o14)                               false
(%i15) close(s)$
</pre>
<p><code>readline</code> retorna <code>false</code> quado o fim de ficheiro acontecer.
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-entrada-e-sa_00edda"></a>
<a name="SEC258"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC257" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC259" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC256" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC256" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 69.2 Definições para entrada e saída </h2>

<p>Exemplo: 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: openw(&quot;E:/file.txt&quot;);
(%o2)                     #&lt;output stream E:/file.txt&gt;
(%i3) control: 
&quot;~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%&quot;$
(%i4) printf( s,control, 'true,[1,2,3],42 )$
(%o4)                                false
(%i5) close(s);
(%o5)                                true
(%i6) s: openr(&quot;E:/file.txt&quot;);
(%o6)                     #&lt;input stream E:/file.txt&gt;
(%i7) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i8) close(s)$
</pre>

<dl>
<dt><u>Função:</u> <b>close</b><i> (<var>fluxo</var>) </i>
<a name="IDX1921"></a>
</dt>
<dd><p>Fecha  <var>fluxo</var> e retorna <code>true</code> se <var>fluxo</var> tiver sido aberto anteriormente. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>flength</b><i> (<var>fluxo</var>)</i>
<a name="IDX1922"></a>
</dt>
<dd><p>Retorna o número de elementos em <var>fluxo</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>fposition</b><i> (<var>fluxo</var>)</i>
<a name="IDX1923"></a>
</dt>
<dt><u>Função:</u> <b>fposition</b><i> (<var>fluxo</var>, <var>pos</var>)</i>
<a name="IDX1924"></a>
</dt>
<dd><p>Retorna a posição corrente em <var>fluxo</var>, se <var>pos</var> não está sendo usada.
Se <var>pos</var> estiver sendo usada,
<code>fposition</code> escolhe a posição em <var>fluxo</var>.
<var>pos</var> tem que ser um número positivo,
o primeiro elemento em <var>fluxo</var> está na posição 1.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>freshline</b><i> () </i>
<a name="IDX1925"></a>
</dt>
<dt><u>Função:</u> <b>freshline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1926"></a>
</dt>
<dd><p>escreve uma nova linha (em <var>fluxo</var>),
se a posição actual não for um início de linha.
Veja também <code>newline</code>.
</p></dd></dl>

<dl>
<dt><u>Função:</u> <b>newline</b><i> () </i>
<a name="IDX1927"></a>
</dt>
<dt><u>Função:</u> <b>newline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1928"></a>
</dt>
<dd><p>Escreve uma nova linha (para <var>fluxo</var>).
Veja <code>sprint</code> para um exemplo de uso de <code>newline()</code>.
Note que existem alguns casos, onde <code>newline()</code>não trabalha como esperado. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>opena</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1929"></a>
</dt>
<dd><p>Retorna um fluxo de saída para <var>ficheiro</var>.
Se um ficheiro já existente tiver sido aberto, <code>opena</code> anexa os elementos ao final do ficheiro.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>openr</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1930"></a>
</dt>
<dd><p>Retorna um fluxo para <var>ficheiro</var>.
Se <var>ficheiro</var> não existir, ele será criado.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>openw</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1931"></a>
</dt>
<dd><p>Retorna um fluxo de saída para <var>ficheiro</var>.
Se <var>ficheiro</var> não existir, será criado.
Se um ficheiro já existente for aberto, <code>openw</code> modifica destrutivametne o <var>ficheiro</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>printf</b><i> (<var>dest</var>, <var>seq_caracte</var>)</i>
<a name="IDX1932"></a>
</dt>
<dt><u>Função:</u> <b>printf</b><i> (<var>dest</var>, <var>seq_caracte</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1933"></a>
</dt>
<dd><p>Torna a função FORMAT do Lisp Comum disponível no Maxima. 
(Retirado de gcl.info: &quot;format produces formatted output by outputting the caracteres of 
control-string string and observing that a tilde introduces a directive.
The caractere after the tilde,
possibly preceded by prefix parameters and modifiers,
specifies what kind of formatting is desired.
Most directives use one or more elements of args to create their output.&quot;)
</p>
<p>A seguinte descrição e oa exemplos podem fornecer uma idéia de uso de <code>printf</code>.
Veja um referência de Lisp para maiores informações.
</p>
<pre class="example">   ~%       nova linha
   ~&amp;       novíssima line
   ~t       tabulação
   ~$       monetário
   ~d       inteiro decimal
   ~b       inteiro binário
   ~o       inteiro octal
   ~x       inteiro hexadecimal
   ~br      inteiro de base b
   ~r       soletra um inteiro
   ~p       plural
   ~f       ponto flutuante
   ~e       notação científica
   ~g       ~f ou ~e, dependendo  da magnitude
   ~a       como mostrado pela função print do Maxima
   ~s       sequências de caracteres entre &quot;aspas duplas&quot;
   ~~       ~
   ~&lt;       justificação de texto, ~&gt; terminador de justificação de texto
   ~(       conversão de caixa alta/baixa, ~) terminador de conversão de caixa
   ~[       selecção, ~] terminador de selecção 
   ~{       iteração, ~} terminador de iteração
</pre>
<p>Por favor note que não existe especificador de formato para grandes
números em ponto flutuante. Todavia grandes números em ponto
flutuante podem simplesmente serem mostrados por meio da directiva
<code>~a</code>.  <code>~s</code> mostra as sequências de caracteres entre &quot;aspas
duplas&quot;; pode evitar isso usando <code>~a</code>.  Note que a directiva de
selecção <code>~[</code> é indexada em zero.  Também note que existem
algumas directivas, que não trabalham no Maxima.  Por exemplo,
<code>~:[</code> falha.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) printf( false, &quot;~a ~a ~4f ~a ~@r&quot;, 
              &quot;String&quot;,sym,bound,sqrt(12),144), bound = 1.234;
(%o2)                 String sym 1.23 2*sqrt(3) CXLIV
(%i3) printf( false,&quot;~{~a ~}&quot;,[&quot;one&quot;,2,&quot;THREE&quot;] );
(%o3)                          one 2 THREE 
(%i4) printf( true,&quot;~{~{~9,1f ~}~%~}&quot;,mat ),
              mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i5) control: &quot;~:(~r~) bird~p ~[is~;are~] singing.&quot;$
(%i6) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
(%o6)                    Two birds are singing.
</pre>
<p>Se <var>dest</var> for um fluxo ou <code>true</code>, então <code>printf</code> retorna <code>false</code>.
De outra forma, <code>printf</code> retorna uma sequência de caracteres contendo a saída.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>readline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1934"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres contendo os caracteres a partir da posição corrente em <var>fluxo</var> até o fim de linha ou <var>false</var> se o fim de linha do ficheiro for encontrado.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sprint</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1935"></a>
</dt>
<dd><p>Avalia e mostra seus argumentos um após o outro `sobre uma linha'
iniciando na posição mais à esquerda.  Os números são
mostrados com o '-' à direita do número, e isso desconsidera o
comprimento da linha. <code>newline()</code>, que pode ser chamada a partir de
<code>stringproc.lisp</code> pode ser útil, se desejar colocar uma parada de
linha intermédia.
</p>
<pre class="example">(%i1) for n:0 thru 22 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 
(%i2) load(&quot;stringproc&quot;)$
(%i3) for n:0 thru 22 do ( 
         sprint(fib(n)), if mod(n,10)=9 then newline() )$
0 1 1 2 3 5 8 13 21 34 
55 89 144 233 377 610 987 1597 2584 4181 
6765 10946 17711 
</pre>
</dd></dl>

<hr size="6">
<a name="Defini_00e7_00f5es-para-caracteres"></a>
<a name="SEC259"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC258" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC260" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC256" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC256" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 69.3 Definições para caracteres </h2>

<dl>
<dt><u>Função:</u> <b>alphacharp</b><i> (<var>caractere</var>)    </i>
<a name="IDX1936"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere alfabético. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>alphanumericp</b><i> (<var>caractere</var>) </i>
<a name="IDX1937"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere alfabético ou um dígito. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ascii</b><i> (<var>int</var>) </i>
<a name="IDX1938"></a>
</dt>
<dd><p>Retorna o caractere correspondente ao código numérico ASCII <var>int</var>.
( -1 &lt; int &lt; 256 )
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) for n from 0 thru 255 do ( 
tmp: ascii(n), if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
a b c d e f g h i j k l m n o p q r s t u v w x y z
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cequal</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)          </i>
<a name="IDX1939"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere_1</var> e <var>caractere_2</var> forem os mesmos. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cequalignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)    </i>
<a name="IDX1940"></a>
</dt>
<dd><p>como <code>cequal</code> mas ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cgreaterp</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)       </i>
<a name="IDX1941"></a>
</dt>
<dd><p>Retorna <code>true</code> se o código numérico ASCII do <var>caractere_1</var> for maior que o código numérico ASCII do <var>caractere_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cgreaterpignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1942"></a>
</dt>
<dd><p>Como <code>cgreaterp</code> mas ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>charp</b><i> (<var>obj</var>) </i>
<a name="IDX1943"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for um caractere do Maxima.
Veja na seção &quot;Introdução a manipulação de sequências de caracteres&quot; para ter um exemplo.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cint</b><i> (<var>caractere</var>) </i>
<a name="IDX1944"></a>
</dt>
<dd><p>Retorna o código numéico ASCII de <var>caractere</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>clessp</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1945"></a>
</dt>
<dd><p>Retorna <code>true</code> se o código numérico ASCII de <var>caractere_1</var> for menor que o código numérico ASCII de <var>caractere_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>clesspignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1946"></a>
</dt>
<dd><p>Como em <code>clessp</code> ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>constituent</b><i> (<var>caractere</var>)   </i>
<a name="IDX1947"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for caractere  gráfico e não o caractere de espaço em branco.
Um caractere gráfico é um caractere que se pode ver, adicionado o caractere de espaço em branco.
(<code>constituent</code> foi definida por Paul Graham, em ANSI Common Lisp, 1996, página 67.)
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) for n from 0 thru 255 do ( 
tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
! &quot; #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>cunlisp</b><i> (<var>lisp_char</var>) </i>
<a name="IDX1948"></a>
</dt>
<dd><p>Converte um caractere do Lisp em um caractere do Maxima.  (É
possível que não chegue a precisar dessa função.)
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>digitcharp</b><i> (<var>caractere</var>)    </i>
<a name="IDX1949"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um dígito (algarismo de 0 a 9). 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>lcharp</b><i> (<var>obj</var>) </i>
<a name="IDX1950"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for um caractere do Lisp.
(Pode não precisar dessa função.)
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>lowercasep</b><i> (<var>caractere</var>)    </i>
<a name="IDX1951"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere em caixa baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>newline</b>
<a name="IDX1952"></a>
</dt>
<dd><p>O caractere de nova linha. 
</p>
</dd></dl>

<dl>
<dt><u>Variável:</u> <b>space</b>
<a name="IDX1953"></a>
</dt>
<dd><p>O caractere de espaço em branco.
</p>
</dd></dl>

<dl>
<dt><u>Variável:</u> <b>tab</b>
<a name="IDX1954"></a>
</dt>
<dd><p>O caractere de tabulação.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>uppercasep</b><i> (<var>caractere</var>)    </i>
<a name="IDX1955"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere em caixa alta. 
</p>
</dd></dl>

<hr size="6">
<a name="Defini_00e7_00f5es-para-sequ_00eancias-de-caracteres"></a>
<a name="SEC260"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC259" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC256" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC256" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 69.4 Definições para sequências de caracteres </h2>

<dl>
<dt><u>Função:</u> <b>sunlisp</b><i> (<var>lisp_string</var>) </i>
<a name="IDX1956"></a>
</dt>
<dd><p>Converte uma sequência de caracteres do Lisp em uma sequência de caracteres do Maxima.
(Em geral, pode não chegar a precisar dessa função.)
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>lstringp</b><i> (<var>obj</var>) </i>
<a name="IDX1957"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> is uma sequência de caracteres do Lisp.
(Em geral, pode não chegar a precisar dessa função.)
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>stringp</b><i> (<var>obj</var>) </i>
<a name="IDX1958"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for uma sequência de caracteres do Maxima.
Veja a introdução para obter exemplos.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>charat</b><i> (<var>seq_caracte</var>, <var>n</var>) </i>
<a name="IDX1959"></a>
</dt>
<dd><p>Retorna o <var>n</var>-ésimo caractere de <var>seq_caracte</var>.
O primeiro caractere em <var>seq_caracte</var> é retornado com <var>n</var> = 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charat(&quot;Lisp&quot;,1);
(%o2)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>charlist</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1960"></a>
</dt>
<dd><p>Retorna a lsita de todos os caracteres em <var>seq_caracte</var>. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charlist(&quot;Lisp&quot;);
(%o2)                     [L, i, s, p]
(%i3) %[1];
(%o3)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>parsetoken</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1961"></a>
</dt>
<dd><p><code>parsetoken</code> converte a primeira ficha em <var>seq_caracte</var> para o correspondente número ou retorna <code>false</code> se o número não puder ser determinado.
O conjunto de delimitadores para a troca de fichas é <code>{space, comma, semicolon, tab, newline}</code>
</p>
<p>Nota de tradução:
espaço, vírgula, ponto e vírgula, tabulação e nova linha.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) 2*parsetoken(&quot;1.234 5.678&quot;);
(%o2)                         2.468
</pre>
<p>Para analizar, pode também usar a função <code>parse_string</code>.
Veja a descrição no ficheiro 'share\contrib\eval_string.lisp'.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sconc</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1962"></a>
</dt>
<dd><p>Avalia seus argumentos e concatena-os em uma sequência de caracteres.
<code>sconc</code> é como <code>sconcat</code> mas retorna uma sequência de caracteres do Maxima.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sconc(&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3));
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) stringp(%);
(%o3)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>scopy</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1963"></a>
</dt>
<dd><p>Retorna uma cópia de <var>seq_caracte</var> como uma nova sequência de caracteres. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1964"></a>
</dt>
<dt><u>Função:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>, <var>início</var>) </i>
<a name="IDX1965"></a>
</dt>
<dt><u>Função:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>, <var>início</var>, <var>fim</var>) </i>
<a name="IDX1966"></a>
</dt>
<dd><p>Como em <code>supcase</code>, mas caracteres em caixa alta são convertidos para caracteres em caixa baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sequal</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>) </i>
<a name="IDX1967"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>seq_caracte__1</var> e <var>seq_caracte__2</var> tiverem o mesmo comprimento e contiverem os mesmos caracteres. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sequalignore</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>)</i>
<a name="IDX1968"></a>
</dt>
<dd><p>Como em <code>sequal</code> mas igonara a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sexplode</b><i> (<var>seq_caracte</var>)</i>
<a name="IDX1969"></a>
</dt>
<dd><p><code>sexplode</code> é um apelido para a função <code>charlist</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>simplode</b><i> (<var>lista</var>)  </i>
<a name="IDX1970"></a>
</dt>
<dt><u>Função:</u> <b>simplode</b><i> (<var>lista</var>, <var>delim</var>)  </i>
<a name="IDX1971"></a>
</dt>
<dd><p><code>simplode</code> takes uma <code>lista</code> ou expressões  e concatena-as em uma sequência de caracteres.
Se nenhum delimitador <var>delim</var> for usado, <code>simplode</code> funciona como <code>sconc</code> e não utiliza delimitador.
<var>delim</var> pode ser qualquer sequência de caracteres.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) simplode([&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3)]);
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) simplode( sexplode(&quot;stars&quot;),&quot; * &quot; );
(%o3)                   s * t * a * r * s
(%i4) simplode( [&quot;One&quot;,&quot;more&quot;,&quot;coffee.&quot;],&quot; &quot; );
(%o4)                   One more coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sinsert</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>pos</var>)  </i>
<a name="IDX1972"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres que é uma concatenação de <code>substring (<var>seq_caracte</var>, 1, <var>pos</var> - 1)</code>,
a sequência de caracteres <var>seq</var> e <code>substring (<var>seq_caracte</var>, <var>pos</var>)</code>.
Note que o primeiro caractere está em <var>seq_caracte</var> e está na posição 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: &quot;A submarine.&quot;$
(%i3) sconc( substring(s,1,3),&quot;yellow &quot;,substring(s,3) );
(%o3)                  A yellow submarine.
(%i4) sinsert(&quot;hollow &quot;,s,3);
(%o4)                  A hollow submarine.
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1973"></a>
</dt>
<dt><u>Função:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>, <var>início</var>)  </i>
<a name="IDX1974"></a>
</dt>
<dt><u>Função:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>, <var>início</var>, <var>fim</var>)  </i>
<a name="IDX1975"></a>
</dt>
<dd><p>Retorna <var>seq_caracte</var> excepto que cada caractere da posição <var>início</var> até a posição <var>fim</var> está invertido.
Se a posição <var>fim</var> não for fornecida,
todos os caracteres do início ao <var>fim</var> de <var>seq_caracte</var> são substituídos.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sinvertcase(&quot;sInvertCase&quot;);
(%o2)                      SiNVERTcASE
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>slength</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1976"></a>
</dt>
<dd><p>Retorna número de caracteres em <var>seq_caracte</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>smake</b><i> (<var>num</var>, <var>caractere</var>) </i>
<a name="IDX1977"></a>
</dt>
<dd><p>Retorna uma nova sequência de caracteres repetindo <var>num</var> vezes <var>caractere</var>. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smake(3,&quot;w&quot;);
(%o2)                          www
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>smismatch</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>) </i>
<a name="IDX1978"></a>
</dt>
<dt><u>Função:</u> <b>smismatch</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>, <var>test</var>) </i>
<a name="IDX1979"></a>
</dt>
<dd><p>Retorna a posição do primeiro caractere de <var>seq_caracte__1</var> no qual <var>seq_caracte__1</var> e <var>seq_caracte__2</var> diferem ou <code>false</code> em caso contrário.
A função padrao de teste para coincidência é <code>sequal</code>.
Se <code>smismatch</code> pode ignorar a caixa alta/baixa, use <code>sequalignore</code> como função de teste.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smismatch(&quot;seven&quot;,&quot;seventh&quot;);
(%o2)                           6
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>split</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1980"></a>
</dt>
<dt><u>Função:</u> <b>split</b><i> (<var>seq_caracte</var>, <var>delim</var>)  </i>
<a name="IDX1981"></a>
</dt>
<dt><u>Função:</u> <b>split</b><i> (<var>seq_caracte</var>, <var>delim</var>, <var>multiple</var>)  </i>
<a name="IDX1982"></a>
</dt>
<dd><p>Retorna a lista de todas as fichas em <var>seq_caracte</var>.
Cada ficha é uma sequência de caracteres não analisada.
<code>split</code> usa <var>delim</var> como delimitador.
Se <var>delim</var> não for fornecido, o caractere de espaço é o delimitador padrão.
<var>multiple</var> é uma variável booleana com <code>true</code> como valor padrão.
Multiplos delimitadores são lidos como um.
Essa função é útil se tabulações são gravadas com caracteres de espaço multiplos.
Se <var>multiple</var> for escolhido para <code>false</code>, cada delimitador é considerado.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) split(&quot;1.2   2.3   3.4   4.5&quot;);
(%o2)                 [1.2, 2.3, 3.4, 4.5]
(%i3) split(&quot;first;;third;fourth&quot;,&quot;;&quot;,false);
(%o3)               [first, , third, fourth]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sposition</b><i> (<var>caractere</var>, <var>seq_caracte</var>) </i>
<a name="IDX1983"></a>
</dt>
<dd><p>Retorna a posição do primeiro caractere em <var>seq_caracte</var> que coincide com <var>caractere</var>.
O primeiro caractere em <var>seq_caracte</var> está na posição 1.
Para que os caracteres que coincidirem desconsiderem a caixa alta/baixa veja <code>ssearch</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1984"></a>
</dt>
<dt><u>Função:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1985"></a>
</dt>
<dt><u>Função:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>)  </i>
<a name="IDX1986"></a>
</dt>
<dt><u>Função:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>, <var>fim</var>)  </i>
<a name="IDX1987"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres como <var>seq_caracte</var> mas com todas as subsequências de caracteres que coincidirem com <var>seq</var>.
A função padrão de teste de coincidência é <code>sequal</code>.
Se <code>sremove</code> puder ignorar a caixa alta/baixa enquanto busca por <var>seq</var>, use <code>sequalignore</code> como teste.
Use <var>início</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caractere em <var>seq_caracte</var> está na posição 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sremove(&quot;n't&quot;,&quot;I don't like coffee.&quot;);
(%o2)                   I do like coffee.
(%i3) sremove (&quot;DO &quot;,%,'sequalignore);
(%o3)                    I like coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1988"></a>
</dt>
<dt><u>Função:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1989"></a>
</dt>
<dt><u>Função:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>)  </i>
<a name="IDX1990"></a>
</dt>
<dt><u>Função:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>, <var>fim</var>)  </i>
<a name="IDX1991"></a>
</dt>
<dd><p>Como em <code>sremove</code> excepto que a primeira subsequência de caracteres que coincide com <code>seq</code> é removida. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sreverse</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1992"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres com todos os caracteres de <var>seq_caracte</var> em ordem reversa. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1993"></a>
</dt>
<dt><u>Função:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1994"></a>
</dt>
<dt><u>Função:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>)  </i>
<a name="IDX1995"></a>
</dt>
<dt><u>Função:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>, <var>fim</var>)</i>
<a name="IDX1996"></a>
</dt>
<dd><p>Retorna a posição da primeira subsequência de caracteres de <var>seq_caracte</var> que coincide com a sequência de caracteres <var>seq</var>.
A função padrão de teste de coincidência é <code>sequal</code>.
Se <code>ssearch</code> puder igonorar a caixa alta/baixa, use <code>sequalignore</code> como função de teste.
Use <var>início</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caracter em <var>seq_caracte</var> está na posição 1.
</p>
<pre class="example">(%i1) ssearch(&quot;~s&quot;,&quot;~{~S ~}~%&quot;,'sequalignore);
(%o1)                                  4
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ssort</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1997"></a>
</dt>
<dt><u>Função:</u> <b>ssort</b><i> (<var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX1998"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres que contém todos os caracteres de <var>seq_caracte</var> em uma ordem tal que não existam dois caracteres <var>c</var> sucessivos e <var>d</var> seja tal que <code>test (<var>c</var>, <var>d</var>)</code> seja <code>false</code> e <code>test (<var>d</var>, <var>c</var>)</code> seja <code>true</code>.
A função padrão de teste para ordenação é <var>clessp</var>.
O conjunto de funções de teste é <code>{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}</code>.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssort(&quot;I don't like Mondays.&quot;);
(%o2)                    '.IMaddeiklnnoosty
(%i3) ssort(&quot;I don't like Mondays.&quot;,'cgreaterpignore);
(%o3)                 ytsoonnMlkIiedda.'   
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>) </i>
<a name="IDX1999"></a>
</dt>
<dt><u>Função:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2000"></a>
</dt>
<dt><u>Função:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>) </i>
<a name="IDX2001"></a>
</dt>
<dt><u>Função:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>, <var>fim</var>) </i>
<a name="IDX2002"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres como <var>seq_caracte</var> excepto que todas as subsequências de caracteres que coincidirem com <var>antiga</var> são substituídas por <var>nova</var>.
<var>antiga</var> e <var>nova</var> não precisam ser de mesmo comprimento.
A função padrão de teste para coincidência é para coincidências é <code>sequal</code>.
Se <code>ssubst</code> puder ignorar a cixa alta/baixa enquanto procurando por <var>antiga</var>, use <code>sequalignore</code> como função de teste.
Use <var>início</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caractere em <var>seq_caracte</var> está na posição 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssubst(&quot;like&quot;,&quot;hate&quot;,&quot;I hate Thai food. I hate green tea.&quot;);
(%o2)          I like Thai food. I like green tea.
(%i3) ssubst(&quot;Indian&quot;,&quot;thai&quot;,%,'sequalignore,8,12);
(%o3)         I like Indian food. I like green tea.
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>) </i>
<a name="IDX2003"></a>
</dt>
<dt><u>Função:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2004"></a>
</dt>
<dt><u>Função:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>) </i>
<a name="IDX2005"></a>
</dt>
<dt><u>Função:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>início</var>, <var>fim</var>) </i>
<a name="IDX2006"></a>
</dt>
<dd><p>Como em <code>subst</code> excepto que somente a primeira subsequência de caracteres que coincidir com <var>antiga</var> é substituída. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>strim</b><i> (<var>seq</var>,<var>seq_caracte</var>) </i>
<a name="IDX2007"></a>
</dt>
<dd><p>Retorna uma sequência de caracteres como <var>seq_caracte</var>,
mas com todos os caracteres que aparecerem em <var>seq</var> removidos de ambas as extremidades. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) &quot;/* comment */&quot;$
(%i3) strim(&quot; /*&quot;,%);
(%o3)                        comment
(%i4) slength(%);
(%o4)                           7
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>striml</b><i> (<var>seq</var>, <var>seq_caracte</var>) </i>
<a name="IDX2008"></a>
</dt>
<dd><p>Como em <code>strim</code> excepto que somente a extremidade esquerda de <var>seq_caracte</var> é recordada. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>strimr</b><i> (<var>seq</var>, <var>seq_caracte</var>) </i>
<a name="IDX2009"></a>
</dt>
<dd><p>Como em <code>strim</code> excepto que somente a extremidade direita de sequência de caracteres é recortada. 
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>substring</b><i> (<var>seq_caracte</var>, <var>início</var>)</i>
<a name="IDX2010"></a>
</dt>
<dt><u>Função:</u> <b>substring</b><i> (<var>seq_caracte</var>, <var>início</var>, <var>fim</var>) </i>
<a name="IDX2011"></a>
</dt>
<dd><p>Retorna a subsequência de caracteres de <var>seq_caracte</var> começando na posição <var>início</var> e terminando na posição <var>fim</var>.
O caractere na posição <var>fim</var> não é incluído.
Se <var>fim</var> não for fornecido, a subsequência de caracteres contém o restante da sequência de caracteres.
Note que o primeiro caractere em <var>seq_caracte</var> está na posição 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) substring(&quot;substring&quot;,4);
(%o2)                        string
(%i3) substring(%,4,6);
(%o3)                          in
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>supcase</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX2012"></a>
</dt>
<dt><u>Função:</u> <b>supcase</b><i> (<var>seq_caracte</var>, <var>início</var>) </i>
<a name="IDX2013"></a>
</dt>
<dt><u>Função:</u> <b>supcase</b><i> (<var>seq_caracte</var>, <var>início</var>, <var>fim</var>) </i>
<a name="IDX2014"></a>
</dt>
<dd><p>Retorna <var>seq_caracte</var> excepto que caracteres em caixa baixa a partir da posição <var>início</var> até a posição <var>fim</var> são substituídos pelo correspondente caracteres em cixa alta.
Se <var>fim</var> não for fornecido,
todos os caracteres em caixa baixa de <var>início</var> até o fim de <var>seq_caracte</var> são substituídos.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) supcase(&quot;english&quot;,1,2);
(%o2)                        English
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>tokens</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX2015"></a>
</dt>
<dt><u>Função:</u> <b>tokens</b><i> (<var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2016"></a>
</dt>
<dd><p>Retorna uma lista de fichas, que tiverem sido extrídos de <var>seq_caracte</var>.
As fichas são subsequências de caracteres cujos caracteres satisfazem a uma determinada função de teste.
Se o teste não for fornecido, <var>constituent</var> é usada como teste padrão.
<code>{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp}</code> é o conjunto de fnç~oes de teste. 
(A versão Lisp de <code>tokens</code> é escrita por Paul Graham. ANSI Common Lisp, 1996, page 67.)
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) tokens(&quot;24 October 2005&quot;);
(%o2)                  [24, October, 2005]
(%i3) tokens(&quot;05-10-24&quot;,'digitcharp);
(%o3)                     [05, 10, 24]
(%i4) map(parsetoken,%);
(%o4)                      [5, 10, 24]
</pre>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC256" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_70.html#SEC261" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
