<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima 5.41.0: 36. Regras e Modelos</title>

<meta name="description" content="Manual do Maxima 5.41.0: 36. Regras e Modelos">
<meta name="keywords" content="Manual do Maxima 5.41.0: 36. Regras e Modelos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Regras-e-Modelos"></a>
<a name="SEC142"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_35.html#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC138" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC145" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 36. Regras e Modelos </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC143">36.1 Introdução a Regras e Modelos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC144">36.2 Definições para Regras e Modelos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Regras-e-Modelos"></a>
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC142" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC145" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.1 Introdução a Regras e Modelos </h2>

<p>Essa secção descreve coincidências de modelos definidos pelo utilizador e
regras de simplificação.
Existem dois grupos de funções que implementam até certo ponto diferentes esquemas de coincidência de modelo.
Em um grupo estão <code>tellsimp</code>, <code>tellsimpafter</code>, <code>defmatch</code>, <code>defrule</code>,
<code>apply1</code>, <code>applyb1</code>, e <code>apply2</code>.
Em outro grupo estão <code>let</code> e <code>letsimp</code>.
Ambos os esquemas definem modelos em termos de variáveis de modelo declaradas por <code>matchdeclare</code>.
</p>
<p>Regras de coincidência de modelos definidas por <code>tellsimp</code> e <code>tellsimpafter</code> são aplicadas automaticamente
através do simplificador do Maxima.
Regras definidas através de <code>defmatch</code>, <code>defrule</code>, e <code>let</code> são aplicadas
através de uma chamada explícita de função.
</p>
<p>Existe mecanismos adicionais para regras aplicadas a polinómios através de <code>tellrat</code>,
e para álgebra comutativa e não comutativa no pacote <code>affine</code>. 
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-Regras-e-Modelos"></a>
<a name="SEC144"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC145" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC142" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC145" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.2 Definições para Regras e Modelos </h2>

<dl>
<dt><u>Função:</u> <b>apply1</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1167"></a>
</dt>
<dd><p>Repetidamente aplica <var>rule_1</var> a
<var>expr</var> até que isso falhe, então repetidamente aplica a mesma regra a todas
as subexpressões de <var>expr</var>, da esquerda para a direita, até que <var>rule_1</var> tenha falhado
sobre todas as subexpressões.  Chama o resultado da transformação de <var>expr</var> dessa
maneira de <var>expr_2</var>.  Então <var>rule_2</var> é aplicada no mesmo estilo
iniciando no topo de <var>expr_2</var>.  Quando <var>rule_n</var> falhar na subexpressão
final, o resultado é retornado.
</p>
<p><code>maxapplydepth</code> é a intensidade de nível mais distante de subexpressões processadas por
<code>apply1</code> e <code>apply2</code>.
</p>
<p>Veja também <code>applyb1</code>, <code>apply2</code>, e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>apply2</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1168"></a>
</dt>
<dd><p>Se <var>rule_1</var> falhar sobre uma dada subexpressão, então <var>rule_2</var> é
repetidamente aplicada, etc.  Somente se todas as regras falharem sobre uma dada
subexpressão é que o conjunto completo de regras é repetidamente aplicada à próxima
subexpressão.  Se uma das regras obtém sucesso, então a mesma
subexpressão é reprocessada, iniciando com a primeira regra.
</p>
<p><code>maxapplydepth</code> é a intensidade do nível mais distante de subexpressões processadas através de
<code>apply1</code> e <code>apply2</code>.
</p>
<p>Veja também <code>apply1</code> e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>applyb1</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1169"></a>
</dt>
<dd><p>Repetidamente aplica <var>rule_1</var> para a subexpressão mais distante de <var>expr</var> até falhar,
então repetidamente aplica a mesma regra um nível mais acima (i.e., subexpressãos mais larga),
até que <var>rule_1</var> tenha falhado sobre a expressão de nível mais alto.
Então <var>rule_2</var> é aplicada com o mesmo estilo para o resultado de <var>rule_1</var>.
após <var>rule_n</var> ter sido aplicada à expressão de nível mais elevado,
o resultado é retornado.
</p>
<p><code>applyb1</code> é similar a <code>apply1</code> mas trabalha da
base para cima em lugar de do topo para baixo.
</p>
<p><code>maxapplyheight</code> é o ápice que <code>applyb1</code> encontra
antes de interromper.
</p>
<p>Veja também <code>apply1</code>, <code>apply2</code>, e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>current_let_rule_package</b>
<a name="IDX1170"></a>
</dt>
<dd><p>Valor por omissão: <code>default_let_rule_package</code>
</p>
<p><code>current_let_rule_package</code> é o nome do pacote de regras que está sendo usado por
funções no pacote <code>let</code> (<code>letsimp</code>, etc.) se nenhum outro pacote de regras for especificado.
A essa variável pode ser atribuído o nome de qualquer pacote de regras definido
via comando <code>let</code>.
</p>
<p>Se uma chamada tal como <code>letsimp (expr, nome_pct_regras)</code> for feita,
o pacote de regras <code>nome_pct_regras</code> é usado para aquela chamada de função somente,
e o valor de <code>current_let_rule_package</code> não é alterado.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>default_let_rule_package</b>
<a name="IDX1171"></a>
</dt>
<dd><p>Valor por omissão: <code>default_let_rule_package</code>
</p>
<p><code>default_let_rule_package</code> é o nome do pacote de regras usado quando um
não for explicitamente escolhido pelo utilizador com <code>let</code> ou através de alteração do valor de
<code>current_let_rule_package</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>defmatch</b><i> (<var>prognome</var>, <var>modelo</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX1172"></a>
</dt>
<dt><u>Função:</u> <b>defmatch</b><i> (<var>prognome</var>, <var>modelo</var>)</i>
<a name="IDX1173"></a>
</dt>
<dd><p>Define uma função <code><var>prognome</var>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>
que testa <var>expr</var> para ver se essa expressão coincide com <var>modelo</var>.
</p>
<p><var>modelo</var> é uma expressão contendo os argumentos modelo <var>x_1</var>, ..., <var>x_n</var> (se existir algum)
e alguns modelos de variáveis (se existir algum).
os argumentos modelo são fornecidos explicitamente como argumentos para <code>defmatch</code> enquanto os modelos de variáveis
são declarados através da função <code>matchdeclare</code>.
Qualquer variável não declarada como modelo em <code>matchdeclare</code>
ou como um argumento modelo em <code>defmatch</code> coincide somente com si mesma.
</p>
<p>O primeiro argumento para a função criada <var>prognome</var> é uma expressão
a serem comparadas contra o modelo  e os outros argumentos são os atuais argumetnos
que correspondem às variáveis respectivas <var>x_1</var>, ..., <var>x_n</var> no modelo.
</p>
<p>Se a tentativa de coincidência obtiver sucesso, <var>prognome</var> retorna
uma lista de equações cujos lados esquerdos são os
argumetnos de modelo e variáveis de modelo, e cujo lado direito forem as subexpressões
cujos argumentos de modelo e as variáveis coincidem.
Os modelos de variáveis, mas não tos argumentos de modelo, são atribuídos às subexpressões que coincidirem.
Se a coincidência falhar, <var>prognome</var> retorna <code>false</code>.  
</p>
<p>Um modelo literal
(isto é, um modelo que não contiver nem argumentos de modelo nem variáveis de modelo)
retorna <code>true</code> se a coincidência ocorrer.
</p>
<p>Veja também <code>matchdeclare</code>, <code>defrule</code>, <code>tellsimp</code>, e <code>tellsimpafter</code>.
</p>
<p>Exemplos:
</p>
<p>Define uma função <code>linearp(expr, x)</code> que
testa <code>expr</code> para ver se essa expressão da forma <code>a*x + b</code>
tal que <code>a</code> e <code>b</code> não contenham <code>x</code> e <code>a</code> seja não nulo.
Essa função de coincidência coincide com expressões que sejam lineares em qualquer variável,
por que o argumento de modelo <code>x</code> é fornecido para <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre>
<p>Define uma função <code>linearp(expr)</code> que testa <code>expr</code>
para ver se essa expressão é da forma <code>a*x + b</code>
tal que <code>a</code> e <code>b</code> não contenham <code>x</code> e <code>a</code> seja não nulo.
Essa função de coincidência somente coincide com expressões lineares em <code>x</code>,
não em qualquer outra variável, porque nenhum argumento de modelo é fornecido a <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre>
<p>Define uma função <code>checklimits(expr)</code> que testa <code>expr</code>
para ver se essa expressão é uma integral definida.
</p> 
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>defrule</b><i> (<var>nomeregra</var>, <var>modelo</var>, <var>substituição</var>)</i>
<a name="IDX1174"></a>
</dt>
<dd><p>Define e nomeia uma
regra de substituição para o modelo dado.  Se a regra nomeada <var>nomeregra</var> for
aplicada a uma expressão (através de <code>apply1</code>, <code>applyb1</code>, ou <code>apply2</code>), toda
subexpressão coincidindo com o modelo será substituída por
<code>substituição</code>. Todas as variáveis em <code>substituição</code> que tiverem sido
atribuidos valores pela coincidência com o modelo são atribuidas esses valores na
<code>substituição</code> que é então simplificado.
</p>
<p>As regras por si mesmas podem ser
tratadas como funções que transforma uma expressão através de uma
operação de coincidência de modelo e substituição.
Se a coincidência falhar, a função da regra retorna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>disprule</b><i> (<var>nomeregra_1</var>, ..., <var>nomeregra_2</var>)</i>
<a name="IDX1175"></a>
</dt>
<dt><u>Função:</u> <b>disprule</b><i> (all)</i>
<a name="IDX1176"></a>
</dt>
<dd><p>Mostra regras com os nomes <var>nomeregra_1</var>, ..., <var>nomeregra_n</var>,
como retornado por <code>defrule</code>, <code>tellsimp</code>, ou <code>tellsimpafter</code>,
ou um modelo definido por meio de <code>defmatch</code>.
</p>
<p>Cada regra é mostrada com um rótulo de expressão intermédia (<code>%t</code>).
</p>
<p><code>disprule (all)</code> mostra todas as regras.
</p>
<p><code>disprule</code> não avalia seus argumentos.
</p>
<p><code>disprule</code> retorna a lista de rótulos de expressões intermedáirias correspondendo às regras mostradas.
</p>
<p>Veja também <code>letrules</code>, que mostra regras definidas através de <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x),
+rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ..., <var>arg_n</var>)</i>
<a name="IDX1177"></a>
</dt>
<dt><u>Função:</u> <b>let</b><i> ([<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>nome_pacote</var>)</i>
<a name="IDX1178"></a>
</dt>
<dd><p>Define uma regra de substituição para <code>letsimp</code> tal que <var>prod</var> é substituído por <var>repl</var>.
<var>prod</var> é um produto de expoentes positivos ou negativos dos seguintes termos:
</p>
<ul>
<li>
Atomos que <code>letsimp</code> irá procurar literalmente a menos que previamente
chamando <code>letsimp</code> a função <code>matchdeclare</code> é usada para associar um
predicado com o átomo.  Nesse caso <code>letsimp</code> irá coincidir com o átomo para
qualquer termo de um produto satisfazendo o predicado.
</li><li>
Núcleos tais como <code>sin(x)</code>, <code>n!</code>, <code>f(x,y)</code>, etc.  Como com átomos acima
<code>letsimp</code> irá olhar um literal coincidente a menos que <code>matchdeclare</code> seja usada para
associar um predicado com o argumento do núcleo.
</li></ul>

<p>Um termo para um expoente positivo irá somente coincidir com um termo tendo ao menos aquele
expoente.  Um termo para um expoente negativo
por outro lado irá somente coincidir com um termo com um expoente ao menos já
negativo.  o caso de expentes negativos em <var>prod</var> o comutador
<code>letrat</code> deve ser escolhido para <code>true</code>.
Veja também <code>letrat</code>.
</p>
<p>Se um predicado for incluído na função <code>let</code> seguido por uma lista de
argumentos, uma tentativa de coincidência (i.e. uma que pode ser aceita se o
predicado fosse omitido) é aceita somente se
<code>prednome (arg_1', ..., arg_n')</code> avaliar para <code>true</code> onde <var>arg_i'</var> é o valor
coincidente com <var>arg_i</var>.  O <var>arg_i</var> pode ser o nome de qualquer átomo ou o argumento
de qualquer núcleo aparecendo em <var>prod</var>.
<var>repl</var> pode ser qualquer expressão racional. Se quaisquer dos átomos ou argumentos de <var>prod</var> aparecer em <var>repl</var> a
substituição é feita. </p>
<p>O sinalizador global <code>letrat</code> controla a simplificação dos quocientes através de <code>letsimp</code>.
Quando <code>letrat</code> for <code>false</code>,
<code>letsimp</code> simplifica o numerador e o
denominador de <var>expr</var> separadamente, e não simplifica o quociente.
Substituições tais como <code>n!/n</code> vão para <code>(n-1)!</code> então falham quando <code>letrat</code> for <code>false</code>.
Quando <code>letrat</code> for <code>true</code>, então o numerador,
o denominador, e o quociente são simplificados nessa ordem.
</p>
<p>Essas funções de substituição
permitem-lhe trabalhar com muitos pacotes de regras.  Cada pacote de
regras pode conter qualquer número de regras <code>let</code> e é
referenciado através de um nome definido pelo utilizador.  <code>let
([<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ...,
<var>arg_n</var>], <var>nome_pacote</var>)</code> adiciona a regra <var>prednome</var> ao
pacote de regras <var>nome_pacote</var>.  <code>letsimp (<var>expr</var>,
<var>nome_pacote</var>)</code> aplica as regras em <var>nome_pacote</var>.
<code>letsimp (<var>expr</var>, <var>nome_pacote1</var>, <var>nome_pacote2</var>, ...)</code>
é equivalente a <code>letsimp (<var>expr</var>, <var>nome_pacote1</var>)</code>
seguido por <code>letsimp (%, <var>nome_pacote2</var>)</code>, ....
</p>
<p><code>current_let_rule_package</code> é o nome do pacote de regras que está
actualmente sendo usando.
Essa variável pode receber o nome de
qualquer pacote de regras definidos via o comando <code>let</code>.
Quando qualquer das funções compreendidas no pacote <code>let</code> são chamadas sem o nome do pacote,
o pacote nomeado por <code>current_let_rule_package</code> é usado.
Se uma chamada tal como <code>letsimp (<var>expr</var>, <var>nome_pct_regras</var>)</code> é feita,
o pacote de regras <var>nome_pct_regras</var> é usado somente para aquele comando <code>letsimp</code>,
e <code>current_let_rule_package</code> não é alterada.
Se não especificado de outra forma,
<code>current_let_rule_package</code> avalia de forma padronizada para <code>default_let_rule_package</code>.
</p>
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>letrat</b>
<a name="IDX1179"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>letrat</code> for <code>false</code>, <code>letsimp</code> simplifica o
numerador e o denominador de uma razão separadamente,
e não simplifica o quociente.
</p>
<p>Quando <code>letrat</code> for <code>true</code>,
o numerador, o denominador, e seu quocienten são simplificados nessa ordem.
</p>
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>letrules</b><i> ()</i>
<a name="IDX1180"></a>
</dt>
<dt><u>Função:</u> <b>letrules</b><i> (<var>nome_pacote</var>)</i>
<a name="IDX1181"></a>
</dt>
<dd><p>Mostra as regras em um pacote de regras.
<code>letrules ()</code> mostra as regras no pacote de regras corrente.
<code>letrules (<var>nome_pacote</var>)</code> mostra as regras em <code>nome_pacote</code>.
</p>
<p>O pacote de regras corrente é nomeado por <code>current_let_rule_package</code>.
Se não especificado de outra forma, <code>current_let_rule_package</code>
avalia de forma padrão para <code>default_let_rule_package</code>.
</p>
<p>Veja também <code>disprule</code>, que mostra regras defindas por <code>tellsimp</code> e <code>tellsimpafter</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>letsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1182"></a>
</dt>
<dt><u>Função:</u> <b>letsimp</b><i> (<var>expr</var>, <var>nome_pacote</var>)</i>
<a name="IDX1183"></a>
</dt>
<dt><u>Função:</u> <b>letsimp</b><i> (<var>expr</var>, <var>nome_pacote_1</var>, ..., <var>nome_pacote_n</var>)</i>
<a name="IDX1184"></a>
</dt>
<dd><p>Repetidamente aplica a substituição definida por <code>let</code>
até que nenhuma mudança adicional seja feita para <var>expr</var>.
</p>
<p><code>letsimp (<var>expr</var>)</code> usa as regras de <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>nome_pacote</var>)</code> usa as regras de <var>nome_pacote</var>
sem alterar <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>nome_pacote_1</var>, ..., <var>nome_pacote_n</var>)</code>
é equivalente a <code>letsimp (<var>expr</var>, <var>nome_pacote_1</var></code>,
seguido por <code>letsimp (%, <var>nome_pacote_2</var>)</code>, e assim sucessivamente.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>let_rule_packages</b>
<a name="IDX1185"></a>
</dt>
<dd><p>Valor por omissão: <code>[default_let_rule_package]</code>
</p>
<p><code>let_rule_packages</code> é uma lista de todos os pacotes de regras <code>let</code> definidos pelo utilizador
mais o pacote padrão <code>default_let_rule_package</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>matchdeclare</b><i> (<var>a_1</var>, <var>pred_1</var>, ..., <var>a_n</var>, <var>pred_n</var>)</i>
<a name="IDX1186"></a>
</dt>
<dd><p>Associa um predicado <var>pred_k</var> 
com uma variável ou lista de variáveis <var>a_k</var>
de forma que <var>a_k</var> coincida com expressões
para as quais o predicado retorne qualquer coisa que não <code>false</code>.
</p>
<p>Umpredicado é o nome de uma função,
ou de uma expressão lambda,
ou uma chamada de função ou chamada de função lambda iomitindo o úlltimo argumento,
ou <code>true</code> ou <code>all</code>.
Qualquer expressão coincide com <code>true</code> ou <code>all</code>.
Se o predicado for especificado como uma chamada de função ou chamada de função lambda,
a expressão a ser testada é anexada ao final da lista de argumentos;
os argumentos são avaliados ao mesmo tempo que a coincidência é avaliada.
De outra forma, o predicado é especificado como um nome de função ou expressão lambda,
e a expressão a ser testada é o argumento sozinho.
Uma função predicado não precisa ser definida quando <code>matchdeclare</code> for chamada;
o predicado não é avaliado até que uma coincidência seja tentada.
</p>
<p>Um predicado pode retornar uma expressão Booleana além de <code>true</code> ou <code>false</code>.
Expressões Booleanas são avaliadas por <code>is</code> dentro da função da regra construída,
de forma que não é necessário chamar <code>is</code> dentro do predicado.
</p>
<p>Se uma expressão satisfaz uma coincidência de predicado,
a variável de coincidência é atribuída à expressão,
excepto para variáveis de coincidência que são operandos de adição <code>+</code> ou multiplicação <code>*</code>.
Somente adição e multiplicação são manuseadas de forma especial;
outros operadores enários (ambos os definidos internamente e os definidos pelo utilizador) são tratados como funções comuns.
</p>
<p>No caso de adição e multiplicação,
a variável de coincidência pode ser atribuida a uma expressão simples que satisfaz o predicado de coincidência,
ou uma adição ou um produto (respectivamente) de tais expressões.
Tal coincidência de termo multiplo é gulosa:
predicados são avaliados na ordem em que suas variáveis associadas
aparecem no modelo de coincidência,
e o termo que satisfizer mais que um predicado é tomado pelo primeiro
predicado que satisfizer.
Cada predicado é testado contra todos os operandos de adição ou produto antes que o próximo predicado seja avaliado.
Adicionalmente,
se 0 ou 1 (respectivamente) satisfazem um predicado de coincidência,
e não existe outros termos que satisfaçam o predicado,
0 ou 1 é atribuído para a variável de coincidência associada com o predicado.
</p>
<p>O algoritmo para processar modelos contendo adição e multiplicação faz alguns resultados de coincidência
(por exemplo, um modelo no qual uma variável &quot;coincida com qualquer coisa&quot; aparecer)
dependerem da ordem dos termos no modelo de coincidência e na expressão a ser testada a coincidência.
Todavia,
se todos os predicados de coincidência são mutuamente exclusivos,
o resultado de coincidência é insensível a ordenação,
como um predicado de coincidência não pode aceitar termos de coincidência de outro.
</p>
<p>Chamado <code>matchdeclare</code> com uma variável <var>a</var> como um argumento
muda a propriedade <code>matchdeclare</code> para <var>a</var>, se a variável <var>a</var> tiver sido declarada anteriormente;
somente o <code>matchdeclare</code> mais recente está em efeito quando uma regra é definida,
mudanças posteriores para a propriedade <code>matchdeclare</code>
(via <code>matchdeclare</code> ou <code>remove</code>)
não afectam regras existentes.
</p>
<p><code>propvars (matchdeclare)</code> retorna a lista de todas as variáveis
para as quais exista uma propriedade <code>matchdeclare</code>.
<code>printprops (<var>a</var>, matchdeclare)</code> retorna o predicado para a variável <code>a</code>.
<code>printprops (all, matchdeclare)</code> retorna a lista de predicados para todas as variáveis <code>matchdeclare</code>.
<code>remove (<var>a</var>, matchdeclare)</code> remove a propriedade <code>matchdeclare</code> da variável <var>a</var>.
</p>
<p>As funções
<code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>tellsimpafter</code>, e <code>let</code>
constroem regras que testam expressões contra modelos.
</p>
<p><code>matchdeclare</code> coloca apóstrofo em seus argumentos.
<code>matchdeclare</code> sempre retorna <code>done</code>.
</p>
<p>Exemplos:
</p>
<p>Um predicado é o nome de uma função,
ou uma expressão lambda,
ou uma chamada de função ou chamada a função lambda omitindo o último argumento,
or <code>true</code> or <code>all</code>.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre>
<p>Se uma expressão satisfaz um predicado de coincidência,
a variável de coincidência é atribuída à expressão.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre>
<p>No caso de adição e multiplicação,
à variável de coincidência pode ser atribuída uma expressão simples que satisfaz o predicado de coincidência,
ou um somatório ou produtório (respectivamente) de tais expressões.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre>
<p>Quando coincidindo argumentos de <code>+</code> e <code>*</code>,
se todos os predicados de coincidência forem mutuamente exclusivos,
o resultado da coincidência é insensíve à ordenação,
como um predicado de coincidência não pode aceitar termos que coincidiram com outro.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre>
<p>As funções <code>propvars</code> e <code>printprops</code> retornam informações sobre variávels de coincidência.
</p>
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>matchfix</b><i> (<var>delimitador_e</var>, <var>delimitador_d</var>)</i>
<a name="IDX1187"></a>
</dt>
<dt><u>Função:</u> <b>matchfix</b><i> (<var>delimitador_e</var>, <var>delimitador_d</var>, <var>arg_pos</var>, <var>pos</var>)</i>
<a name="IDX1188"></a>
</dt>
<dd><p>Declara um operador <code>matchfix</code> com delimitadores esquerdo e direito <var>delimitador_e</var> e <var>delimitador_d</var>.
Os delimitadores são especificados como sequêcias de caracteres.
</p>
<p>Um operador &quot;matchfix&quot; é uma função que aceita qualquer número de argumentos,
tal que os argumentos ocorram entre os delimitadores correspondentes esquerdo e direito.
Os delimitadores podem ser quaisquer sequêcias de caracteres, contanto que o analisador de expressões do Maxima possa
distinguir os delimitadores dos operandos 
e de outras expressões e operadores.
Na prática essas regras excluem delimitadores não analisáveis tais como
<code>%</code>, <code>,</code>, <code>$</code> e <code>;</code>, 
e pode ser necessário isolar os delimitadores com espaços em branco.
O delimitador da direita pode ser o mesmo ou diferente do delimitador da esquerda.
</p>
<p>Um delimitador esquerdo pode ser associado com somente um delimitador direito;
dois diferentes operadores <code>matchfix</code> não podem ter o mesmo delimitador esquerdo.
</p>
<p>Um operador existente pode ser redeclarado com um operador <code>matchfix</code>
sem alterar suas outras propriedades.
Particularmente, operadores internos tais como adição <code>+</code> podem
ser declarados <code>matchfix</code>,
mas funções operadores não podem ser definidas para operadores internos.
</p>
<p><code>matchfix (<var>delimitador_e</var>, <var>delimitador_d</var>, <var>arg_pos</var>, <var>pos</var>)</code> 
declara o argumento <var>arg_pos</var> como sendo um entre: expressão lógica,
expressão comum do Maxima mas que não seja do tipo anterior, e qualquer outro
tipo de expressão que não esteja incluída nos dois primeiros tipos.
Essa declaração resulta em <var>pos</var> sendo um entre: expressão lógica,
expressão comum do Maxima mas que não seja do tipo anterior, e qualquer outro
tipo de expressão que não esteja incluída nos dois primeiros tipos 
e os delimitadores <var>delimitador_e</var> e <var>delimitador_d</var>.
</p>

<p>A função para realizar uma operação <code>matchfix</code> é uma função
comum definida pelo utilizador.
A função operador é definida
da forma usual
com o operador de definição de função <code>:=</code> ou <code>define</code>.
Os argumentos podem ser escritos entre os delimitadores,
ou com o delimitador esquerdo com uma sequência de caracteres com apóstrofo e os argumentos
seguindo entre parêntesis.
<code>dispfun (<var>delimitador_e</var>)</code> mostra a definição da função operador.
</p>
<p>O único operador interno <code>matchfix</code> é o construtor de listas <code>[ ]</code>.
Parêntesis <code>( )</code> e aspas duplas <code>&quot; &quot;</code> 
atuam como operadores <code>matchfix</code>,
mas não são tratados como tal pelo analisador do Maxima.
</p>
<p><code>matchfix</code> avalia seus argumentos.
<code>matchfix</code> retorna seu primeiro argumento, <var>delimitador_e</var>.
</p>
<p>Exemplos:
</p>
<ul>
<li>
Delimitadores podem ser quase quaisquer sequência de caracteres.
</li></ul>
<pre class="example">(%i1) matchfix (&quot;@@&quot;, &quot;~&quot;);
(%o1)                          @@
(%i2) @@ a, b, c ~;
(%o2)                      @@a, b, c~
(%i3) matchfix (&quot;&gt;&gt;&quot;, &quot;&lt;&lt;&quot;);
(%o3)                          &gt;&gt;
(%i4) &gt;&gt; a, b, c &lt;&lt;;
(%o4)                      &gt;&gt;a, b, c&lt;&lt;
(%i5) matchfix (&quot;foo&quot;, &quot;oof&quot;);
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) &gt;&gt; w + foo x, y oof + z &lt;&lt; / @@ p, q ~;
                     &gt;&gt;z + foox, yoof + w&lt;&lt;
(%o7)                ----------------------
                            @@p, q~
</pre>
<ul>
<li>
Operadores <code>matchfix</code> são funções comuns definidas pelo utilizador.
</li></ul>
<pre class="example">(%i1) matchfix (&quot;!-&quot;, &quot;-!&quot;);
(%o1)                         &quot;!-&quot;
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define (&quot;!-&quot; (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun (&quot;!-&quot;);
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) &quot;!-&quot; (3, 5);
                                16
(%o7)                         - --
                                15
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>remlet</b><i> (<var>prod</var>, <var>nome</var>)</i>
<a name="IDX1189"></a>
</dt>
<dt><u>Função:</u> <b>remlet</b><i> ()</i>
<a name="IDX1190"></a>
</dt>
<dt><u>Função:</u> <b>remlet</b><i> (all)</i>
<a name="IDX1191"></a>
</dt>
<dt><u>Função:</u> <b>remlet</b><i> (all, <var>nome</var>)</i>
<a name="IDX1192"></a>
</dt>
<dd><p>Apaga a regra de substituiçao, prod -&gt; repl, mais
recentemente definida através dea função <code>let</code>.  Se <code>nome</code> for fornecido a regra é
apagada do pacote de regras chamado <code>nome</code>.
</p>
<p><code>remlet()</code> e <code>remlet(all)</code> apagam todas as regras de substituição do pacote de regras corrente.
Se o nome de um pacote de regras for fornecido,
e.g. <code>remlet (all, <var>nome</var>)</code>, o pacote de regras <var>nome</var> é também apagado.
</p>
<p>Se uma substituição é para ser mudada usando o mesmo
produto, <code>remlet</code> não precisa ser chamada, apenas redefina a substituição
usando o mesmo produto (literalmente) com a função <code>let</code> e a nova
substituição e/ou nome de predicado.  Pode agora <code>remlet (<var>prod</var>)</code> ser
chamada e a regra de substituição original é ressuscitada.
</p>
<p>Veja também <code>remrule</code>, que remove uma regra definida através de <code>tellsimp</code> ou de <code>tellsimpafter</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>remrule</b><i> (<var>op</var>, <var>nomeregra</var>)</i>
<a name="IDX1193"></a>
</dt>
<dt><u>Função:</u> <b>remrule</b><i> (<var>op</var>, all)</i>
<a name="IDX1194"></a>
</dt>
<dd><p>Remove regras definidas por <code>tellsimp</code>, ou <code>tellsimpafter</code>.
</p>
<p><code>remrule (<var>op</var>, <var>nomeregra</var>)</code>
remove a regra com o nome <code>nomeregra</code> do operador <var>op</var>.
Quando <var>op</var> for um operador interno ou um operador definido pelo utilizador
(como definido por <code>infix</code>, <code>prefix</code>, etc.),
<var>op</var> e <var>rulename</var> devem ser colocados entre aspas duplas.
</p>
<p><code>remrule (<var>op</var>, all)</code> remove todas as regras para o operador <var>op</var>.
</p>
<p>Veja também <code>remlet</code>, que remove uma regra definida através de <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, &quot;+rule1&quot;);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, &quot;@@rule1&quot;);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>tellsimp</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1195"></a>
</dt>
<dd><p>é similar a <code>tellsimpafter</code> mas coloca
nova informação antes da antiga de forma que essa nova regra seja aplicada antes das regras
de simplificação internas.
</p>
<p><code>tellsimp</code> é usada quando for importante modificar a expressão
antes que o simplificador trabalhe sobre ela, por exemplo se o
simplificador &quot;sabe&quot; alguma coisa sobre a expressão, mas o que ele
retorna não é para sua apreciação.  Se o
simplificador &quot;sabe&quot; alguma coisa sobre o principal operador da
expressão, mas está simplesmente a escondê-lo, provavelmente
querrá usar <code>tellsimpafter</code>.
</p>
<p>O modelo pode não ser uma
adição, um produto, variável simples, ou número.
</p>
<p><code>rules</code> é a lista de regras definidas por
<code>defrule</code>, <code>defmatch</code>, <code>tellsimp</code>, e <code>tellsimpafter</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>tellsimpafter</b><i> (<var>modelo</var>, <var>substituição</var>)</i>
<a name="IDX1196"></a>
</dt>
<dd><p>Define a uma regra de simplificação que o simplificador do Maxima
aplica após as regras de simplificação internas.
<var>modelo</var> é uma expressão, compreendendo variáveis de modelo (declaradas através de <code>matchdeclare</code>)
e outros átomos e operações, considerados literais para o propósito de coincidência de modelos.
<var>substituição</var> é substituída para uma expressão actual que coincide com <var>modelo</var>;
variáveis de modelo em <var>substituição</var> são atribuidas a valores coincidentes na expressão actual.
</p>
<p><var>modelo</var> pode ser qualquer expressão não at&ocirc;mica
na qual o principal operador não é uma variável de modelo;
a regra de simplificação está associada com o operador principal.
Os nomes de funções (com uma excessão, descrita abaixo), listas, e arrays
podem aparecer em <var>modelo</var> como o principal operador somente como literais (não variáveis de modelo);
essas regras fornecem expressões tais como <code>aa(x)</code> e <code>bb[y]</code> como modelos,
se <code>aa</code> e <code>bb</code> forem variáveis de modelo.
Nomes de funções, listas, e arrays que são variáveis de modelo podem aparecer como operadores
outros que não o operador principal em <var>modelo</var>.
</p>
<p>Existe uma excessão para o que foi dito acima com relação a regras e nomes de funções.
O nome de uma função subscrita em uma expressão tal como <code>aa[x](y)</code>
pode ser uma variável de modelo,
porque o operador principal não é <code>aa</code> mas ao contrário o átomo Lisp <code>mqapply</code>.
Isso é uma consequência da representação de expressões envolvendo funções subscritas.
</p>

<p>Regras de simplificação são aplicadas após avaliação 
(se não suprimida através de colocação de apóstrofo ou do sinalizador <code>noeval</code>).
Regras estabelecidas por <code>tellsimpafter</code> são aplicadas na ordem em que forem definidas,
e após quaisquer regras internas.
Regras são aplicadas de baixo para cima, isto é,
aplicadas primeiro a subexpressões antes de ser aplicada à expressão completa.
Isso pode ser necessário para repetidamente simplificar um resultado
(por exemplo, via o operador apóstrofo-apóstrofo <code>''</code> ou o sinalizador <code>infeval</code>)
para garantir que todas as regras são aplicadas.
</p>
<p>Variáveis de modelo são tratadas como variáveis locais em regras de simplificação.
Assim que uma regra é definida, o valor de uma variável de modelo
não afecta a regra, e não é afectado pela regra.
Uma atribuição para uma variável de modelo que resulta em uma coincidência de regra com sucesso
não afecta a atribuição corrente (ou necessita disso) da variável de modelo.
Todavia,
como com todos os átomos no Maxima,
as propriedades de variáveis de modelo (como declarado por <code>put</code> e funções relacionadas) são globais.
</p>
<p>A regra construída por <code>tellsimpafter</code> é nomeada após o operador principal de <code>modelo</code>.
Regras para operadores internos, 
e operadores definidos pelo utilizador 
definidos por meio de <code>infix</code>, <code>prefix</code>, <code>postfix</code>, <code>matchfix</code>, e <code>nofix</code>,
possuem nomes que são sequências de caracteres do Maxima.
Regras para outras funções possuem nomes que são identificadores comuns do Maxima.
</p>
<p>O tratamento de substantivos e formas verbais é desprezívelmente confuso. Se uma regra é definida para uma forma substantiva (ou verbal)
e uma regra para o verbo correspondente (ou substantivo) já existe, 
então a nova regra definida aplica-se a ambas as formas (substantiva e verbal).
Se uma regra para a correspondente forma verbal (ou substantiva) não existe,
a nova regra definida aplicar-se-á somente para a forma substantiva (ou verbal).
</p>
<p>A regra construída através de <code>tellsimpafter</code> é uma função Lisp comum.
Se o nome da regra for <code>$foorule1</code>,
a construção <code>:lisp (trace $foorule1)</code> rastreia a função,
e <code>:lisp (symbol-function '$foorule1</code> mostra sua definição.
</p>
<p><code>tellsimpafter</code> não avalia seus argumentos.
<code>tellsimpafter</code> retorna a lista de regras para o operador principal de <var>modelo</var>,
incluindo a mais recente regra estabelecia.
</p>
<p>Veja também <code>matchdeclare</code>, <code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>let</code>,
<code>kill</code>, <code>remrule</code>, e <code>clear_rules</code>.
</p>
<p>Exemplos:
</p>
<p><var>modelo</var> pode ser qualquer expressão não at&ocirc;mica na qual o 
principal operador não é uma variável de modelo.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre>
<p>Regras são aplicadas na ordem em que forem definidas.
Se duas regras podem coincidir com uma expressão,
a regra que foi primeiro definida é a que será aplicada.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre>
<p>variáveis de modelo são tratadas como variáveis locais em regras de simplificação.
(Compare a <code>defmatch</code>, que trata variáveis de modelo como variáveis globais.)
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre>
<p>Como com todos os átomos, propriedades de variáveis de modelo são globais embora valores sejam locais.
Nesse exemplo, uma propriedade de atribuição é declarada via <code>define_variable</code>.
Essa é a propriedade do átomo <code>bb</code> através de todo o Maxima.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
<p>Regras são nomeadas após operadores principais.
Nomes de regras para operadores internos e operadores definidos pelo utilizador são sequências de caracteres,
enquanto nomes para outras funções são identificadores comuns.
</p>
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4, 
htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1, 
foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
(%o10)                    [false, true]
(%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
(%o11)                    [true, true]
(%i12) remrule (foo, foorule1);
(%o12)                         foo
(%i13) remrule (&quot;^&quot;, &quot;^rule1&quot;);
(%o13)                          ^
</pre>
<p>Um exemplo trabalhado: multiplicação anticomutativa.
</p>
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>clear_rules</b><i> ()</i>
<a name="IDX1197"></a>
</dt>
<dd><p>Executa <code>kill (rules)</code> e então re-escolhe o próximo número de regra para 1
para adição <code>+</code>, multiplicação <code>*</code>, e exponenciação <code>^</code>.
</p>
</dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC145" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
