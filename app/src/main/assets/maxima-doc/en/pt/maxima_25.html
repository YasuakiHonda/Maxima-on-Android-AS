<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima 5.41.0: 25. Matrizes e Álgebra Linear</title>

<meta name="description" content="Manual do Maxima 5.41.0: 25. Matrizes e Álgebra Linear">
<meta name="keywords" content="Manual do Maxima 5.41.0: 25. Matrizes e Álgebra Linear">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Matrizes-e-_00c1lgebra-Linear"></a>
<a name="SEC80"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC79" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC78" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Matrizes e Álgebra Linear </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC81">25.1 Introdução a Matrizes e Álgebra Linear</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC85">25.2 Definições para Matrizes e Álgebra Linear</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Matrizes-e-_00c1lgebra-Linear"></a>
<a name="SEC81"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC80" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Introdução a Matrizes e Álgebra Linear </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC82">25.1.1 Ponto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC83">25.1.2 Vetores</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC84">25.1.3 auto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Ponto"></a>
<a name="SEC82"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC83" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Ponto </h3>
<p>O operador <code>.</code> representa multiplicação não comutativa e produto escalar.
Quando os operandos são matrizes 1-coluna ou 1-linha <code>a</code> e <code>b</code>,
a expresão <code>a.b</code> é equivalente a <code>sum (a[i]*b[i], i, 1, length(a))</code>.
Se <code>a</code> e <code>b</code> não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de <code>a</code> e <code>b</code>.
O produto escalar é definido como <code>conjugate(a).b</code> quando <code>a</code> e <code>b</code> são complexos;
<code>innerproduct</code> no pacote <code>eigen</code> fornece o produto escalar complexo.
</p>
<p>Quando os operandos são matrizes mais gerais,
o produto é a matriz produto <code>a</code> e <code>b</code>.
O número de linhas de <code>b</code> deve ser igual ao número de colunas de <code>a</code>,
e o resultado tem número de linhas igual ao número de linhas de <code>a</code>
e número de colunas igual ao número de colunas de <code>b</code>.
</p>
<p>Para distinguir <code>.</code> como um operador aritmético do 
ponto decimal em um número em ponto flutuante,
pode ser necessário deixar espaços em cada lado.
Por exemplo, <code>5.e3</code> é <code>5000.0</code> mas <code>5 . e3</code> é <code>5</code> vezes <code>e3</code>.
</p>
<p>Existem muitos sinalizadores que governam a simplificação de
expresões envolvendo <code>.</code>, a saber
<code>dot</code>, <code>dot0nscsimp</code>, <code>dot0simp</code>, <code>dot1simp</code>, <code>dotassoc</code>, 
<code>dotconstrules</code>, <code>dotdistrib</code>, <code>dotexptsimp</code>, <code>dotident</code>,
e <code>dotscrules</code>.
</p>
<hr size="6">
<a name="Vetores"></a>
<a name="SEC83"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC82" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Vetores </h3>
<p><code>vect</code> é um pacote de funções para análise vectorial.
<code>load (&quot;vect&quot;)</code> chama esse pacote, e <code>demo (&quot;vect&quot;)</code> permite visualizar uma demonstração.
</p>
<p>O pacote de análise vectorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente com
o gradiente, divergencia, torção, e operadores Laplacianos.  A 
distribuição desses operadores sobre adições ou produtos é governada
por muitos sinalizadores, como são várias outras expansões, incluindo expansão
dentro de componentes em qualquer sistema de coordenadas ortogonais.
Existem também funções para derivar o escalar ou vector potencial
de um campo.
</p>
<p>O pacote <code>vect</code> contém essas funções:
<code>vectorsimp</code>, <code>scalefactors</code>,
<code>express</code>, <code>potential</code>, e <code>vectorpotential</code>.
</p>
<p>Atenção: o pacote <code>vect</code> declara o operador ponto <code>.</code>
como sendo um operador comutativo.
</p>
<hr size="6">
<a name="auto"></a>
<a name="SEC84"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC83" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.3 auto </h3>

<p>O pacote <code>eigen</code> contém muitas funções devotadas para a
computação simbólica de autovalores e autovectores.
Maxima chama o pacote automaticamente se uma das funções
<code>eigenvalues</code> ou <code>eigenvectors</code> é invocada.
O pacote pode ser chamado explicitamente com <code>load (&quot;eigen&quot;)</code>.
</p>
<p><code>demo (&quot;eigen&quot;)</code> mostra uma demonstração das compatibilidades
desse pacote.
<code>batch (&quot;eigen&quot;)</code> executa a mesma demonstração,
mas sem lembretes de utilizador entre sucessivas computações.
</p>
<p>As funções no pacote <code>eigen</code> são
<code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code>,
<code>gramschmidt</code>, <code>eigenvalues</code>, <code>eigenvectors</code>, <code>uniteigenvectors</code>,
e <code>similaritytransform</code>.
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-Matrizes-e-_00c1lgebra-Linear"></a>
<a name="SEC85"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC84" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Definições para Matrizes e Álgebra Linear </h2>

<dl>
<dt><u>Função:</u> <b>addcol</b><i> (<var>M</var>, <var>list_1</var>, ..., <var>list_n</var>)</i>
<a name="IDX747"></a>
</dt>
<dd><p>Anexa a(s) coluna(s) dadas por uma
ou mais listas (ou matrizes) sobre a matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>addrow</b><i> (<var>M</var>, <var>list_1</var>, ..., <var>list_n</var>)</i>
<a name="IDX748"></a>
</dt>
<dd><p>Anexa a(s) linha(s) dadas por uma ou
mais listas (ou matrizes) sobre a matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>adjoint</b><i> (<var>M</var>)</i>
<a name="IDX749"></a>
</dt>
<dd><p>Retorna a matriz adjunta da matriz <var>M</var>.
A matriz adjunta é a transposta da matriz dos cofactores de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>augcoefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX750"></a>
</dt>
<dd><p>Retorna a matriz dos coeficientes
aumentada para as variáveis <var>x_1</var>, ..., <var>x_n</var> do sistema de equações lineares
<var>eqn_1</var>, ..., <var>eqn_m</var>.  Essa é a matriz dos coeficientes com uma coluna anexada para
os termos independentes em cada equação (i.e., esses termos não dependem de
<var>x_1</var>, ..., <var>x_n</var>).
</p>
<pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>charpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX751"></a>
</dt>
<dd><p>Retorna um polinómio característico para a matriz <var>M</var>
em relação à variável <var>x</var>.  Que é,
<code>determinant (<var>M</var> - diagmatrix (length (<var>M</var>), <var>x</var>))</code>.
</p>
<pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>coefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX752"></a>
</dt>
<dd><p>Retorna a matriz dos coeficientes para as
variáveis <var>x_1</var>, ..., <var>x_n</var> do sistema de equações lineares
<var>eqn_1</var>, ..., <var>eqn_m</var>.
</p>
<pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>col</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX753"></a>
</dt>
<dd><p>Reorna a <var>i</var>'ésima coluna da matriz <var>M</var>.
O valor de retorno é uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>columnvector</b><i> (<var>L</var>)</i>
<a name="IDX754"></a>
</dt>
<dt><u>Função:</u> <b>covect</b><i> (<var>L</var>)</i>
<a name="IDX755"></a>
</dt>
<dd><p>Retorna uma matriz de uma coluna e <code>length (<var>L</var>)</code> linhas,
contendo os elementos da lista <var>L</var>.
</p>
<p><code>covect</code> é um sin&ocirc;nimo para <code>columnvector</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p>Isso é útil se quiser usar partes das saídas das
funções nesse pacote em cálculos matriciais.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovectores
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>conjugate</b><i> (<var>x</var>)</i>
<a name="IDX756"></a>
</dt>
<dd><p>Retorna o conjugado complexo de <var>x</var>.
</p>
<pre class="example">(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>copymatrix</b><i> (<var>M</var>)</i>
<a name="IDX757"></a>
</dt>
<dd><p>Retorna uma cópia da matriz <var>M</var>.  Esse é o único
para fazer uma copia separada copiando <var>M</var> elemento a elemento.
</p>
<p>Note que uma atribuição de uma matriz para outra, como em <code>m2: m1</code>,
não copia <code>m1</code>.
Uma atribuição <code>m2 [i,j]: x</code> ou <code>setelmx (x, i, j, m2</code> também modifica <code>m1 [i,j]</code>.
criando uma cópia com <code>copymatrix</code> e então usando atribução cria uma separada e modificada cópia.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>determinant</b><i> (<var>M</var>)</i>
<a name="IDX758"></a>
</dt>
<dd><p>Calcula o determinante de <var>M</var> por um método similar à
eliminação de Gauss.
</p>
<p>A forma do resultado depende da escolha
do comutador <code>ratmx</code>.
</p>
<p>Existe uma rotina especial para calcular
determinantes esparsos que é chamada quando os comutadores
<code>ratmx</code> e <code>sparse</code> são ambos <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável:</u> <b>detout</b>
<a name="IDX759"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>detout</code> é <code>true</code>, o determinante de uma
matriz cuja inversa é calculada é factorado fora da inversa.
</p>
<p>Para esse comutador ter efeito <code>doallmxops</code> e <code>doscmxops</code> deveram ambos serem
<code>false</code> (veja suas transcrições).  Alternativamente esses comutadores podem ser
dados para <code>ev</code> o que faz com que os outros dois sejam escolhidos correctamente.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>diagmatrix</b><i> (<var>n</var>, <var>x</var>)</i>
<a name="IDX760"></a>
</dt>
<dd><p>Retorna uma matriz diagonal de tamanho <var>n</var> por <var>n</var> com os
elementos da diagonal todos iguais a <var>x</var>.
<code>diagmatrix (<var>n</var>, 1)</code> retorna uma matriz identidade (o mesmo que <code>ident (<var>n</var>)</code>).
</p>
<p><var>n</var> deve avaliar para um inteiro, de outra forma <code>diagmatrix</code> reclama com uma mensagem de erro.
</p>
<p><var>x</var> pode ser qualquer tipo de expresão, incluindo outra matriz.
Se <var>x</var> é uma matriz, isso não é copiado; todos os elementos da diagonal referem-se à mesma instância, <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Variável:</u> <b>doallmxops</b>
<a name="IDX761"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>doallmxops</code> é <code>true</code>,
todas as operações relacionadas a matrizes são realizadas.
Quando isso é <code>false</code> então a escolha de
comutadores individuais <code>dot</code> governam quais operações são executadas.
</p>
</dd></dl>

<dl>
<dt><u>Variável:</u> <b>domxexpt</b>
<a name="IDX762"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>domxexpt</code> é <code>true</code>,
uma matriz exponencial, <code>exp (<var>M</var>)</code> onde <var>M</var> é a matriz,
é interpretada como uma matriz com elementos <code>[i,j</code> iguais a <code>exp (m[i,j])</code>.
de outra forma <code>exp (<var>M</var>)</code> avalia para <code>exp (<var>ev(M)</var></code>.
</p>
<p><code>domxexpt</code>
afecta todas as expresões da forma <code><var>base</var>^<var>expoente</var></code> onde <var>base</var> é uma
expresão assumida escalar ou constante, e <var>expoente</var> é uma lista ou
matriz.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>domxmxops</b>
<a name="IDX763"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>domxmxops</code> é <code>true</code>, todas as operações matriz-matriz ou
matriz-lista são realizadas (mas não operações
escalar-matriz); se esse comutador é <code>false</code> tais operações não são.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>domxnctimes</b>
<a name="IDX764"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>domxnctimes</code> é <code>true</code>, produtos não comutativos de
matrizes são realizados.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dontfactor</b>
<a name="IDX765"></a>
</dt>
<dd><p>Valor por omissão: <code>[]</code>
</p>
<p><code>dontfactor</code> pode ser escolhido para uma lista de variáveis em relação
a qual factoração não é para ocorrer.  (A lista é inicialmente vazia.)
Factoração também não pegará lugares com relação a quaisquer variáveis que
são menos importantes, conforme a hierarquía de variável assumida para a forma expresão racional canónica (CRE),
que essas na lista <code>dontfactor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>doscmxops</b>
<a name="IDX766"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>doscmxops</code> é <code>true</code>, operações escalar-matriz são
realizadas.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>doscmxplus</b>
<a name="IDX767"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>doscmxplus</code> é <code>true</code>, operações escalar-matriz retornam
uma matriz resultado.  Esse comutador não é subsomado sob <code>doallmxops</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dot0nscsimp</b>
<a name="IDX768"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dot0nscsimp</code> é <code>true</code>, um produto não comutativo de zero
e um termo não escalar é simplificado para um produto comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dot0simp</b>
<a name="IDX769"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dot0simp</code> é <code>true</code>,
um produto não comutativo de zero e
um termo escalar é simplificado para um produto não comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dot1simp</b>
<a name="IDX770"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dot1simp</code> é <code>true</code>,
um produto não comutativo de um e
outro termo é simplificado para um produto comutativo.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotassoc</b>
<a name="IDX771"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dotassoc</code> é <code>true</code>, uma expresão <code>(A.B).C</code> simplifica para
<code>A.(B.C)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotconstrules</b>
<a name="IDX772"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dotconstrules</code> é <code>true</code>, um produto não comutativo de uma
constante e outro termo é simplificado para um produto comutativo.
Ativando esse sinalizador efectivamente activamos <code>dot0simp</code>, <code>dot0nscsimp</code>, e
<code>dot1simp</code> também.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotdistrib</b>
<a name="IDX773"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>dotdistrib</code> é <code>true</code>, uma expresão <code>A.(B + C)</code> simplifica para <code>A.B + A.C</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotexptsimp</b>
<a name="IDX774"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>dotexptsimp</code> é <code>true</code>, uma expresão <code>A.A</code> simplifica para <code>A^^2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotident</b>
<a name="IDX775"></a>
</dt>
<dd><p>Valor por omissão: 1
</p>
<p><code>dotident</code> é o valor retornado por <code>X^^0</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>dotscrules</b>
<a name="IDX776"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>dotscrules</code> é <code>true</code>, uma expresão <code>A.SC</code> ou <code>SC.A</code> simplifica
para <code>SC*A</code> e <code>A.(SC*B)</code> simplifica para <code>SC*(A.B)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>echelon</b><i> (<var>M</var>)</i>
<a name="IDX777"></a>
</dt>
<dd><p>Retorna a forma escalonada da matriz <var>M</var>,
como produzido através da eliminação de Gauss.
A forma escalonada é calculada de <var>M</var>
por operações elementares de linha tais que o primeiro
elemento não zero em cada linha na matriz resultante seja o número um e os
elementos da coluna abaixo do primeiro número um em cada linha sejam todos zero.
</p>
<p><code>triangularize</code> também realiza eliminação de Gaussian,
mas não normaliza o elemento líder não nulo em cada linha.
</p>
<p><code>lu_factor</code> e <code>cholesky</code> são outras funções que retornam matrizes triangularizadas.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>eigenvalues</b><i> (<var>M</var>)</i>
<a name="IDX778"></a>
</dt>
<dt><u>Função:</u> <b>eivals</b><i> (<var>M</var>)</i>
<a name="IDX779"></a>
</dt>
<dd><p>Retorna uma lista de duas listas contendo os autovalores da matriz <var>M</var>.
A primeira sublista do valor de retorno é a lista de autovalores da
matriz, e a segunda sublista é a lista de
multiplicidade dos autovalores na ordem correspondente.
</p>
<p><code>eivals</code> é um sin&ocirc;nimo de <code>eigenvalues</code>.
</p>
<p><code>eigenvalues</code> chama a função <code>solve</code> para achar as raízes do
polinómio característico da matriz.
Algumas vezes <code>solve</code> pode não estar habilitado a achar as raízes do polinómio;
nesse caso algumas outras funções nesse
pacote (except <code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code> e
<code>gramschmidt</code>) não irão trabalhar.
</p>
<p>Em alguns casos os autovalores achados por <code>solve</code> podem ser expresões complicadas.
(Isso pode acontecer quando <code>solve</code> retorna uma expresão real não trivial
para um autovalor que é sabidamente real.)
Isso pode ser possível para simplificar os autovalores usando algumas outras funções.
</p>
<p>O pacote <code>eigen.mac</code> é chamado automaticamente quando
<code>eigenvalues</code> ou <code>eigenvectors</code> é referenciado.
Se <code>eigen.mac</code> não tiver sido ainda chamado,
<code>load (&quot;eigen&quot;)</code> chama-o.
Após ser chamado, todas as funções e variáveis no pacote estarão disponíveis.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>eigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX780"></a>
</dt>
<dt><u>Função:</u> <b>eivects</b><i> (<var>M</var>)</i>
<a name="IDX781"></a>
</dt>
<dd><p>pegam uma matriz <var>M</var> como seu argumento e retorna uma lista
de listas cuja primeira sublista é a saída de <code>eigenvalues</code>
e as outras sublistas são os autovectores da
matriz correspondente para esses autovalores respectivamente.
</p>
<p><code>eivects</code> é um sin&ocirc;nimo para <code>eigenvectors</code>.
</p>
<p>O pacote <code>eigen.mac</code> é chamado automaticamente quando
<code>eigenvalues</code> ou <code>eigenvectors</code> é referenciado.
Se <code>eigen.mac</code> não tiver sido ainda chamado,
<code>load (&quot;eigen&quot;)</code> chama-o.
Após ser chamado, todas as funções e variáveis no pacote estarão disponíveis.
</p>
<p>Os sinalizadores que afectam essa função são:
</p>
<p><code>nondiagonalizable</code> é escolhido para <code>true</code> ou <code>false</code> dependendo de
se a matriz é não diagonalizável ou diagonalizável após o
retorno de <code>eigenvectors</code>.
</p>
<p><code>hermitianmatrix</code> quando <code>true</code>, faz com que os autovectores
degenerados da matriz Hermitiana sejam ortogonalizados usando o
algoritmo de Gram-Schmidt.
</p>
<p><code>knowneigvals</code> quando <code>true</code> faz com que o pacote <code>eigen</code> assumir que os
autovalores da matriz são conhecidos para o utilizador e armazenados sob o
nome global <code>listeigvals</code>.  <code>listeigvals</code> poderá ser escolhido para uma lista similar
à saída de <code>eigenvalues</code>.
</p>
<p>A função <code>algsys</code> é usada aqui para resolver em relação aos autovectores.  Algumas vezes se os
autovalores estão ausêntes, <code>algsys</code> pode não estar habilitado a achar uma solução.
Em alguns casos, isso pode ser possível para simplificar os autovalores por
primeiro achando e então usando o comando <code>eigenvalues</code> e então usando outras funções
para reduzir os autovalores a alguma coisa mais simples.
Continuando a simplificação, <code>eigenvectors</code> pode ser chamada novamente
com o sinalizador <code>knowneigvals</code> escolhido para <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ematrix</b><i> (<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX782"></a>
</dt>
<dd><p>Retorna uma matriz <var>m</var> por <var>n</var>, todos os elementos da qual
são zero excepto para o elemento <code>[<var>i</var>, <var>j</var>]</code> que é <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>entermatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX783"></a>
</dt>
<dd><p>Retorna uma matriz <var>m</var> por <var>n</var>, lendo os elementos interativamente.
</p>
<p>Se <var>n</var> é igual a <var>m</var>,
Maxima pergunta pelo tipo de matriz (diagonal, simétrica, antisimétrica, ou genérica)
e por cada elemento.
Cada resposta é terminada por um ponto e vírgula <code>;</code> ou sinal de dólar <code>$</code>.
</p>
<p>Se <var>n</var> não é igual a <var>m</var>,
Maxima pergunta por cada elemento.
</p>
<p>Os elementos podem ser quaisquer expressões, que são avaliadas.
<code>entermatrix</code> avalia seus argumentos.
</p>
<pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matriz entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</i>
<a name="IDX784"></a>
</dt>
<dt><u>Função:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</i>
<a name="IDX785"></a>
</dt>
<dt><u>Função:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>)</i>
<a name="IDX786"></a>
</dt>
<dd><p>Retorna uma matriz gerada de <var>a</var>,
pegando o elemento <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code>
como o elemento do canto superior esquerdo e <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code>
como o elemento do canto inferior directo da matriz.
Aqui <var>a</var> é um array declarado (criado através de <code>array</code> mas não por meio de <code>make_array</code>)
ou um array não declarado,
ou uma função array,
ou uma expressão lambda de dois argumentos.
(Uma funçãO array é criado como outras funções com <code>:=</code> ou <code>define</code>,
mas os argumentos são colocados entre colchêtes em lugar de parêntesis.)
</p>
<p>Se <var>j_1</var> é omitido, isso é assumido ser igual a <var>i_1</var>.
Se ambos <var>j_1</var> e <var>i_1</var> são omitidos, ambos são assumidos iguais a 1.
</p>
<p>Se um elemento seleccionado <code>i,j</code> de um array for indefinido,
a matriz conterá um elemento simbólico <code><var>a</var>[i,j]</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>gramschmidt</b><i> (<var>x</var>)</i>
<a name="IDX787"></a>
</dt>
<dt><u>Função:</u> <b>gschmit</b><i> (<var>x</var>)</i>
<a name="IDX788"></a>
</dt>
<dd><p>Realiza o algoritmo de ortonalização de Gram-Schmidt sobre <var>x</var>,
seja ela uma matriz ou uma lista de listas.
<var>x</var> não é modificado por <code>gramschmidt</code>.
</p>
<p>Se <var>x</var> é uma matriz, o algoritmo é aplicado para as linhas de <var>x</var>.
Se <var>x</var> é uma lista de listas, o algoritmo é aplicado às sublistas,
que devem ter igual números de elementos.
Nos dois casos,
o valor de retorno é uma lista de listas, as sublistas das listas são ortogonais
e gera o mesmo spaço que <var>x</var>.
Se a dimensão do conjunto gerador de <var>x</var> é menor que o número de linhas ou sublistas,
algumas sublistas do valor de retorno são zero.
</p>
<p><code>factor</code> é chamada a cada estágio do algoritmo para simplificar resultados intermédios.
Como uma consequência, o valor de retorno pode conter inteiros factorados.
</p>
<p><code>gschmit</code> (nota ortográfica) é um sin&ocirc;nimo para <code>gramschmidt</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovectores
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ident</b><i> (<var>n</var>)</i>
<a name="IDX789"></a>
</dt>
<dd><p>Retorna uma matriz identidade <var>n</var> por <var>n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>innerproduct</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX790"></a>
</dt>
<dt><u>Função:</u> <b>inprod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX791"></a>
</dt>
<dd><p>Retorna o produto interno (também chamado produto escalar ou produto do ponto) de <var>x</var> e <var>y</var>,
que são listas de igual comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual comprimento.
O valor de retorno é <code>conjugate (x) . y</code>,
onde <code>.</code> é o operador de multiplicação não comutativa.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p><code>inprod</code> é um sin&ocirc;nimo para <code>innerproduct</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>invert</b><i> (<var>M</var>)</i>
<a name="IDX792"></a>
</dt>
<dd><p>Retorna a inversa da matriz <var>M</var>.
A inversa é calculada pelo método adjunto.
</p>
<p>Isso permite a um utilizador calcular a inversa de uma matriz com
entradas bfloat ou polinómios com coeficientes em ponto flutuante sem
converter para a forma CRE.
</p>
<p>Cofactores são calculados pela função  <code>determinant</code>,
então se <code>ratmx</code> é <code>false</code> a inversa é calculada
sem mudar a representação dos elementos.
</p>
<p>A implementação
corrente é ineficiente para matrizes de alta ordem.
</p>
<p>Quando <code>detout</code> é <code>true</code>, o determinante é factorado fora da
inversa.
</p>
<p>Os elementos da inversa não são automaticamente expandidos.
Se <var>M</var> tem elementos polinomiais, melhor aparência de saída pode ser
gerada por <code>expand (invert (m)), detout</code>.
Se isso é desejável para ela
divisão até pelo determinante pode ser excelente por <code>xthru (%)</code>
ou alternativamente na unha por
</p>
<pre class="example">expe (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
</pre>
<p>Veja <code>^^</code> (expoente não comutativo) para outro método de inverter uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>lmxchar</b>
<a name="IDX793"></a>
</dt>
<dd><p>Valor por omissão: <code>[</code>
</p>
<p><code>lmxchar</code> é o caractere mostrado como o delimitador
esquerdo de uma matriz.
Veja também <code>rmxchar</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>matrix</b><i> (<var>row_1</var>, ..., <var>row_n</var>)</i>
<a name="IDX794"></a>
</dt>
<dd><p>Retorna uma matriz retangular que tem as linhas <var>row_1</var>, ..., <var>row_n</var>.
Cada linha é uma lista de expressões.
Todas as linhas devem ter o mesmo comprimento.
</p>
<p>As operações <code>+</code> (adição), <code>-</code> (subtração), <code>*</code> (multiplicação),
e <code>/</code> (divisão), são realizadas elemento por elemento
quando os operandos são duas matrizes, um escalar e uma matriz, ou uma matriz e um escalar.
A operação <code>^</code> (exponenciação, equivalentemente <code>**</code>)
é realizada elemento por elemento
se os operandos são um escalar e uma matriz ou uma matriz e um escalar,
mas não se os operandos forem duas matrizes.
Todos as operações são normalmente realizadas de forma completa,
incluindo <code>.</code> (multiplicação não comutativa).
</p>
<p>Multiplicação de matrizes é representada pelo operador de multiplicação não comutativa <code>.</code>.
O correspondente operador de exponenciação não comutativa é <code>^^</code>.
Para uma matriz <code><var>A</var></code>, <code><var>A</var>.<var>A</var> = <var>A</var>^^2</code> e
<code><var>A</var>^^-1</code> é a inversa de <var>A</var>, se existir.
</p>
<p>Existem comutadores para controlar a simplificação de expresões
envolvendo operações escalar e matriz-lista.
São eles
<code>doallmxops</code>, <code>domxexpt</code>
<code>domxmxops</code>, <code>doscmxops</code>, e <code>doscmxplus</code>.
</p>
<p>Existem opções adicionais que são relacionadas a matrizes.  São elas:
<code>lmxchar</code>, <code>rmxchar</code>, <code>ratmx</code>, <code>listarith</code>, <code>detout</code>,
<code>scalarmatrix</code>,
e <code>sparse</code>.
</p>
<p>Existe um número de
funções que pegam matrizes como argumentos ou devolvem matrizes como valor de retorno.
Veja <code>eigenvalues</code>, <code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, <code>genmatrix</code>, <code>addcol</code>, <code>addrow</code>, 
<code>copymatrix</code>, <code>transpose</code>, <code>echelon</code>,
e <code>rank</code>.
</p>
<p>Exemplos:
</p>
<ul>
<li>
Construção de matrizes de listas.
</li></ul>
<pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre><ul>
<li>
Adição, elemento por elemento.
</li></ul>
<pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre><ul>
<li>
Subtração, elemento por elemento.
</li></ul>
<pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre><ul>
<li>
Multiplicação, elemento por elemento.
</li></ul>
<pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre><ul>
<li>
Divisão, elemento por elemento.
</li></ul>
<pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre><ul>
<li>
Matriz para um expoente escalar, elemento por elemento.
</li></ul>
<pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre><ul>
<li>
Base escalar para um expoente matriz, elemento por elemento.
</li></ul>
<pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
Base matriz para um expoente matriz.  Essa não é realizada elemento por elemento.
</li></ul>
<pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre><ul>
<li>
Multiplicação não comutativa de matrizes.
</li></ul>
<pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre><ul>
<li>
Exponenciação não comutativa de matrizes.
Uma base escalar <var>b</var> para uma potência matriz <var>M</var>
é realizada elemento por elemento e então <code>b^^m</code> é o mesmo que <code>b^m</code>.
</li></ul>
<pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
A matriz elevada a um expoente -1 com exponenciação não comutativa é a matriz inversa,
se existir.
</li></ul>
<pre class="example">(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>matrixmap</b><i> (<var>f</var>, <var>M</var>)</i>
<a name="IDX795"></a>
</dt>
<dd><p>Retorna uma matriz com elemento <code>i,j</code> igual a <code><var>f</var>(<var>M</var>[i,j])</code>.
</p>
<p>Veja também <code>map</code>, <code>fullmap</code>, <code>fullmapl</code>, e <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>matrixp</b><i> (<var>expr</var>)</i>
<a name="IDX796"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> é uma matriz, de outra forma retorna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>matrix_element_add</b>
<a name="IDX797"></a>
</dt>
<dd><p>Valor por omissão: <code>+</code>
</p>
<p><code>matrix_element_add</code> é a operação 
invocada em lugar da adição em uma multiplicação de matrizes.
A <code>matrix_element_add</code> pode ser atribuído qualquer operador n-ário
(que é, uma função que manuseia qualquer número de argumentos).
Os valores atribuídos podem ser o nome de um operador entre aspas duplas,
o nome da função,
ou uma expressão lambda.
</p>
<p>Veja também <code>matrix_element_mult</code> e <code>matrix_element_transpose</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>matrix_element_mult</b>
<a name="IDX798"></a>
</dt>
<dd><p>Valor por omissão: <code>*</code>
</p>
<p><code>matrix_element_mult</code> é a operação
invocada em lugar da multiplicação em uma multiplicação de matrizes.
A <code>matrix_element_mult</code> pode ser atribuído qualquer operador binário.
O valor atribuído pode ser o nome de um operador entre aspas duplas,
o nome de uma função,
ou uma expressão lambda.
</p>
<p>O operador do ponto <code>.</code> é uma escolha útil em alguns contextos.
</p>
<p>Veja também <code>matrix_element_add</code> e <code>matrix_element_transpose</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>matrix_element_transpose</b>
<a name="IDX799"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p><code>matrix_element_transpose</code> é a operação
aplicada a cada elemento de uma matriz quando for uma transposta.
A <code>matrix_element_mult</code> pode ser atribuído qualquer operador unário.
O valor atribuído pode ser  nome de um operador entre aspas duplas,
o nome de uma função,
ou uma expressão lambda.
</p>
<p>Quando <code>matrix_element_transpose</code> for igual a <code>transpose</code>,
a função  <code>transpose</code> é aplicada a todo elemento.
Quando <code>matrix_element_transpose</code> for igual a <code>nonscalars</code>,
a função <code>transpose</code> é aplicada a todo elemento não escalar.
Se algum elemento é um átomo, a opção <code>nonscalars</code> aplica
<code>transpose</code> somente se o átomo for declarado não escalar,
enquanto a opção <code>transpose</code> sempre aplica <code>transpose</code>.
</p>
<p>O valor padrão, <code>false</code>, significa nenhuma operação é aplicada.
</p>
<p>Veja também <code>matrix_element_add</code> e <code>matrix_element_mult</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>mattrace</b><i> (<var>M</var>)</i>
<a name="IDX800"></a>
</dt>
<dd><p>Retorna o traço (que é, a soma dos elementos sobre a diagonal principal) da
matriz quadrada <var>M</var>.  
</p>
<p><code>mattrace</code> é chamada por <code>ncharpoly</code>,
uma alternativa para <code>charpoly</code> do Maxima.
</p>
<p><code>load (&quot;nchrpl&quot;)</code> chama essa função.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>minor</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX801"></a>
</dt>
<dd><p>Retorna o <var>i</var>, <var>j</var> menor do elemento localizado na linha <var>i</var> coluna <var>j</var> da matriz <var>M</var>.  Que é <var>M</var>
com linha <var>i</var> e coluna <var>j</var> ambas removidas.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ncexpt</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX802"></a>
</dt>
<dd><p>Se uma expressão exponencial não comutativa é muito
alta para ser mostrada como <code><var>a</var>^^<var>b</var></code> aparecerá como <code>ncexpt (<var>a</var>,<var>b</var>)</code>.
</p>
<p><code>ncexpt</code> não é o nome de uma função ou operador;
o nome somente aparece em saídas, e não é reconhecido em entradas.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ncharpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX803"></a>
</dt>
<dd><p>Retorna o polinómio característico da matriz <var>M</var>
com relação a <var>x</var>.  Essa é uma alternativa para <code>charpoly</code> do Maxima.
</p>
<p><code>ncharpoly</code> trabalha pelo cálculo dos traços das potências na dada matriz,
que são sabidos serem iguais a somas de potências das raízes do
polinómio característico.  Para essas quantidade a função
simétrica das raízes pode ser calculada, que nada mais são que
os coeficientes do polinómio característico.  <code>charpoly</code> trabalha
formatando o determinante de <code><var>x</var> * ident [n] - a</code>.  Dessa forma <code>ncharpoly</code> é vencedor,
por exemplo, no caso de largas e densas matrizes preencidas com inteiros,
desde que isso evite inteiramente a aritmética polinomial.
</p>
<p><code>load (&quot;nchrpl&quot;)</code> loads this file.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>newdet</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX804"></a>
</dt>
<dd><p>Calcula o determinante de uma matriz ou array <var>M</var> pelo
algoritmo da árvore menor de Johnson-Gentleman.
O argumento <var>n</var> é a ordem; isso é opcional se <var>M</var> for uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Declaração:</u> <b>nonscalar</b>
<a name="IDX805"></a>
</dt>
<dd><p>Faz átomos ser comportarem da mesma forma que uma lista ou matriz em relação ao
operador do ponto.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>nonscalarp</b><i> (<var>expr</var>)</i>
<a name="IDX806"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> é um não escalar, i.e., isso contém
átomos declarados como não escalares, listas, ou matrizes.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>permanent</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX807"></a>
</dt>
<dd><p>Calcula o permanente da matriz <var>M</var>.  Um permanente
é como um determinante mas sem mudança de sinal.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX808"></a>
</dt>
<dd><p>Calcula o posto da matriz <var>M</var>.  Que é, a ordem do
mais largo determinante não singular de <var>M</var>.
</p>
<p><var>rank</var> pode retornar uma
resposta ruim se não puder determinar que um elemento da matriz que é
equivalente a zero é realmente isso.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>ratmx</b>
<a name="IDX809"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>ratmx</code> é <code>false</code>, adição, subtração,
e multiplicação para determinantes e matrizes são executados na
representação dos elementos da matriz e fazem com que o resultado da
inversão de matrizes seja esquerdo na representação geral.
</p>
<p>Quando <code>ratmx</code> é <code>true</code>,
as 4 operações mencionadas acima são executadas na forma CRE e o
resultado da matriz inversa é dado na forma CRE.  Note isso pode
fazer com que os elementos sejam expandidos (dependendo da escolha de <code>ratfac</code>)
o que pode não ser desejado sempre.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>row</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX810"></a>
</dt>
<dd><p>retorna a <var>i</var>'ésima linha da matriz <var>M</var>.
O valor de retorno é uma matriz.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>scalarmatrixp</b>
<a name="IDX811"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>scalarmatrixp</code> é <code>true</code>, então sempre que uma matriz 1 x 1
é produzida como um resultado de cálculos o produto do ponto de matrizes 
é simplificado para um escalar, a saber o elemento solitário da matriz.
</p>
<p>Quando <code>scalarmatrixp</code> é <code>all</code>,
então todas as matrizes 1 x 1 serão simplificadas para escalares.
</p>
<p>Quando <code>scalarmatrixp</code> é <code>false</code>, matrizes 1 x 1 não são simplificadas para escalares.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>scalefactors</b><i> (<var>coordinatetransform</var>)</i>
<a name="IDX812"></a>
</dt>
<dd><p>Aqui coordinatetransform
avalia para a forma [[expresão1, expresão2, ...],
indeterminação1, indeterminação2, ...], onde indeterminação1,
indeterminação2, etc.  são as variáveis de coordenadas curvilíneas e
onde a escolha de componentes cartesianas retangulares é dada em termos das
coordenadas curvilíneas por [expresão1, expresão2, ...].
<code>coordinates</code> é escolhida para o vector [indeterminação1, indeterminação2,...],
e <code>dimension</code> é escolhida para o comprimento desse vector.  SF[1], SF[2],
..., SF[DIMENSION] são escohidos para factores de escala de coordenada, e <code>sfprod</code>
é escohido para o produto desse factores de escala.  Inicialmente, <code>coordinates</code>
é [X, Y, Z], <code>dimension</code> é 3, e SF[1]=SF[2]=SF[3]=SFPROD=1,
correspondendo a coordenadas Cartesianas retangulares 3-dimensional.
Para expandir uma expresão dentro de componentes físicos no sistema de coordenadas
corrente , existe uma função com uso da forma
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>setelmx</b><i> (<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</i>
<a name="IDX813"></a>
</dt>
<dd><p>Atribue <var>x</var> para o (<var>i</var>, <var>j</var>)'ésimo elemento da matriz <var>M</var>,
e retorna a matriz alterada.
</p>
<p><code><var>M</var> [<var>i</var>, <var>j</var>]: <var>x</var></code> tem o mesmo efeito,
mas retorna <var>x</var> em lugar de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>similaritytransform</b><i> (<var>M</var>)</i>
<a name="IDX814"></a>
</dt>
<dt><u>Função:</u> <b>simtran</b><i> (<var>M</var>)</i>
<a name="IDX815"></a>
</dt>
<dd><p><code>similaritytransform</code> calcula uma transformação homotética da matriz <code>M</code>.
Isso retorna uma lista que é a saída do
comando <code>uniteigenvectors</code>.  Em adição se o sinalizador <code>nondiagonalizable</code>
é <code>false</code> duas matrizes globais <code>leftmatrix</code> e <code>rightmatrix</code> são calculadas.
Essas matrizes possuem a propriedade de
<code>leftmatrix . <var>M</var> . rightmatrix</code> é uma matriz diagonal com os autovalores
de <var>M</var> sobre a diagonal.  Se <code>nondiagonalizable</code> é <code>true</code> as matrizes esquerda e
direita não são computadas.
</p>
<p>Se o sinalizador <code>hermitianmatrix</code> é <code>true</code>
então <code>leftmatrix</code> é o conjugado complexo da transposta de
<code>rightmatrix</code>.  De outra forma <code>leftmatrix</code> é a inversa de <code>rightmatrix</code>.
</p>
<p><code>rightmatrix</code> é a matriz cujas colunas são os autovectores
unitários de <var>M</var>.  Os outros sinalizadores (veja <code>eigenvalues</code> e
<code>eigenvectors</code>) possuem o mesmo efeito desde que
<code>similaritytransform</code> chama as outras funções no pacote com o objectivo de
estar habilitado para a forma <code>rightmatrix</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p><code>simtran</code> é um sin&ocirc;nimo para <code>similaritytransform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>sparse</b>
<a name="IDX816"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>sparse</code> é <code>true</code>, e se <code>ratmx</code> é <code>true</code>, então <code>determinant</code>
usará rotinas especiais para calcular determinantes esparsos.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX817"></a>
</dt>
<dt><u>Função:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>)</i>
<a name="IDX818"></a>
</dt>
<dt><u>Função:</u> <b>submatrix</b><i> (<var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX819"></a>
</dt>
<dd><p>Retorna uma nova matriz formada pela
matrix <var>M</var> com linhas <var>i_1</var>, ..., <var>i_m</var> excluídas, e colunas <var>j_1</var>, ..., <var>j_n</var> excluídas.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>transpose</b><i> (<var>M</var>)</i>
<a name="IDX820"></a>
</dt>
<dd><p>Retorna a transposta de <var>M</var>.
</p>
<p>Se <var>M</var> é uma matriz, o valor de retorno é outra matriz <var>N</var>
tal que <code>N[i,j] = M[j,i]</code>.
</p>
<p>Se <var>M</var> for uma lista, o valor de retorno é uma matrix <var>N</var>
de <code>length (m)</code> linhas e 1 coluna, tal que <code>N[i,1] = M[i]</code>.
</p>
<p>De outra forma <var>M</var> é um símbolo,
e o valor de retorno é uma expressão substantiva <code>'transpose (<var>M</var>)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>triangularize</b><i> (<var>M</var>)</i>
<a name="IDX821"></a>
</dt>
<dd><p>Retorna a maior forma triangular da matriz <code>M</code>, como produzido através da eliminação de Gauss.
O valor de retorno é o mesmo que <code>echelon</code>,
excepto que o o coeficiente lider não nulo em cada linha não é normalizado para 1.
</p>
<p><code>lu_factor</code> e <code>cholesky</code> são outras funções que retornam matrizes triangularizadas.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>uniteigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX822"></a>
</dt>
<dt><u>Função:</u> <b>ueivects</b><i> (<var>M</var>)</i>
<a name="IDX823"></a>
</dt>
<dd><p>Calcula autovectores unitários da matriz <var>M</var>.
O valor de retorno é uma lista de listas, a primeiro sublista é a
saída do comando <code>eigenvalues</code>, e as outras sublistas são
os autovectores unitários da matriz correspondente a esses autovalores
respectivamente.
</p>
<p>Os sinalizadores mencionados na descrição do
comando <code>eigenvectors</code> possuem o mesmo efeito aqui também.
</p>
<p>Quando <code>knowneigvects</code> é <code>true</code>, o pacote <code>eigen</code> assume
que os autovectores da matriz são conhecidos para o utilizador são
armazenados sob o nome global <code>listeigvects</code>.  <code>listeigvects</code> pode ser ecolhido
para uma lista similar à saída do comando <code>eigenvectors</code>.
</p>
<p>Se <code>knowneigvects</code> é escolhido para <code>true</code> e a lista de autovectores é dada a
escolha do sinalizador <code>nondiagonalizable</code> pode não estar correcta.  Se esse é
o caso por favor ecolha isso para o valor correcto.  O autor assume que
o utilizador sabe o que está fazendo e que não tentará diagonalizar uma
matriz cujos autovectores não geram o mesmo espaço vectorial de
dimensão apropriada.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p><code>ueivects</code> é um sin&ocirc;nimo para <code>uniteigenvectors</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>unitvector</b><i> (<var>x</var>)</i>
<a name="IDX824"></a>
</dt>
<dt><u>Função:</u> <b>uvect</b><i> (<var>x</var>)</i>
<a name="IDX825"></a>
</dt>
<dd><p>Retorna <em><var>x</var>/norm(<var>x</var>)</em>;
isso é um vector unitário na mesma direção que <var>x</var>.
</p>
<p><code>load (&quot;eigen&quot;)</code> chama essa função.
</p>
<p><code>uvect</code> é um sin&ocirc;nimo para <code>unitvector</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>vectorsimp</b><i> (<var>expr</var>)</i>
<a name="IDX826"></a>
</dt>
<dd><p>Aplica simplificações e expansões conforme
os seguintes sinalizadores globais:
</p>
<p><code>expandall</code>, <code>expanddot</code>, <code>expanddotplus</code>, <code>expandcross</code>, <code>expandcrossplus</code>,
<code>expandcrosscross</code>, <code>expandgrad</code>, <code>expandgradplus</code>, <code>expandgradprod</code>,
<code>expanddiv</code>, <code>expanddivplus</code>, <code>expanddivprod</code>, <code>expandcurl</code>, <code>expandcurlplus</code>,
<code>expandcurlcurl</code>, <code>expandlaplacian</code>, <code>expandlaplacianplus</code>,
e <code>expandlaplacianprod</code>.
</p>
<p>Todos esses sinalizadores possuem valor padrão <code>false</code>.  O sufixo <code>plus</code> refere-se a
utilização aditivamente ou distribuitivamente.  O sufixo <code>prod</code> refere-se a
expansão para um operando que é qualquer tipo de produto.
</p>
<dl compact="compact">
<dt> <code>expandcrosscross</code></dt>
<dd><p>Simplifica <em>p ~ (q ~ r)</em> para <em>(p . r)*q - (p . q)*r</em>.
</p></dd>
<dt> <code>expandcurlcurl</code></dt>
<dd><p>Simplifica <em>curl curl p</em> para <em>grad div p + div grad p</em>.
</p></dd>
<dt> <code>expandlaplaciantodivgrad</code></dt>
<dd><p>Simplifica <em>laplacian p</em> para <em>div grad p</em>.
</p></dd>
<dt> <code>expandcross</code></dt>
<dd><p>Habilita <code>expandcrossplus</code> e <code>expandcrosscross</code>.
</p></dd>
<dt> <code>expandplus</code></dt>
<dd><p>Habilita <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code>, e <code>expandlaplacianplus</code>.
</p></dd>
<dt> <code>expandprod</code></dt>
<dd><p>Habilita <code>expandgradprod</code>, <code>expanddivprod</code>, e <code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>Esses sinalizadores foram todos declarados <code>evflag</code>.
</p>

</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>vect_cross</b>
<a name="IDX827"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>vect_cross</code> é <code>true</code>, isso permite DIFF(X~Y,T) trabalhar onde
~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para <code>true</code>, de qualqeur modo.)
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>zeromatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX828"></a>
</dt>
<dd><p>Retorna um matriz <var>m</var> por <var>n</var>, com todos os elementos sendo zero.
</p>
</dd></dl>

<dl>
<dt><u>Símbolo especial:</u> <b>[</b>
<a name="IDX829"></a>
</dt>
<dt><u>Símbolo especial:</u> <b>]</b>
<a name="IDX830"></a>
</dt>
<dd><p><code>[</code> e <code>]</code> marcam o omeço e o fim, respectivamente, de uma lista.
</p>
<p><code>[</code> e <code>]</code> também envolvem os subscritos de
uma lista, array, array desordenado, ou função array.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
</pre>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC80" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC86" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC272" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
