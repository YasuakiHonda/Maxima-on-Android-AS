<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 21. Equa&ccedil;&otilde;es</title>

<meta name="description" content="Manual do Maxima: 21. Equa&ccedil;&otilde;es">
<meta name="keywords" content="Manual do Maxima: 21. Equa&ccedil;&otilde;es">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Equa_00e7_00f5es"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_20.html#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 21. Equa&ccedil;&otilde;es </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC70">21.1 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Equa&ccedil;&otilde;es</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
</table>

<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Equa_00e7_00f5es"></a>
<a name="SEC70"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC69" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.1 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Equa&ccedil;&otilde;es </h2>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>%rnum_list</b>
<a name="IDX653"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>[]</code>
</p>
<p><code>%rnum_list</code> &eacute; a lista de vari&aacute;veis introduzidas em solu&ccedil;&otilde;es
por <code>algsys</code>.
<code>%r</code> vari&aacute;veis S&atilde;o adicionadas a <code>%rnum_list</code> na ordem em que
forem criadas.
Isso &eacute; conveniente para fazer substitui&ccedil;&otilde;es dentro da
solu&ccedil;&atilde;o mais tarde.
&Eacute; recomendado usar essa lista em lugar de
fazer <code>concat ('%r, j)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>algexact</b>
<a name="IDX654"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p><code>algexact</code> afeta o comportamento de <code>algsys</code> como segue:
</p>
<p>Se <code>algexact</code> &eacute; <code>true</code>,
<code>algsys</code> sempre chama <code>solve</code> e ent&atilde;o usa <code>realroots</code>
sobre falhas de <code>solve</code>.
</p>
<p>Se <code>algexact</code> &eacute; <code>false</code>, <code>solve</code> &eacute; chamada somente se
o eliminante n&atilde;o for de uma vari&aacute;vel, ou se for uma quadr&aacute;tica ou uma
biquadrada.
</p>
<p>Dessa forma <code>algexact: true</code> n&atilde;o garante somente solu&ccedil;&otilde;es
exatas, apenas que <code>algsys</code> tentar&aacute; primeiro pegar
solu&ccedil;&otilde;es exatas, e somente retorna aproxima&ccedil;&otilde;es quando tudo mais falha.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>algsys</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX655"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>algsys</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX656"></a>
</dt>
<dd><p>Resolve polin&ocirc;mios simult&acirc;neos <var>expr_1</var>, ..., <var>expr_m</var>
ou equa&ccedil;&otilde;es polin&ocirc;miais <var>eqn_1</var>, ..., <var>eqn_m</var>
para as vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var>.
Uma express&atilde;o <var>expr</var> &eacute; equivalente a uma equa&ccedil;&atilde;o <code><var>expr</var> = 0</code>.
Pode existir mais equa&ccedil;&otilde;es que vari&aacute;veis ou vice-versa.
</p>
<p><code>algsys</code> retorna uma lista de solu&ccedil;&otilde;es,
com cada solu&ccedil;&atilde;o dada com uma lista de valores de estado das equa&ccedil;&otilde;es
das vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var> que satisfazem o sistema de equa&ccedil;&otilde;es.
Se <code>algsys</code> n&atilde;o pode achar uma solu&ccedil;&atilde;o, uma lista vazia <code>[]</code> &eacute; retornada.
</p>
<p>Os s&iacute;mbolos <code>%r1</code>, <code>%r2</code>, ...,
s&atilde;o introduzidos tantos quantos forem necess&aacute;rios para representar par&acirc;metros arbitr&aacute;rios na solu&ccedil;&atilde;o;
essas vari&aacute;veis s&atilde;o tamb&eacute;m anexadas &agrave; lista <code>%rnum_list</code>.
</p>
<p>O m&eacute;todo usado &eacute; o seguinte:
</p>
<p>(1) Primeiro as equa&ccedil;&otilde;es s&atilde;o fatoradas e quebradas em subsistemas.
</p>
<p>(2) Para cada subsistema <var>S_i</var>, uma equa&ccedil;&atilde;o <var>E</var> e uma vari&aacute;vel <var>x</var> s&atilde;o
selecionados.
A vari&aacute;vel &eacute; escolhida para ter o menor grau n&atilde;o zero.
Ent&atilde;o a resultante de <var>E</var> e <var>E_j</var> em rela&ccedil;&atilde;o a <var>x</var> &eacute; calculada para cada um das
equa&ccedil;&otilde;es restantes <var>E_j</var> nos subsistemas <var>S_i</var>.
Isso retorna um novo subsistema <var>S_i'</var> em umas poucas vari&aacute;veis, como <var>x</var> tenha sido eliminada.
O processo agora retorna ao passo (1).
</p>
<p>(3) Eventualmente, um subsistema consistindo de uma equa&ccedil;&atilde;o simples &eacute;
obtido.  Se a equa&ccedil;&atilde;o &eacute; de v&aacute;rias vari&aacute;veis e aproxima&ccedil;&otilde;es na
forma de n&uacute;meros em ponto flutuante n&atilde; tenham sido introduzidas, ent&atilde;o <code>solve</code> &eacute;
chamada para achar uma solu&ccedil;&atilde;o exata.
</p>
<p>Em alguns casos, <code>solve</code> n&atilde;o est&aacute; habilitada a achar uma solu&ccedil;&atilde;o,
ou se isso &eacute; feito a solu&ccedil;&atilde;o pode ser uma express&atilde;o express&atilde;o muito larga.
</p>
<p>Se a equa&ccedil;&atilde;o &eacute; de uma &uacute;nica vari&aacute;vel e &eacute; ou linear, ou quadr&aacute;tica, ou
biquadrada, ent&atilde;o novamente <code>solve</code> &eacute; chamada se aproxima&ccedil;&otilde;es n&atilde;o tiverem
sido introduzidas.  Se aproxima&ccedil;&otilde;es tiverem sido introduzidas ou a
equa&ccedil;&atilde;o n&atilde;o &eacute; de uma &uacute;nica vari&aacute;vel e nem t&atilde;o pouco linear, quadratica, ou
biquadrada, ent&atilde;o o comutador <code>realonly</code> &eacute; <code>true</code>, A fun&ccedil;&atilde;o
<code>realroots</code> &eacute; chamada para achar o valor real das solu&ccedil;&otilde;es.  Se
<code>realonly</code> &eacute; <code>false</code>, ent&atilde;o <code>allroots</code> &eacute; chamada a qual procura por
solu&ccedil;&otilde;es reais e complexas.
</p>
<p>Se <code>algsys</code> produz uma solu&ccedil;&atilde;o que tem
poucos digitos significativos que o requerido, o usu&aacute;rio pode escolher o valor
de <code>algepsilon</code> para um valor maior.
</p>
<p>Se <code>algexact</code> &eacute; escolhido para
<code>true</code>, <code>solve</code> ser&aacute; sempre chamada.
</p>
<p>(4) Finalmente, as solu&ccedil;&otilde;es obtidas no passo (3) s&atilde;o substitu&iacute;das dentro
dos n&iacute;veis pr&eacute;vios e o processo de solu&ccedil;&atilde;o retorna para (1).
</p>
<p>Quando <code>algsys</code> encontrar uma equa&ccedil;&atilde;o de v&aacute;rias vari&aacute;veis que cont&eacute;m
aproxima&ccedil;&otilde;es em ponto flutuante (usualmente devido a suas falhas em achar
solu&ccedil;&otilde;es exatas por um est&aacute;gio mais f&aacute;cil), ent&atilde;o n&atilde;o tentar&aacute;
aplicar m&eacute;todos exatos para tais equa&ccedil;&otilde;es e em lugar disso imprime a mensagem:
&quot;<code>algsys</code> cannot solve - system too complicated.&quot;
</p>
<p>Intera&ccedil;&otilde;es com <code>radcan</code> podem produzir express&otilde;es largas ou
complicadas.
Naquele caso, pode ser poss&iacute;vel isolar partes do resultado
com <code>pickapart</code> ou <code>reveal</code>.
</p>
<p>Ocasionalmente, <code>radcan</code> pode introduzir uma unidade imagin&aacute;ria
<code>%i</code> dentro de uma solu&ccedil;&atilde;o que &eacute; atualmente avaliada como real.
</p>
<p>Exemplos:
</p>
<p>++</p><pre class="example">(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>allroots</b><i> (<var>expr</var>)</i>
<a name="IDX657"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>allroots</b><i> (<var>eqn</var>)</i>
<a name="IDX658"></a>
</dt>
<dd><p>Calcula aproxima&ccedil;&otilde;es num&eacute;ricas de ra&iacute;zes reais e complexas do
polin&ocirc;mio <var>expr</var> ou equa&ccedil;&atilde;o polin&ocirc;mial <var>eqn</var> de uma vari&aacute;vel.
</p>
<p>O sinalizador <code>polyfactor</code> quando <code>true</code> faz com que
<code>allroots</code> fatore o polin&ocirc;mio sobre os n&uacute;meros reais se o
polin&ocirc;mio for real, ou sobre os n&uacute;meros complexos, se o polin&ocirc;mio for
complexo.
</p>
<p><code>allroots</code> pode retornar resultados imprecisos no caso de multiplas ra&iacute;zes.
Se o polin&ocirc;mio for real, <code>allroots (%i*<var>p</var>)</code>) pode retornar
aproxima&ccedil;&otilde;es mais precisas que <code>allroots (<var>p</var>)</code>,
como <code>allroots</code> invoca um algor&iacute;tmo diferente naquele caso.
</p>
<p><code>allroots</code> rejeita n&atilde;o-polin&ocirc;mios.  Isso requer que o numerador
ap&oacute;s a classifica&ccedil;&atilde;o (<code>rat</code>'ing) poder&aacute; ser um polin&ocirc;mio, e isso requer que o
denominador seja quando muito um n&uacute;mero complexo.  Com um resultado disso <code>allroots</code>
ir&aacute; sempre retornar uma express&atilde;o equivalente (mas fatorada), se
<code>polyfactor</code> for <code>true</code>.
</p>
<p>Para polin&ocirc;mios complexos um algor&iacute;tmo por Jenkins e Traub &eacute;
usado (Algorithm 419, <i>Comm.  ACM</i>, vol.  15, (1972), p.  97).
Para polin&ocirc;mios reais o algor&iacute;tmo usado &eacute; devido a Jenkins (Algorithm 493, <i>ACM TOMS</i>,
vol.  1, (1975), p.178).
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>backsubst</b>
<a name="IDX659"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>backsubst</code> &eacute; <code>false</code>, evita substitui&ccedil;&otilde;es
em express&otilde;es anteriores ap&oacute;s as equa&ccedil;&otilde;es terem sido triangularizadas.  Isso pode
ser de grande ajuda em problemas muito grandes onde substitui&ccedil;&atilde;o em express&otilde;es anteriores pode vir a causar
a gera&ccedil;&atilde;o de express&otilde;es extremamente largas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>breakup</b>
<a name="IDX660"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>breakup</code> &eacute; <code>true</code>, <code>solve</code> expressa solu&ccedil;&otilde;es
de equa&ccedil;&otilde;es c&uacute;bicas e qu&aacute;rticas em termos de subexpress&otilde;es comuns,
que s&atilde;o atribu&iacute;das a r&oacute;tulos de express&otilde;es intermedi&aacute;rias (<code>%t1</code>, <code>%t2</code>, etc.).
De outra forma, subexpress&otilde;es comuns n&atilde;o s&atilde;o identificadas.
</p>
<p><code>breakup: true</code> tem efeito somente quando <code>programmode</code> &eacute; <code>false</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>dimension</b><i> (<var>eqn</var>)</i>
<a name="IDX661"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>dimension</b><i> (<var>eqn_1</var>, ..., <var>eqn_n</var>)</i>
<a name="IDX662"></a>
</dt>
<dd><p><code>dimen</code> &eacute; um pacote de an&aacute;lise dimensional.
<code>load (&quot;dimen&quot;)</code> chama esse pacote.
<code>demo (&quot;dimen&quot;)</code> mostra uma cura demostra&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>dispflag</b>
<a name="IDX663"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Se escolhida para <code>false</code> dentro de um <code>block</code> inibir&aacute;
a visualiza&ccedil;&atilde;o da sa&iacute;da gerada pelas fun&ccedil;&otilde;es solve chamadas de
dentro de <code>block</code>.  Terminando <code>block</code> com um sinal de dolar, $, escolhe
<code>dispflag</code> para <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>funcsolve</b><i> (<var>eqn</var>, <var>g</var>(<var>t</var>))</i>
<a name="IDX664"></a>
</dt>
<dd><p>Retorna <code>[<var>g</var>(<var>t</var>) = ...]</code>  ou <code>[]</code>, dependendo de existir
ou n&atilde;o uma fun&ccedil;&atilde;o racional <code><var>g</var>(<var>t</var>)</code> satisfazendo <var>eqn</var>,
que deve ser de primeira ordem, polin&ocirc;mio linear em (para esse caso) 
<code><var>g</var>(<var>t</var>)</code> e <code><var>g</var>(<var>t</var>+1)</code>
</p>
<pre class="example">(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Equa&ccedil;&otilde;es dependentes eliminadas:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
</pre>
<p>Aten&ccedil;&atilde;o: essa &eacute; uma implementa&ccedil;&atilde;o muito rudimentar - muitas verifica&ccedil;&otilde;es de seguran&ccedil;a
e obviamente generaliza&ccedil;&otilde;es est&atilde;o aus&ecirc;ntes.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>globalsolve</b>
<a name="IDX665"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>When <code>globalsolve</code> for <code>true</code>,
vari&aacute;veis para as quais as equa&ccedil;&otilde;es s&atilde;o resolvidas s&atilde;o atribuidas aos valores da solu&ccedil;&atilde;o encontrados por <code>linsolve</code>,
e por <code>solve</code> quando resolvendo duas ou mais equa&ccedil;&otilde;es lineares.
</p>
<p>Quando <code>globalsolve</code> for <code>false</code>,
solu&ccedil;&otilde;es encontradas por <code>linsolve</code> e por <code>solve</code> quando resolvendo duas ou mais equa&ccedil;&otilde;es lineares
s&atilde;o espressas como equa&ccedil;&otilde;es,
e as vari&aacute;veis para as quais a equa&ccedil;&atilde;o foi resolvida n&atilde;o s&atilde;o atribuidas.
</p>
<p>Quando resolvendo qualquer coisa outra que n&atilde;o duas equa&ccedil;&otilde;es lineares ou mais,
<code>solve</code> ignora <code>globalsolve</code>.
Outras fun&ccedil;&otilde;es que resolvem equa&ccedil;&otilde;es (e.g., <code>algsys</code>) sempre ignoram <code>globalsolve</code>.
</p>    
<p>Exemplos:
</p>
<pre class="example">(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ieqn</b><i> (<var>ie</var>, <var>unk</var>, <var>tech</var>, <var>n</var>, <var>guess</var>)</i>
<a name="IDX666"></a>
</dt>
<dd><p><code>inteqn</code> &eacute; um pacote para resolver equa&ccedil;&otilde;es com integrais.
<code>load (&quot;inteqn&quot;)</code> carrega esse pacote.
</p>
<p><var>ie</var> &eacute; a equa&ccedil;&atilde;o integral; <var>unk</var> &eacute; a fun&ccedil;&atilde;o desconhecida; <var>tech</var> &eacute; a
t&eacute;cnica a ser tentada nesses dados acima (<var>tech</var> = <code>first</code> significa: tente
a primeira t&eacute;cnica que achar uma solu&ccedil;&atilde;o; <var>tech</var> = <code>all</code> significa: tente todas a
t&eacute;cnicas aplic&aacute;veis); <var>n</var> &eacute; o n&uacute;mero m&aacute;ximo de termos a serem usados de
<code>taylor</code>, <code>neumann</code>, <code>firstkindseries</code>, ou <code>fredseries</code> (isso &eacute; tamb&eacute;m o
n&uacute;mero m&aacute;ximo de ciclos de recurss&atilde;o para o m&eacute;todo de diferencia&ccedil;&atilde;o); <var>guess</var> &eacute;
o inicial suposto para <code>neumann</code> ou <code>firstkindseries</code>.
</p>
<p>Valores padr&atilde;o do segundo at&eacute; o quinto par&acirc;metro s&atilde;o:
</p>
<p><var>unk</var>: <code><var>p</var>(<var>x</var>)</code>, onde <var>p</var> &eacute; a primeira fun&ccedil;&atilde;o encontrada em um integrando
que &eacute; desconhecida para Maxima e <var>x</var> &eacute; a vari&aacute;vel que ocorre como um
argumento para a primeira ocorr&ecirc;ncia de <var>p</var> achada fora de uma integral no
caso de equa&ccedil;&otilde;es <code>secondkind</code> , ou &eacute; somente outra vari&aacute;vel
ao lado da vari&aacute;vel de integra&ccedil;&atilde;o em equa&ccedil;&otilde;es <code>firstkind</code>.  Se uma
tentativa de procurar por <var>x</var> falha, o usu&aacute;rio ser&aacute; perguntado para suprir a
vari&aacute;vel independente.
</p>
<p>tech: <code>first</code>
</p>
<p>n: 1
</p>
<p>guess: <code>none</code> o que far&aacute; com que <code>neumann</code> e <code>firstkindseries</code> use
<code><var>f</var>(<var>x</var>)</code> como uma suposi&ccedil;&atilde;o inicial.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ieqnprint</b>
<a name="IDX667"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p><code>ieqnprint</code> governa o comportamento do resultado
retornado pelo comando <code>ieqn</code>.  Quando <code>ieqnprint</code> &eacute;
<code>false</code>, as listas retornadas pela fun&ccedil;&atilde;o <code>ieqn</code> s&atilde;o da forma
</p>
<p>   [<var>solu&ccedil;&atilde;o</var>, <var>tecnica usada</var>, <var>nterms</var>, <var>sinalizador</var>]
</p>
<p>onde <var>sinalizador</var> &eacute; retirado se a solu&ccedil;&atilde;o for exata.
</p>
<p>De outra forma, isso &eacute; a
palavra <code>approximate</code> ou <code>incomplete</code> correspondendo &agrave; forma inexata ou
forma aberta de solu&ccedil;&atilde;o, respectivamente.  Se um m&eacute;todo de s&eacute;rie foi usado,
<var>nterms</var> fornece o n&uacute;mero de termos usados (que poder&aacute; ser menor que os n
dados para <code>ieqn</code> se ocorrer um erro evita a gera&ccedil;&atilde;o de termos adicionais).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lhs</b><i> (<var>expr</var>)</i>
<a name="IDX668"></a>
</dt>
<dd><p>Retorna o lado esquerdo (isto &eacute;, o primeiro argumento)
da express&atilde;o <var>expr</var>,
quando o operador de <var>expr</var>
for um dos operadores relacionais <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
um dos operadores de atribui&ccedil;&atilde;o <code>:= ::= : ::</code>,
ou um operadro infixo definido pelo usu&aacute;rio, como declarado por meio de <code>infix</code>.
</p>
<p>Quando <var>expr</var> for um &aacute;tomo ou
seu operador for alguma coisa que n&atilde;o esses listados acima,
<code>lhs</code> retorna <var>expr</var>.
</p>
<p>Veja tamb&eacute;m <code>rhs</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa &lt; bb), lhs (aa &lt;= bb), lhs (aa &gt;= bb), lhs (aa &gt; bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>linsolve</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX669"></a>
</dt>
<dd><p>Resolve a lista de
equa&ccedil;&otilde;es lineares simult&acirc;neas para a lista de vari&aacute;veis.  As express&otilde;es
devem ser cada uma polin&ocirc;mios nas vari&aacute;veis e podem ser equa&ccedil;&otilde;es.
</p>
<p>Quando <code>globalsolve</code> &eacute; <code>true</code> ent&atilde;o vari&aacute;veis que foram resolvidas
ser&atilde;o escolhidas para a solu&ccedil;&atilde;o do conjunto de equa&ccedil;&otilde;es simult&acirc;neas.
</p>
<p>Quando <code>backsubst</code> &eacute; <code>false</code>, <code>linsolve</code>
n&atilde;o realiza substitui&ccedil;&atilde;o em equa&ccedil;&otilde;es anteriores ap&oacute;s
as equa&ccedil;&otilde;es terem sido triangularizadas.  Isso pode ser necess&aacute;rio em problemas
muito grandes onde substitui&ccedil;&atilde;o em equa&ccedil;&otilde;es anteriores poder&aacute; causar a gera&ccedil;&atilde;o de
express&otilde;es extremamente largas.
</p>
<p>Quando <code>linsolve_params</code> for <code>true</code>,
<code>linsolve</code> tamb&eacute;m gera s&iacute;mbolos <code>%r</code>
usados para representar par&acirc;metros arbitr&aacute;rios descritos no manual sob
<code>algsys</code>.
De outra forma, <code>linsolve</code> resolve um menor-determinado sistema de
equa&ccedil;&otilde;es com algumas vari&aacute;veis expressas em termos de outras.
</p>
<p>Quando <code>programmode</code> for <code>false</code>,
<code>linsolve</code> mostra a solu&ccedil;&atilde;o com express&otilde;es intermedi&aacute;rias com r&oacute;tulos (<code>%t</code>),
e retorna a lista de r&oacute;tulos.
</p>
<pre class="example">(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>linsolvewarn</b>
<a name="IDX670"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>linsolvewarn</code> &eacute; <code>true</code>,
<code>linsolve</code> imprime uma mensagem &quot;Dependent equa&ccedil;&otilde;es eliminated&quot;.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>linsolve_params</b>
<a name="IDX671"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>linsolve_params</code> &eacute; <code>true</code>, <code>linsolve</code> tamb&eacute;m gera
os s&iacute;mbolos <code>%r</code> usados para representar par&acirc;metros arbitr&aacute;rios descritos no
manual sob <code>algsys</code>.
De outra forma, <code>linsolve</code> resolve um menor-determinado sistema de
equa&ccedil;&otilde;es com algumas vari&aacute;veis expressas em termos e outras.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>multiplicities</b>
<a name="IDX672"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>not_set_yet</code>
</p>
<p><code>multiplicities</code> &eacute; escolhida para uma lista de
multiplicidades das solu&ccedil;&otilde;es individuais retornadas por <code>solve</code> ou
<code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>nroots</b><i> (<var>p</var>, <var>low</var>, <var>high</var>)</i>
<a name="IDX673"></a>
</dt>
<dd><p>Retorna o n&uacute;mero de ra&iacute;zes reais do polin&ocirc;mio 
real de uma &uacute;nica vari&aacute;vel <var>p</var> no intervalo semi-aberto
<code>(<var>low</var>, <var>high</var>]</code>.
Uma extremidade do intervalo podem ser <code>minf</code> ou <code>inf</code>.
infinito e mais infinito.
</p>
<p><code>nroots</code> usa o m&eacute;todo das sequ&uuml;&ecirc;ncias de Sturm.
</p>
<pre class="example">(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>nthroot</b><i> (<var>p</var>, <var>n</var>)</i>
<a name="IDX674"></a>
</dt>
<dd><p>Onde p &eacute; um polin&ocirc;mio com coeficientes inteiros e
n &eacute; um inteiro positivo retorna q, um polin&ocirc;mio sobre os inteiros, tal
que q^n=p ou imprime uma mensagem de erro indicando que p n&atilde;o &eacute; uma pot&ecirc;ncia n-&eacute;sima
perfeita.  Essa rotina &eacute; mais r&aacute;pida que <code>factor</code> ou mesmo <code>sqfr</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>programmode</b>
<a name="IDX675"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>programmode</code> &eacute; <code>true</code>,
<code>solve</code>, <code>realroots</code>, <code>allroots</code>, e <code>linsolve</code>
retornam solu&ccedil;&otilde;es como elementos em uma lista.
(Exceto quando <code>backsubst</code> &eacute; escolhido para <code>false</code>, nesse caso
<code>programmode: false</code> &eacute; assumido.)
</p>
<p>Quando <code>programmode</code> &eacute; <code>false</code>, <code>solve</code>, etc.
cria r&oacute;tulos de express&otilde;es intermedi&aacute;rias
<code>%t1</code>, <code>t2</code>, etc., e atribui as solu&ccedil;&otilde;es para eles.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>realonly</b>
<a name="IDX676"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>realonly</code> &eacute; <code>true</code>, <code>algsys</code> retorna somente
aquelas solu&ccedil;&otilde;es que est&atilde;o livres de <code>%i</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>realroots</b><i> (<var>expr</var>, <var>bound</var>)</i>
<a name="IDX677"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>realroots</b><i> (<var>eqn</var>, <var>bound</var>)</i>
<a name="IDX678"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>realroots</b><i> (<var>expr</var>)</i>
<a name="IDX679"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>realroots</b><i> (<var>eqn</var>)</i>
<a name="IDX680"></a>
</dt>
<dd><p>Calcula aproxima&ccedil;&otilde;es racionais das ra&iacute;zes reais da express&atilde;o polinomial <var>expr</var>
ou da equa&ccedil;&atilde;o polinomial <var>eqn</var> de uma vari&aacute;vel,
dentro de uma toler&acirc;ncia de <var>bound</var>.
coeficientes de <var>expr</var> ou de <var>eqn</var> devem ser n&uacute;meros literais;
constantes s&iacute;mbolo tais como <code>%pi</code> s&atilde;o rejeitadas.
</p>
<p><code>realroots</code> atribui as multiplicidades das ra&iacute;zes que encontrar
para a vari&aacute;vel global <code>multiplicities</code>.
</p>
<p><code>realroots</code> constr&oacute;i uma seq&uuml;&ecirc;ncia de Sturm para delimitar cada ra&iacute;z,
e ent&atilde;o palica a bisec&ccedil;&atilde;o para redefinir as aproxima&ccedil;&otilde;es.
Todos os coeficientes s&atilde;o convertidos para os equivalentes racionais antes da busca por ra&iacute;zes,
e c&aacute;lculos s&atilde;o realizados por meio de aritm&eacute;tica racional exata.
Mesmo se alguns coeficientes forem n&uacute;meros em ponto flutuante,
os resultados s&atilde;o racionais (a menos que for&ccedil;ados a n&uacute;meros em ponto flutuante por <code>float</code> ou por <code>numer</code> flags).
</p>
<p>Quando <var>bound</var> for menor que 1, todas as ra&iacute;zes inteiras s&atilde;o encontradas exatamente.
Quando <var>bound</var> n&atilde;o for especificado, ser&aacute; assumido como sendo igual &agrave; vari&aacute;vel globa <code>rootsepsilon</code>.
</p>
<p>Quando a var&aacute;vel global <code>programmode</code> for <code>true</code>,
<code>realroots</code> retorna uma lista da forma <code>[x = <var>x_1</var>, x = <var>x_2</var>, ...]</code>.
Quando <code>programmode</code> for <code>false</code>,
<code>realroots</code> cria r&oacute;tulos de express&otilde;es intermedi&aacute;rias <code>%t1</code>, <code>%t2</code>, ...,
atribui os resultados a eles, e retorna a lista de r&oacute;tulos.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
</pre>

<pre class="example">(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rhs</b><i> (<var>expr</var>)</i>
<a name="IDX681"></a>
</dt>
<dd><p>Retorna o lado direito (isto &eacute;, o segundo argumento)
da express&atilde;o <var>expr</var>,
quando o operador de <var>expr</var>
for um dos operadores relacionais <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
um dos operadores de atribui&ccedil;&atilde;o <code>:= ::= : ::</code>,
ou um operador bin&aacute;rio infixo definido pelo usu&aacute;rio, como declarado por meio de <code>infix</code>.
</p>
<p>Quando <var>expr</var> for um &eacute;tomo ou
seu operadro for alguma coisa que n&atilde;o esses listados acima,
<code>rhs</code> retorna 0.
</p>
<p>Veja tamb&eacute;m <code>lhs</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa &lt; bb), rhs (aa &lt;= bb), rhs (aa &gt;= bb), rhs (aa &gt; bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>rootsconmode</b>
<a name="IDX682"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p><code>rootsconmode</code> governa o comportamento do comando
<code>rootscontract</code>.  Veja <code>rootscontract</code> para detalhes.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rootscontract</b><i> (<var>expr</var>)</i>
<a name="IDX683"></a>
</dt>
<dd><p>Converte produtos de ra&iacute;zes em ra&iacute;zes de produtos.
Por exemplo,
<code>rootscontract (sqrt(x)*y^(3/2))</code> retorna <code>sqrt(x*y^3)</code>.
</p>
<p>Quando <code>radexpand</code> &eacute; <code>true</code> e <code>domain</code> &eacute; <code>real</code>,
<code>rootscontract</code> converte <code>abs</code> em <code>sqrt</code>, e.g.,
<code>rootscontract (abs(x)*sqrt(y))</code> retorna <code>sqrt(x^2*y)</code>.
</p>
<p>Existe uma op&ccedil;&atilde;o <code>rootsconmode</code>
afetando <code>rootscontract</code> como segue:
</p>
<pre class="example">Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
</pre>
<p>Quando <code>rootsconmode</code> &eacute; <code>false</code>, <code>rootscontract</code> contrai somente como rela&ccedil;&atilde;o a expoentes
de n&uacute;mero racional cujos denominadores s&atilde;o os mesmos.  A chave para os exemplos
<code>rootsconmode: true</code> &eacute; simplesmente que 2 divides 4 mas n&atilde;o 
divide 3.  <code>rootsconmode: all</code> envolve pegar o menor multiplo comum
dos denominadores dos expoentes.
</p>
<p><code>rootscontract</code> usa <code>ratsimp</code> em uma maneira similar a <code>logcontract</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>rootsepsilon</b>
<a name="IDX684"></a>
</dt>
<dd><p>Valor padr&atilde;o: 1.0e-7
</p>
<p><code>rootsepsilon</code> &eacute; a toler&acirc;ncia que estabelece o
intervalo de confic&ecirc;ncia para as ra&iacute;zes achadas pela fun&ccedil;&atilde;o <code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>solve</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX685"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>solve</b><i> (<var>expr</var>)</i>
<a name="IDX686"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>solve</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX687"></a>
</dt>
<dd><p>Resolve a equa&ccedil;&atilde;o alg&eacute;brica <var>expr</var> para a vari&aacute;vel
<var>x</var> e retorna uma lista de equa&ccedil;&otilde;es solu&ccedil;&atilde;o em <var>x</var>.  Se <var>expr</var> n&atilde;o &eacute; uma
equa&ccedil;&atilde;o, a equa&ccedil;&atilde;o <code><var>expr</var> = 0</code> &eacute; assumida em seu lugar.
<var>x</var> pode ser uma fun&ccedil;&atilde;o (e.g. <code>f(x)</code>), ou outra express&atilde;o n&atilde;o at&ocirc;mica
exceto uma adi&ccedil;&atilde;o ou um produto.  <var>x</var> pode ser omitido se <var>expr</var> cont&eacute;m somente uma
vari&aacute;vel.  <var>expr</var> pode ser uma express&atilde;o racional, e pode conter
fun&ccedil;&otilde;es trigonom&eacute;tricas, exponenciais, etc.
</p>
<p>O seguinte m&eacute;todo &eacute; usado:
</p>
<p>Tome <var>E</var> sendo a express&atilde;o e <var>X</var> sendo a vari&aacute;vel.  Se <var>E</var> &eacute; linear em <var>X</var>
ent&atilde;o isso &eacute; trivialmente resolvido para <var>X</var>.  De outra forma se <var>E</var> &eacute; da forma
<code>A*X^N + B</code> ent&atilde;o o resultado &eacute; <code>(-B/A)^1/N)</code> vezes as <code>N</code>'&eacute;simas ra&iacute;zes da
unidade.
</p>
<p>Se <var>E</var> n&atilde;o &eacute; linear em <var>X</var> ent&atilde;o o m&aacute;ximo divisor comum (mdc) dos expoentes de <var>X</var> em <var>E</var> (digamos
<var>N</var>) &eacute; dividido dentro dos expoentes e a multiplicidade das ra&iacute;zes &eacute;
multiplicada por <var>N</var>.  Ent&atilde;o <code>solve</code> &eacute; chamada novamente sobre o resultado.
Se <var>E</var> for dada em fatores ent&atilde;o <code>solve</code> &eacute; chamada sobre cada um dos fatores.  Finalmente
<code>solve</code> usar&aacute; as f&oacute;rmulas quadr&aacute;ticas, c&uacute;bicas, ou qu&aacute;rticas onde
necess&aacute;rio.
</p>
<p>No caso onde <var>E</var> for um polin&ocirc;mio em alguma fun&ccedil;&atilde;o de vari&aacute;vel a ser
resolvida, digamos <code>F(X)</code>, ent&atilde;o isso &eacute; primeiro resolvida para <code>F(X)</code> (chama o
resultado <var>C</var>), ent&atilde;o a equa&ccedil;&atilde;o <code>F(X)=C</code> pode ser resolvida para <var>X</var> fornecendo o
inverso da fun&ccedil;&atilde;o <var>F</var> que &eacute; conhecida.
</p>
<p><code>breakup</code> se <code>false</code> far&aacute; com que <code>solve</code> expresse as solu&ccedil;&otilde;es de
equa&ccedil;&otilde;es c&uacute;bicas ou qu&aacute;rticas como express&otilde;es simples ao inv&eacute;s de como feito
em cima de v&aacute;rias subexpress&otilde;es comuns que &eacute; o padr&atilde;o.
</p>
<p><code>multiplicities</code> - ser&aacute; escolhido para uma lista de multiplicidades de
solu&ccedil;&otilde;es individuais retornadas por <code>solve</code>, <code>realroots</code>, ou <code>allroots</code>.
Tente <code>apropos (solve)</code> para os comutadores que afetam <code>solve</code>.  <code>describe</code> pode
ent&atilde;o ser usada sobre o nome do comutador individual se seu propr&oacute;sito n&atilde;o &eacute;
claro.
</p>
<p><code>solve ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</code>
resolve um sistema de equa&ccedil;&otilde;es polinomiais
(lineares ou n&atilde;o-lineares) simult&acirc;neas por chamada a <code>linsolve</code> ou
<code>algsys</code> e retorna uma lista de listas solu&ccedil;&atilde;o nas vari&aacute;veis.  No
caso de <code>linsolve</code> essa lista conter&aacute; uma lista simples de
solu&ccedil;&otilde;es.  Isso pega duas listas como argumentos.  A primeira lista
representa as equa&ccedil;&otilde;es a serem resolvidas; a segunda lista &eacute; a
lista de desconhecidos a ser determinada.  Se o n&uacute;mero total de
vari&aacute;veis nas equa&ccedil;&otilde;es &eacute; igual ao n&uacute;mero de equa&ccedil;&otilde;es, a
segunda lista-argumento pode ser omitida.  Para sistemas lineares se as dadas
equa&ccedil;&otilde;es n&atilde;o s&atilde;o compat&iacute;veis, a mensagem <code>inconsistent</code> ser&aacute;
mostrada (veja o comutador <code>solve_inconsistent_error</code> ); se n&atilde;o existe
solu&ccedil;&atilde;o &uacute;nica, ent&atilde;o <code>singular</code> ser&aacute; mostrado.
</p>
<p>Quando <code>programmode</code> for <code>false</code>,
<code>solve</code> mostra solu&ccedil;&otilde;es com r&oacute;tulos de express&otilde;es intermedi&aacute;rias (<code>%t</code>),
e retorna a lista de r&oacute;tulos.
</p>
<p>Quando <code>globalsolve</code> for <code>true</code> e o problema for resolver duas ou mais equa&ccedil;&otilde;es lineares,
cada vari&aacute;vel para a qual a equa&ccedil;&atilde;o for resolvida &eacute; associada a seu valor na solu&ccedil;&atilde;o das equa&ccedil;&otilde;es.
</p>
<p>Exemplos:
</p><pre class="example">(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solvedecomposes</b>
<a name="IDX688"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>solvedecomposes</code> &eacute; <code>true</code>, <code>solve</code> chama
<code>polydecomp</code> se perguntado para resolver polin&ocirc;mios.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solveexplicit</b>
<a name="IDX689"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>solveexplicit</code> &eacute; <code>true</code>, inibe <code>solve</code> de
retornar solu&ccedil;&otilde;es impl&iacute;citas, isto &eacute;, solu&ccedil;&otilde;es da forma <code>F(x) = 0</code>
onde <code>F</code> &eacute; alguma fun&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solvefactors</b>
<a name="IDX690"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>solvefactors</code> &eacute; <code>false</code>, <code>solve</code> n&atilde;o tenta
fatorar a express&atilde;o.  O <code>false</code> escolhido pode ser desejado em alguns casos
onde a fatora&ccedil;&atilde;o n&atilde;o &eacute; necess&aacute;ria.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solvenullwarn</b>
<a name="IDX691"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>solvenullwarn</code> &eacute; <code>true</code>, 
<code>solve</code> imprime uma mensagem de alerta se chamada com ou uma lista equa&ccedil;&atilde;o ou uma vari&aacute;vel lista nula.
Por exemplo, <code>solve ([], [])</code> imprimir&aacute; duas mensagens de alerta e retorna <code>[]</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solveradcan</b>
<a name="IDX692"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>solveradcan</code> &eacute; <code>true</code>, <code>solve</code> chama <code>radcan</code>
que faz <code>solve</code> lento mas permitir&aacute; certamente que problemas
contendo exponeniais e logar&iacute;tmos sejam resolvidos.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solvetrigwarn</b>
<a name="IDX693"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>solvetrigwarn</code> &eacute; <code>true</code>,
<code>solve</code> pode imprimir uma mensagem dizendo que est&aacute; usando fun&ccedil;&otilde;es
trigonom&eacute;tricas inversas para resolver a equa&ccedil;&atilde;o, e desse modo perdendo
solu&ccedil;&otilde;es.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>solve_inconsistent_error</b>
<a name="IDX694"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>solve_inconsistent_error</code> for <code>true</code>, <code>solve</code> e
<code>linsolve</code> resultam em erro se as equa&ccedil;&otilde;es a serem resolvidas forem inconsistentes.
</p>
<p>Se <code>false</code>, <code>solve</code> e <code>linsolve</code> retornam uma lista vazia <code>[]</code> 
se as equa&ccedil;&otilde;es forem inconsistentes.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equa&ccedil;&otilde;es:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
