<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 27. itensor</title>

<meta name="description" content="Manual do Maxima: 27. itensor">
<meta name="keywords" content="Manual do Maxima: 27. itensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="itensor"></a>
<a name="SEC89"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_26.html#SEC88" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 27. itensor </h1>



<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC90">27.1 Introdu&ccedil;&atilde;o a itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC93">27.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-itensor"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.1 Introdu&ccedil;&atilde;o a itensor </h2>

<p>Maxima implementa a manipula&ccedil;&atilde;o de tensores simb&oacute;licos d dois tipos distintos:
manipula&ccedil;&atilde;o de componentes de tensores (pacote <code>ctensor</code>) e manipula&ccedil;&atilde;o de tensores indiciais (pacote <code>itensor</code>).
</p>
<p>Note bem: Por favor veja a nota sobre 'nova nota&ccedil;&atilde;o de tensor' abaixo.
</p>
<p>Manipula&ccedil;&atilde;o de componentes de tensores significa que objetos do tipo
tensor geom&eacute;trico s&atilde;o representados como arrays ou matrizes. Opera&ccedil;&otilde;es com tensores tais com
contra&ccedil;&atilde;o ou diferencia&ccedil;&atilde;o covariante s&atilde;o realizadas
sobre &iacute;ndices (que ocorrem exatamente duas vezes) repetidos com declara&ccedil;&otilde;es <code>do</code>.
Isto &eacute;, se executa explicitamente opera&ccedil;&otilde;es sobre as componentes apropriadas do
tensor armazenadas em um array ou uma matriz.
</p>
<p>Manipula&ccedil;&atilde;o tensorial de &iacute;ndice &eacute; implementada atrav&eacute;s da representa&ccedil;&atilde;o
de tensores como fun&ccedil;&otilde;es e suas covariantes, contravariantes e &iacute;ndices de
deriva&ccedil;&atilde;o. Opera&ccedil;&otilde;es com tensores como contra&ccedil;&atilde;o ou diferencia&ccedil;&atilde;o
covariante s&atilde;o executadas atrav&eacute;s de manipula&ccedil;&atilde;o dos &iacute;ndices em si mesmos
em lugar das componentes para as quais eles correspondem.
</p>
<p>Esses dois m&eacute;todos aproximam-se do tratamento de processos diferenciais, alg&eacute;bricos e
anal&iacute;ticos no contexto da geometria de Riemannian possuem v&aacute;rias
vantagens e desvantagens as quais se revelam por si mesmas somente apesar da
natureza particular e dificuldade dos problemas de usu&aacute;rio.  Todavia, se
pode ter em mente as seguintes caracter&iacute;sticas das duas
implementa&ccedil;&otilde;es:
</p>
<p>As representa&ccedil;&otilde;es de tensores e de opera&ccedil;&otilde;es com tensores explicitamente em
termos de seus componntes tornam o pacote <code>ctensor</code> f&aacute;cil de usar. Especifica&ccedil;&atilde;o da
m&eacute;trica e o c&aacute;lculo de tensores induzidos e invariantes
&eacute; direto. Embora todas a capacidade de simplifica&ccedil;&atilde;o poderosa do
Maxima est&aacute; em manusear, uma m&eacute;trica complexa com intrincada depend&ecirc;ncia funcional
e de coordenadas pode facilmente conduzir a express&otilde;es cujo tamanho &eacute;
excessivo e cuja estrutura est&aacute; escondida. Adicionalmente, muitos c&aacute;lculos
envolvem express&otilde;es intermedi&aacute;rias cujo crescimento fazem com que os programas
terminem antes de serem completados. Atrav&eacute;s da experi&ecirc;ncia, um usu&aacute;rio pode evitar
muitas dessas dificuldade.
</p>
<p>O motivo de caminhos especiais atrav&eacute;s dos quais tensores e opera&ccedil;&otilde;es de tensores
s&atilde;o representados em termos de opera&ccedil;&otilde;es simb&oacute;licas sobre seus &iacute;ndices,
express&otilde;es cujas representa&ccedil;&atilde;o de componentes podem ser
n&atilde;o gerenciaveis da forma comum podem algumas vezes serem grandemente simplificadas atrav&eacute;s do uso das rotinas
especiais para objetos sim&eacute;tricos em <code>itensor</code>. Nesse caminho a estrutura
de uma express&atilde;o grande pode ser mais transparente. Por outro lado, o motivo
da representa&ccedil;&atilde;o indicial especial em <code>itensor</code>, faz com que em alguns casos o
usu&aacute;rio possa encontrar dificuldade com a especifica&ccedil;&atilde;o da m&eacute;trica, defini&ccedil;&atilde;o
de fun&ccedil;&atilde;o, e a avalia&ccedil;&atilde;o de objetos &quot;indexados&quot; diferenciados.
</p>
<hr size="6">
<a name="SEC91"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC90" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.1.1 Nova nota&ccedil;&atilde;o d tensores </h3>

<p>At&eacute; agora, o pacote <code>itensor</code> no Maxima tinha usado uma nota&ccedil;&atilde;o que algumas vezes
conduzia a ordena&ccedil;&atilde;o incorreta de &iacute;ndices. Considere o seguinte, por exemplo:
</p>
<pre class="example">(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
</pre>
<p>O resultado est&aacute; incorreto a menos que ocorra ser <code>a</code> um tensor sim&eacute;trico.
A raz&atilde;o para isso &eacute; que embora <code>itensor</code> mantenha corretamente
a ordem dentro do conjunto de &iacute;ndices covariantes e contravariantes, assim que um
&iacute;ndice &eacute; incrementado ou decrementado, sua posi&ccedil;&atilde;o relativa para o outro conjunto de
&iacute;ndices &eacute; perdida.
</p>
<p>Para evitar esse problema, uma nova nota&ccedil;&atilde;o tem sido desenvolvida que mant&eacute;m total
compatibilidade com a nota&ccedil;&atilde;o existente e pode ser usada intercambiavelmente. Nessa
nota&ccedil;&atilde;o, &iacute;ndices contravariantes s&atilde;o inseridos na posi&ccedil;&atilde;o
apropriada na lista de &iacute;ndices covariantes, mas com um sinal de menos colocado antes.
Fun&ccedil;&otilde;es como <code>contract</code> e <code>ishow</code> est&atilde;o agora consciente dessa
nova nota&ccedil;&atilde;o de &iacute;ndice e podem processar tensores apropriadamente.
</p>
<p>Nessa nova nota&ccedil;&atilde;o, o exemplo anterior retorna um resultado correto:
</p>
<pre class="example">(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
</pre>
<p>Presentemente, o &uacute;nico c&oacute;digo que faz uso dessa nota&ccedil;&atilde;o &eacute; a fun&ccedil;&atilde;o
<code>lc2kdt</code>. Atrav&eacute;s dessa nota&ccedil;&atilde;o, a fun&ccedil;&atilde;o <code>lc2kdt</code> encontra com &ecirc;xito resultados consistentes como
a aplica&ccedil;&atilde;o do tensor m&eacute;trico para resolver os s&iacute;mbolos de Levi-Civita sem reordenar
para &iacute;ndices num&eacute;ricos.
</p>
<p>Uma vez que esse c&oacute;digo &eacute; um tipo novo, provavelmente cont&eacute;m erros. Enquanto esse tipo novo n&atilde;o tiver sido
testado para garantir que ele n&atilde;o interrompe nada usando a &quot;antiga&quot; nota&ccedil;&atilde;o de
tensor, existe uma consider&aacute;vel chance que &quot;novos&quot; tensores ir&atilde;o falhar em
interoperar com certas fun&ccedil;&otilde;es ou recursos. Essas falhas ser&atilde;o corrigidas
&agrave; medida que forem encontradas... at&eacute; ent&atilde;o, seja cuidadoso!
</p>

<hr size="6">
<a name="SEC92"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC91" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.1.2 Manipula&ccedil;&atilde;o de tensores indiciais </h3>

<p>o pacote de manipula&ccedil;&atilde;o de tensores indiciais pode ser chamado atrav&eacute;s de
<code>load(itensor)</code>. Demonsta&ccedil;&otilde;es est&atilde;o tamb&eacute;m dispon&iacute;veis: tente <code>demo(tensor)</code>.
Em <code>itensor</code> um tensor &eacute; representado como um &quot;objeto indexado&quot; .  Um &quot;objeto indexado&quot; &eacute; uma
fun&ccedil;&atilde;o de 3 grupos de &iacute;ndices os quais representam o covariante,
o contravariante e o &iacute;ndice de deriva&ccedil;&atilde;o.  Os &iacute;ndices covariantes s&atilde;o
especificados atrav&eacute;s de uma lista com o primeiro argumento para o objeto indexado, e
os &iacute;ndices contravariantes atrav&eacute;s de uma lista como segundo argumento. Se o
objeto indexado carece de algum desses grupos de &iacute;ndices ent&atilde;o a lista
vazia <code>[]</code> &eacute; fornecida como o argumento correspondente.  Dessa forma, <code>g([a,b],[c])</code>
representa um objeto indexado chamado <code>g</code> o qual tem dois &iacute;ndices covariantes
<code>(a,b)</code>, um &iacute;ndice contravariante (<code>c</code>) e n&atilde;o possui &iacute;ndices de deriva&ccedil;&atilde;o.
</p>
<p>Os &iacute;ndices de deriva&ccedil;&atilde;o, se estiverem presente, s&atilde;o anexados ao final como
argumentos adicionais para a fun&ccedil;&atilde;o num&eacute;rica representando o tensor.
Eles podem ser explicitamente especificado pelo usu&aacute;rio ou serem criados no
processo de diferencia&ccedil;&atilde;o com rela&ccedil;&atilde;o a alguma vari&aacute;vel coordenada.
Uma vez que diferencia&ccedil;&atilde;o ordin&aacute;ria &eacute; comutativa, os &iacute;ndices de deriva&ccedil;&atilde;o
s&atilde;o ordenados alfanumericamente, a menos que <code>iframe_flag</code> seja escolhida para <code>true</code>,
indicando que uma moldura m&eacute;trica est&aacute; sendo usada. Essa ordena&ccedil;&atilde;o can&ocirc;nica torna
poss&iacute;vel para Maxima reconhecer que, por exemplo, <code>t([a],[b],i,j)</code> &eacute;
o mesmo que <code>t([a],[b],j,i)</code>.  Diferencia&ccedil;&atilde;o de um objeto indexado com
rela&ccedil;&atilde;o a alguma coordenada cujos &iacute;ndices n&atilde;o aparecem como um argumento
para o objeto indexado podem normalmente retornar zero. Isso &eacute; porque
Maxima pode n&atilde;o saber que o tensor representado atrav&eacute;s do objeto
indexado poss&iacute;velmente depende implicitamente da respectiva coordenada.  Pela
modifica&ccedil;&atilde;o da fun&ccedil;&atilde;o existente no Maxima, <code>diff</code>,  em <code>itensor</code>, Maxima sabe
assumir que todos os objetos indexados dependem de qualquer vari&aacute;vel de
diferencia&ccedil;&atilde;o a menos que seja declarado de outra forma.  Isso torna poss&iacute;vel para
a conven&ccedil;&agrave;o de somat&oacute;rio ser extendida para &iacute;ndices derivativos. Pode
ser verificado que <code>itensor</code> n&atilde;o possui a compatibilidade de
incrementar &iacute;ndices derivativos, e ent&atilde;o eles s&atilde;o sempre tratados como
covariantes.
</p>
<p>As seguintes fun&ccedil;&otilde;es est&atilde;o dispon&iacute;veis no pacote tensor para
manipula&ccedil;&atilde;o de objetos.  Atualmente, com rela&ccedil;&atilde;o &agrave;s
rotinas de simplifica&ccedil;&atilde;o, &eacute; assumido que objetos indexados n&atilde;o
possuem por padr&atilde;o propriedades sim&eacute;tricas. Isso pode ser modificado atrav&eacute;s
da escolha da vari&aacute;vel <code>allsym[false]</code> para <code>true</code>, o que ir&aacute;
resultar no tratamento de todos os objetos indexados completamente sim&eacute;tricos em suas
listas de &iacute;ndices covariantes e sim&eacute;tricos em suas listas de
&iacute;ndices contravariantes.
</p>
<p>O pacote <code>itensor</code> geralmente trata tensores como objetos opacos. Equa&ccedil;&otilde;es
tensoriais s&atilde;o manipuladas baseadas em regras alg&eacute;bricas, especificamente simetria
e regras de contra&ccedil;&atilde;o. Adicionalmente, o pacote <code>itensor</code> n&atilde;o entende
diferencia&ccedil;&atilde;o covariante, curvatura, e tors&atilde;o. C&aacute;lculos podem ser
executados relativamente a um m&eacute;trica de molduras de movimento, dependendo da escolha para
a vari&aacute;vel <code>iframe_flag</code>.
</p>
<p>Uma sess&atilde;o demonstrativa abaixo mostra como chamar o pacote <code>itensor</code>,
especificando o nome da m&eacute;trica, e executando alguns c&aacute;lculos simples.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
               %4 %5
(%t12) v    - g      v   (e p       + e   p     - e p       - e    p
        i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                + e p       + e   p    )/2
                                                     i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %8                    %6 %8
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %8 i             %6    i j %8      i,j

                                                    %6 %8
                                               - ifg      v   ifb      )/2
                                                           %6    %8 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
</pre>



<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-itensor"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC93"></a>
<h2 class="section"> 27.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para itensor </h2>
<hr size="6">
<a name="SEC94"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC93" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.1 Gerenciando objetos indexados </h3>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>entertensor</b><i> (<var>nome</var>)</i>
<a name="IDX853"></a>
</dt>
<dd><p>&Eacute; uma fun&ccedil;&atilde;o que, atrav&eacute;s da linha de comando, permite criar um objeto
indexado chamado <var>nome</var> com qualquer n&uacute;mero de &iacute;ndices de tensores e
derivativos. Ou um &iacute;ndice simples ou uma lista de &iacute;ndices (&agrave;s quais podem ser
nulas) s&atilde;o entradas aceit&aacute;veis (veja o exemplo sob <code>covdiff</code>).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>changename</b><i> (<var>antigo</var>, <var>novo</var>, <var>expr</var>)</i>
<a name="IDX854"></a>
</dt>
<dd><p>Ir&aacute; mudar o nome de todos os objetos indexados chamados <var>antigo</var> para <var>novo</var>
em <var>expr</var>. <var>antigo</var> pode ser ou um s&iacute;mbolo ou uma lista da forma
<code>[<var>nome</var>, <var>m</var>, <var>n</var>]</code> nesse caso somente esses objetos indexados chamados
<var>nome</var> com &iacute;ndice covariante <var>m</var> e &iacute;ndice contravariante <var>n</var> ser&atilde;o
renomeados para <var>novo</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>listoftens</b>
<a name="IDX855"></a>
</dt>
<dd><p>Lista todos os tensores em uma express&atilde;o tensorial, incluindo seus &iacute;ndices. E.g.,
</p>
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ishow</b><i> (<var>expr</var>)</i>
<a name="IDX856"></a>
</dt>
<dd><p>Mostra <var>expr</var> com os objetos indexados tendo seus
&iacute;ndices covariantes como subscritos e &iacute;ndices contravariantes como
sobrescritos.  Os &iacute;ndices derivativos s&atilde;o mostrados como subscritos,
separados dos &iacute;ndices covariantes por uma v&iacute;rgula (veja os exemplos
atrav&eacute;s desse documento).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>indices</b><i> (<var>expr</var>)</i>
<a name="IDX857"></a>
</dt>
<dd><p>Retorna uma lista de dois elementos.  O primeiro &eacute; uma lista de &iacute;ndices
livres em <var>expr</var> (aqueles que ocorrem somente uma vez). O segundo &eacute; uma
lista de indices que ocorrem exatamente duas vezes em <var>expr</var> (dummy)
como demonstra o seguinte exemplo.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre>
<p>Um produto de tensores contendo o mesmo &iacute;ndice mais que duas vezes &eacute; sintaticamente
ilegal. <code>indices</code> tenta lidar com essas express&otilde;es de uma
forma razo&aacute;vel; todavia, quando <code>indices</code> &eacute; chamada para operar sobre tal uma
express&atilde;o ilegal, seu comportamento pode ser considerado indefinido.
</p>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rename</b><i> (<var>expr</var>)</i>
<a name="IDX858"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rename</b><i> (<var>expr</var>, <var>contador</var>)</i>
<a name="IDX859"></a>
</dt>
<dd><p>Retorna uma express&atilde;o equivalente para <var>expr</var> mas com &iacute;ndices que ocorrem exatamente duas vezes
em cada termo alterado do conjunto <code>[%1, %2,...]</code>, se o segundo argumento
opcional for omitido. De outra forma, os &iacute;ndices que ocorrem exatamente duas vezes s&atilde;o indexados
come&ccedil;ando no valor de <var>contador</var>.  Cada &iacute;ndice que ocorre exatamente duas vezes em um produto
ser&aacute; diferente. Para uma adi&ccedil;&atilde;o, <code>rename</code> ir&aacute; operar sobre cada termo na
a adi&ccedil;&atilde;o zerando o contador com cada termo. Nesse caminho <code>rename</code> pode
servir como um simplificador tensorial. Adicionalmente, os &iacute;ndices ser&atilde;o
ordenados alfanumericamente (se <code>allsym</code> for <code>true</code>) com rela&ccedil;&atilde;o a
&iacute;ndices covariantes ou contravariantes dependendo do valor de <code>flipflag</code>.
Se <code>flipflag</code> for <code>false</code> ent&atilde;o os &iacute;ndices ser&atilde;o renomeados conforme
a ordem dos &iacute;ndices contravariantes. Se <code>flipflag</code> for <code>true</code>
a renomea&ccedil;&atilde;o ocorrer&aacute; conforme a ordem dos &iacute;ndices
covariantes. Isso muitas vezes ajuda que o efeito combinado dos dois restantes sejam
reduzidos a uma express&atilde;o de valor um ou mais que um por si mesma.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

              %1 %2  %3 %4      %6         %5         %7        u
           - g      g      ichr2      ichr2      ichr2     ichr2
                                %1 %3      %2 %6      %4 r      %5 %7
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de Op&ccedil;&atilde;o:</u> <b>flipflag</b>
<a name="IDX860"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>. Se <code>false</code> ent&atilde;o os &iacute;ndices ir&atilde;o ser
renomeados conforme a ordem dos &iacute;ndices contravariantes,
de outra forma ser&atilde;o ordenados conforme a ordem dos &iacute;ndices covariantes.
</p>
<p>Se <code>flipflag</code> for <code>false</code> ent&atilde;o <code>rename</code> forma uma lista
de &iacute;ndices contravariantes na ordem em que forem encontrados da esquerda para a direita
(se <code>true</code> ent&atilde;o de &iacute;ndices contravariantes). O primeiro &iacute;ndice
que ocorre exatamente duas vezes na lista &eacute; renomeado para <code>%1</code>, o seguinte para <code>%2</code>, etc.
Ent&atilde;o a ordena&ccedil;&atilde;o ocorre ap&oacute;s a ocorr&ecirc;ncia do <code>rename</code> (veja o exemplo
sob <code>rename</code>).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>defcon</b><i> (<var>tensor_1</var>)</i>
<a name="IDX861"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>defcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</i>
<a name="IDX862"></a>
</dt>
<dd><p>Dado <var>tensor_1</var> a propriedade que a
contra&ccedil;&atilde;o de um produto do <var>tensor_1</var> e do <var>tensor_2</var> resulta em <var>tensor_3</var>
com os &iacute;ndices apropriados.  Se somente um argumento, <var>tensor_1</var>, for
dado, ent&atilde;o a contra&ccedil;&atilde;o do produto de <var>tensor_1</var> com qualquer objeto
indexado tendo os &iacute;ndices apropriados (digamos <code>my_tensor</code>) ir&aacute; retornar como resultado um
objeto indexado com aquele nome, i.e. <code>my_tensor</code>, e com uma nova escolha de
&iacute;ndices refletindo as contra&ccedil;&otilde;es executadas.
Por exemplo, se <code>imetric:g</code>, ent&atilde;o <code>defcon(g)</code> ir&aacute; implementar o
incremento e decremento de &iacute;ndices atrav&eacute;s da contra&ccedil;&atilde;o com o tensor
m&eacute;trico.
Mais de uma <code>defcon</code> pode ser dada para o mesmo objeto indexado; o
&uacute;ltimo  fornecido que for aplicado a uma contra&ccedil;&atilde;o particular ser&aacute;
usado.
<code>contractions</code> &eacute; uma lista de objetos indexados que tenham fornecido
propriedades de contra&ccedil;&otilde;es com <code>defcon</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remcon</b><i> (<var>tensor_1</var>, ..., <var>tensor_n</var>)</i>
<a name="IDX863"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remcon</b><i> (all)</i>
<a name="IDX864"></a>
</dt>
<dd><p>Remove todas as propriedades de contra&ccedil;&atilde;o
de <var>tensor_1</var>, ..., <var>tensor_n</var>). <code>remcon(all)</code> remove todas as propriedades de
contra&ccedil;&atilde;o de todos os objetos indexados.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>contract</b><i> (<var>expr</var>)</i>
<a name="IDX865"></a>
</dt>
<dd><p>Realiza contra&ccedil;&otilde;es tensoriais em <var>expr</var> a qual pode ser qualquer
combina&ccedil;&atilde;o de adi&ccedil;&otilde;es e produtos. Essa fun&ccedil;&atilde;o usa a informa&ccedil;&atilde;o
dada para a fun&ccedil;&atilde;o <code>defcon</code>. Para melhores resultados, <code>expr</code>
pode ser completamente expandida. <code>ratexpand</code> &eacute; o meio mais r&aacute;pido para expandir
produtos e expoentes de adi&ccedil;&otilde;es se n&atilde;o existirem vari&aacute;veis nos denominadores
dos termos. O comutador <code>gcd</code> pode ser <code>false</code> se cancelamentos de
m&aacute;ximo divisor comum forem desnecess&aacute;rios.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>indexed_tensor</b><i> (<var>tensor</var>)</i>
<a name="IDX866"></a>
</dt>
<dd><p>Deve ser executada antes de atribuir componentes para um <var>tensor</var> para o qual
um valor interno j&aacute; existe como com <code>ichr1</code>, <code>ichr2</code>,
<code>icurvature</code>. Veja o exemplo sob <code>icurvature</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>components</b><i> (<var>tensor</var>, <var>expr</var>)</i>
<a name="IDX867"></a>
</dt>
<dd><p>Permite que se atribua um valor indicial a uma express&atilde;o
<var>expr</var> dando os valores das componentes do <var>tensor</var>. Esses
s&atilde;o automaticamente substitu&iacute;dos para o tensor mesmo que isso ocorra com
todos os seus &iacute;ndices. O tensor deve ser da forma <code>t([...],[...])</code>
onde qualquer lista pode ser vazia. <var>expr</var> pode ser qualquer express&atilde;o indexada
envolvendo outros objetos com os mesmos &iacute;ndices livres que <var>tensor</var>. Quando
usada para atribuir valores a um tensor m&eacute;trico no qual as componentes
possuem &iacute;ndices que ocorrem exatamente duas vezes se deve ser cuidadoso para definir esses &iacute;ndices de forma a
evitar a gera&ccedil;&atilde;o de &iacute;ndices que ocorrem exatamente duas vezes e que s&atilde;o multiplos. a remo&ccedil;&atilde;o dessas
atribui&ccedil;&otilde;es &eacute; dada para a fun&ccedil;&atilde;o <code>remcomps</code>.
</p>
<p>&Eacute; importante ter em mente que <code>components</code> cuida somente da
val&ecirc;ncia de um tensor, e que ignora completamente qualquer ordena&ccedil;&atilde;o particular de &iacute;ndices. Dessa forma
atribuindo componentes a, digamos, <code>x([i,-j],[])</code>, <code>x([-j,i],[])</code>, ou
<code>x([i],[j])</code> todas essas atribui&ccedil;&otilde;es produzem o mesmo resultado, a saber componentes sendo
atribuidas a um tensor chamado <code>x</code> com val&ecirc;ncia <code>(1,1)</code>.
</p>
<p>Componentes podem ser atribuidas a uma express&atilde;o indexada por quatro caminhos, dois
dos quais envolvem o uso do comando <code>components</code>:
</p>
<p>1) Como uma express&atilde;o indexada. Por exemplo:
</p>
<pre class="example">
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre>
<p>2) Como uma matriz:
</p>
<pre class="example">
(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([3,3],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

</pre>
<p>3) Como uma fun&ccedil;&atilde;o. Voc&ecirc; pode usar uma fun&ccedil;&atilde;o Maxima para especificar as
componentes de um tensor baseado nesses &iacute;ndices. Por exemplo, os seguintes
c&oacute;digos atribuem <code>kdelta</code> a <code>h</code> se <code>h</code> tiver o mesmo n&uacute;mero de
&iacute;ndices covariantes e &iacute;ndices contravariantes e nenhum &iacute;ndice derivativo, e
atribui <code>kdelta</code> a <code>g</code> caso as condi&ccedil;&otilde;es anteriores n&atilde;o sejam atendidas:
</p>
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

</pre>
<p>4) Usando a compatibilidade dos modelos de coincid&ecirc;ncia do Maxima, especificamente os
comandos <code>defrule</code> e <code>applyb1</code>:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX868"></a>
</dt>
<dd><p>Desassocia todos os valores de <var>tensor</var> que foram atribu&iacute;dos com a
fun&ccedil;&atilde;o <code>components</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>showcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX869"></a>
</dt>
<dd><p>Mostra atribui&ccedil;&otilde;es de componentes de um tensor, feitas usando o comando
<code>components</code>. Essa fun&ccedil;&atilde;o pode ser particularmente &uacute;til quando uma matriz &eacute; atribu&iacute;da
a um tensor indicial usando <code>components</code>, como demonstrado atrav&eacute;s do
seguinte exemplo:
</p>
<pre class="example">
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre>
<p>O comando <code>showcomps</code> pode tamb&eacute;m mostrar componentes de um tensor de
categoria maior que 2.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>idummy</b><i> ()</i>
<a name="IDX870"></a>
</dt>
<dd><p>Incrementos <code>icounter</code> e retorno como seu valor um &iacute;ndice da forma
<code>%n</code> onde n &eacute; um inteiro positivo.  Isso garante que &iacute;ndices que ocorrem exatamente duas vezes
e que s&atilde;o necess&aacute;rios na forma&ccedil;&atilde;o de express&otilde;es n&atilde;o ir&atilde;o conflitar com &iacute;ndices
que j&aacute; estiverem sendo usados (veja o exemplo sob <code>indices</code>).
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>idummyx</b>
<a name="IDX871"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>%</code>
</p>
<p>&Eacute; o prefixo para &iacute;ndices que ocorrem exatamente duas vezes (veja o exemplo sob &iacute;ndices <code>indices</code>).
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de Op&ccedil;&atilde;o:</u> <b>icounter</b>
<a name="IDX872"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>1</code>
</p>
<p>Determina o sufixo num&eacute;rico a ser usado na
gera&ccedil;&atilde;o do pr&oacute;ximo &iacute;ndice que ocorre exatamente duas vezes no pacote tensor.  O prefixo &eacute;
determinado atrav&eacute;s da op&ccedil;&atilde;o <code>idummy</code> (padr&atilde;o: <code>%</code>).
</p></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>kdelta</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX873"></a>
</dt>
<dd><p>&eacute; a fun&ccedil;&atilde;o delta generalizada de Kronecker definida no
pacote <code>itensor</code> com <var>L1</var> a lista de &iacute;ndices covariantes e <var>L2</var>
a lista de &iacute;ndices contravariantes.  <code>kdelta([i],[j])</code> retorna o delta de
Kronecker comum.  O comando <code>ev(<var>expr</var>,kdelta)</code> faz com que a avalia&ccedil;&atilde;o de
uma express&atilde;o contendo <code>kdelta([],[])</code> se d&ecirc; para a dimens&atilde;o de
multiplica&ccedil;&atilde;o.
</p>
<p>No que conduzir a um abuso dessa nota&ccedil;&atilde;o, <code>itensor</code> tamb&eacute;m permite
<code>kdelta</code> ter 2 covariantes e nenhum contravariante, ou 2 contravariantes
e nenhum &iacute;ndice covariante, com efeito fornecendo uma compatibilidade para &quot;matriz unit&aacute;ria&quot; covariante ou
contravariante. Isso &eacute; estritamente considerado um recurso de programa&ccedil;&atilde;o e n&atilde;o significa
implicar que <code>kdelta([i,j],[])</code> seja um objeto tensorial v&aacute;lido.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>kdels</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX874"></a>
</dt>
<dd><p>Delta de Kronecker simetrizado, usado em alguns c&aacute;lculos. Por exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>levi_civita</b><i> (<var>L</var>)</i>
<a name="IDX875"></a>
</dt>
<dd><p>&eacute; o tensor de permuta&ccedil;&atilde;o (ou de Levi-Civita) que retorna 1 se
a lista <var>L</var> consistir de uma permuta&ccedil;&atilde;o par de inteiros, -1 se isso
consistir de uma permuta&ccedil;&atilde;o &iacute;mpar, e 0 se alguns &iacute;ndices em <var>L</var> forem
repetidos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lc2kdt</b><i> (<var>expr</var>)</i>
<a name="IDX876"></a>
</dt>
<dd><p>Simplifica express&otilde;es contendo os s&iacute;mbolos de Levi-Civita, convertendo esses
para express&otilde;es delta de Kronecker quando poss&iacute;vel. A principal diferen&ccedil;a entre
essa fun&ccedil;&atilde;o e simplesmente avaliar os simbolos de Levi-Civita &eacute; que a avalia&ccedil;&atilde;o
direta muitas vezes resulta em express&otilde;es Kronecker contendo &iacute;ndices
num&eacute;ricos. Isso &eacute; muitas vezes indesej&aacute;vel como na preven&ccedil;&atilde;o de simplifica&ccedil;&atilde;o adicional.
A fun&ccedil;&atilde;o <code>lc2kdt</code> evita esse problema, retornando express&otilde;es que
s&atilde;o mais facilmente simplificadas com <code>rename</code> ou <code>contract</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

</pre>
<p>A fun&ccedil;&atilde;o <code>lc2kdt</code> algumas vezes faz uso de tensores m&eacute;tricos.
Se o tensor m&eacute;trico n&atilde;o tiver sido definido previamente com <code>imetric</code>,
isso resulta em um erro.
</p>
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j       k
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                    %3             %4               %3             %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i      l i
(%t11)                           a    - a g

</pre>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lc_l</b>
<a name="IDX877"></a>
</dt>
<dd><p>Regra de simplifica&ccedil;&atilde;o usada para express&otilde;es contendo s&iacute;mbolos n&atilde;o avaliados de
Levi-Civita (<code>levi_civita</code>). Juntamente com <code>lc_u</code>, pode ser usada para simplificar
muitas express&otilde;es mais eficientemente que a avalia&ccedil;&atilde;o de <code>levi_civita</code>.
Por exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
(%t5)                                  0

</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lc_u</b>
<a name="IDX878"></a>
</dt>
<dd><p>Regra de simplifica&ccedil;&atilde;o usada para express&otilde;es contendo s&iacute;mbolos n&atilde;o avaliados de
Levi-Civita (<code>levi_civita</code>). Juntamente com <code>lc_u</code>, pode ser usada para simplificar
muitas express&otilde;es mais eficientemente que a avalia&ccedil;&atilde;o de <code>levi_civita</code>.
Para detalhes, veja <code>lc_l</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>canten</b><i> (<var>expr</var>)</i>
<a name="IDX879"></a>
</dt>
<dd><p>Simplifica <var>expr</var> por renomea&ccedil;&atilde;o (veja <code>rename</code>)
e permutando &iacute;ndices que ocorrem exatamente duas vezes. <code>rename</code> &eacute; restrito a adi&ccedil;&otilde;es de produto
de tensores nos quais nenhum &iacute;ndice derivativo estiver presente. Como tal isso &eacute; limitado
e pode somente ser usado se <code>canform</code> n&atilde;o for capaz de realizar a
simplifica&ccedil;&atilde;o requerida.
</p>
<p>A fun&ccedil;&atilde;o <code>canten</code> retorna um resultado matematicamente correto somente
se seu argumento for uma express&atilde;o que &eacute; completamente sim&eacute;trica em seus &iacute;ndices.
Por essa raz&atilde;o, <code>canten</code> retorna um erro se <code>allsym</code> n&atilde;o for
posicionada em <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>concan</b><i> (<var>expr</var>)</i>
<a name="IDX880"></a>
</dt>
<dd><p>Similar a <code>canten</code> mas tamb&eacute;m executa contra&ccedil;&atilde;o de &iacute;ndices.
</p>
</dd></dl>

<hr size="6">
<a name="SEC95"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC94" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.2 Simetrias de tensores </h3>

<dl>
<dt><u>Vari&aacute;vel de Op&ccedil;&atilde;o:</u> <b>allsym</b>
<a name="IDX881"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>. Se <code>true</code> ent&atilde;o todos os objetos indexados
s&atilde;o assumidos sim&eacute;tricos em todos os seus &iacute;ndices covariantes e
contravariantes. Se <code>false</code> ent&atilde;o nenhum sim&eacute;trico de qualquer tipo &eacute; assumidos
nesses &iacute;ndices. &Iacute;ndices derivativos s&atilde;o sempre tomados para serem sim&eacute;tricos
a menos que <code>iframe_flag</code> seja escolhida para <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>decsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</i>
<a name="IDX882"></a>
</dt>
<dd><p>Declara propriedades de simetria para <var>tensor</var> de covariante <var>m</var> e
<var>n</var> &iacute;ndices contravariantes. As <var>cov_i</var> e <var>contr_i</var> s&atilde;o
pseudofun&ccedil;&otilde;es expressando rela&ccedil;&otilde;es de simetrias em meio a &iacute;ndices covariante e
&iacute;ndices contravariantes respectivamente.  Esses s&atilde;o da forma
<code>symoper(<var>index_1</var>, <var>index_2</var>,...)</code> onde <code>symoper</code> &eacute; um entre
<code>sym</code>, <code>anti</code> ou <code>cyc</code> e os <var>index_i</var> s&atilde;o inteiros
indicando a posi&ccedil;&atilde;o do &iacute;ndice no <var>tensor</var>.  Isso ir&aacute;
declarar <var>tensor</var> para ser sim&eacute;trico, antisim&eacute;trico ou c&iacute;clico respectivamente
nos <var>index_i</var>. <code>symoper(all)</code> &eacute; tamb&eacute;m forma permitida que
indica todos os &iacute;ndices obedecem &agrave; condi&ccedil;&atilde;o de simetria. Por exemplo, dado um
objeto <code>b</code> com 5 &iacute;ndices covariantes,
<code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> declara <code>b</code>
sim&eacute;trico no seu primeiro e no seu segundo &iacute;ndices e antisim&eacute;trico no seu terceiro e
quarto &iacute;ndices covariantes, e c&iacute;clico em todos de seus &iacute;ndices contravariantes.
Qualquer lista de declara&ccedil;&otilde;es de simetria pode ser nula.  A fun&ccedil;&atilde;o que
executa as simplifica&ccedil;&otilde;es &eacute; <code>canform</code> como o exemplo abaixo
ilustra.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>)</i>
<a name="IDX883"></a>
</dt>
<dd><p>Remove todas as propriedades de simetria de <var>tensor</var> que tem <var>m</var>
&iacute;ndices covariantes e <var>n</var> &iacute;ndices contravariantes.
</p></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>canform</b><i> (<var>expr</var>)</i>
<a name="IDX884"></a>
</dt>
<dd><p>Simplifica <var>expr</var> atrav&eacute;s de mudan&ccedil;a de nome de &iacute;ndices
que ocorrem exatamente duas vezes e reordena&ccedil;&atilde;o de todos os &iacute;ndices como ditados pelas condi&ccedil;&otilde;es de simetria
impostas sobre eles. Se <code>allsym</code> for <code>true</code> ent&atilde;o todos os &iacute;ndices s&atilde;o assumidos
sim&eacute;tricos, de outra forma a informa&ccedil;&atilde;o de simetria fornecida pelas declara&ccedil;&otilde;es
<code>decsym</code> ir&atilde;o ser usadas. Os &iacute;ndices que ocorrem exatamente duas vezes s&atilde;o renomeados da mesma
maneira que na fun&ccedil;&atilde;o <code>rename</code>. Quando <code>canform</code> &eacute; aplicada a uma express&atilde;o
larga o c&aacute;lculo pode tomar um consider&aacute;vel montante de tempo.
Esse tempo pode ser diminu&iacute;do atrav&eacute;s do uso de <code>rename</code> sobre a express&atilde;o em primeiro lugar.
Tamb&eacute;m veja o exemplo sob <code>decsym</code>. Nota: <code>canform</code> pode n&atilde;o estar apta a
reduzir um express&atilde;o completamente para sua forma mais simples embora
retorne sempre um resultado matem&aacute;ticamente correto.
</p></dd></dl>

<hr size="6">
<a name="SEC96"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC95" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC97" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.3 C&aacute;lculo de tensores indiciais </h3>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>diff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</i>
<a name="IDX885"></a>
</dt>
<dd><p>&Eacute; a fun&ccedil;&atilde;o usual de diferencia&ccedil;&atilde;o do Maxima que tem sido expandida
nessas habilidades para <code>itensor</code>. <code>diff</code> toma a derivada de <var>expr</var>
 <var>n_1</var> vezes com rela&ccedil;&atilde;o a <var>v_1</var>, <var>n_2</var> vezes com rela&ccedil;&atilde;o a <var>v_2</var>
, etc. Para o pacote <code>tensor</code>, a fun&ccedil;&atilde;o tem sido modificada de
forma que os <var>v_i</var> possam ser inteiros de 1 at&eacute; o valor da vari&aacute;vel
<code>dim</code>.  Isso causar&aacute; a conclus&atilde;o da diferencia&ccedil;&atilde;o com
rela&ccedil;&atilde;o ao <var>v_i</var>&eacute;simo membro da lista <code>vect_coords</code>.  Se
<code>vect_coords</code> for associado a uma vari&aacute;vel at&ocirc;mica, ent&atilde;o aquela vari&aacute;vel
subscrita atrav&eacute;s de <var>v_i</var> ser&aacute; usada para a vari&aacute;vel de
diferencia&ccedil;&atilde;o.  Isso permite que um array de nomes de coordenadas ou
nomes subscritos como <code>x[1]</code>, <code>x[2]</code>, ...  sejam usados.
</p></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>idiff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</i>
<a name="IDX886"></a>
</dt>
<dd><p>Diferencia&ccedil;&atilde;o indicial. A menos que <code>diff</code>, que diferencia
com rela&ccedil;&atilde;o a uma vari&aacute;vel independente, <code>idiff</code> possa ser usada
para diferenciar com rela&ccedil;&atilde;o a uma coordenada. Para um objeto indexado,
isso equivale a anexar ao final os <var>v_i</var> como &iacute;ndices derivativos.
Subseq&uuml;&ecirc;ntemente, &iacute;ndices derivativos ir&atilde;o ser ordenados, a menos que <code>iframe_flag</code>
seja escolhida para <code>true</code>.
</p>
<p><code>idiff</code> pode tamb&eacute;m ser o determinante de um tensor
m&eacute;trico. Dessa forma, se <code>imetric</code> tiver sido associada a <code>G</code> ent&atilde;o
<code>idiff(determinant(g),k)</code> ir&aacute; retornar
<code>2*determinant(g)*ichr2([%i,k],[%i])</code> onde o &iacute;ndice que ocorre exatamente duas vezes <code>%i</code>
&eacute; escolhido apropriadamente.
</p>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>liediff</b><i> (<var>v</var>, <var>ten</var>)</i>
<a name="IDX887"></a>
</dt>
<dd><p>Calcula a derivada de Lie da express&atilde;o tensorial <var>ten</var> com
rela&ccedil;&atilde;o ao campo vetorial <var>v</var>. <var>ten</var> pode ser qualquer express&atilde;o tensorial
indexada; <var>v</var> pode ser o nome (sem &iacute;ndices) de um campo
vetorial. Por exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                                %1  k        %1  k      %1  k
                            + (v   b      - b   v    + v   b   ) a
                                    ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rediff</b><i> (<var>ten</var>)</i>
<a name="IDX888"></a>
</dt>
<dd><p>Avalia todas as ocorr&ecirc;ncias do comando <code>idiff</code> na express&atilde;o
tensorial <var>ten</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>undiff</b><i> (<var>expr</var>)</i>
<a name="IDX889"></a>
</dt>
<dd><p>Retorna uma express&atilde;o equivalente a <var>expr</var> mas com todas as derivadas
de objetos indexados substitu&iacute;das pela forma substantiva da fun&ccedil;&atilde;o <code>idiff</code>. Seu
argumento pode retornar aquele objeto indexado se a diferencia&ccedil;&atilde;o for
conclu&iacute;da.  Isso &eacute; &uacute;til quando for desejado substituir um
objeto indexado que sofreu diferencia&ccedil;&atilde;o com alguma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o resultando
em <var>expr</var> e ent&atilde;o concluir a diferencia&ccedil;&atilde;o atrav&eacute;s de digamos
<code>ev(<var>expr</var>, idiff)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>evundiff</b><i> (<var>expr</var>)</i>
<a name="IDX890"></a>
</dt>
<dd><p>Equivalente &agrave; execu&ccedil;&atilde;o de <code>undiff</code>, seguida por <code>ev</code> e
<code>rediff</code>.
</p>
<p>O ponto dessa opera&ccedil;&atilde;o &eacute; facilmente avaliar express&otilde;es que n&atilde;o possam
ser diretamente avaliadas na forma derivada. Por exemplo, o seguinte
causa um erro:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Todavia, se <code>icurvature</code> &eacute; informado em sua forma substantiva, pode ser avaliado
usando <code>evundiff</code>:
</p>
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

                l              l         %1           l           %1
         + ichr2        + ichr2     ichr2      + ichr2       ichr2
                i j,k m        %1 k      i j,m        %1 k,m      i j
</pre>
<p>Nota: Em vers&otilde;es anteriores do Maxima, formas derivadas dos
s&iacute;mbolos de Christoffel tamb&eacute;m n&atilde;o podiam ser avaliadas. Isso foi corrigido atualmente,
de forma que <code>evundiff</code> n&atilde;o mais &eacute; necess&aacute;ria para express&otilde;es como essa:
</p>
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flush</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX891"></a>
</dt>
<dd><p>Escolhe para zero, em
<var>expr</var>, todas as ocorr&ecirc;ncias de <var>tensor_i</var> que n&atilde;o tiverem &iacute;ndices derivativos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flushd</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX892"></a>
</dt>
<dd><p>Escolhe para zero, em
<var>expr</var>, todas as ocorr&ecirc;ncias de <var>tensor_i</var> que tiverem &iacute;ndices derivativos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flushnd</b><i> (<var>expr</var>, <var>tensor</var>, <var>n</var>)</i>
<a name="IDX893"></a>
</dt>
<dd><p>Escolhe para zero, em <var>expr</var>, todas as
ocorr&ecirc;ncias do objeto diferenciado <var>tensor</var> que tem <var>n</var> ou mais
&iacute;ndices derivativos como demonstra o seguinte exemplo.
</p><pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>coord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX894"></a>
</dt>
<dd><p>Dados os <var>tensor_i</var> a propriedade de diferencia&ccedil;&atilde;o da coordenada que a
derivada do vetor contravariante cujo nome &eacute; um dos
<var>tensor_i</var> retorna um delta de Kronecker. Por exemplo, se <code>coord(x)</code> tiver
sido conclu&iacute;da ent&atilde;o <code>idiff(x([],[i]),j)</code> fornece <code>kdelta([i],[j])</code>.
<code>coord</code> que &eacute; uma lista de todos os objetos indexados tendo essa propriedade.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remcoord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX895"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remcoord</b><i> (all)</i>
<a name="IDX896"></a>
</dt>
<dd><p>Remove a propriedade de coordenada de diferencia&ccedil;&atilde;o dos <code>tensor_i</code>
que foram estabelecidos atrav&eacute;s da fun&ccedil;&atilde;o <code>coord</code>.  <code>remcoord(all)</code>
remove essa propriedade de todos os objetos indexados.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>makebox</b><i> (<var>expr</var>)</i>
<a name="IDX897"></a>
</dt>
<dd><p>Mostra <var>expr</var> da mesma maneira que <code>show</code>; todavia,
qualquer tensor d'Alembertiano ocorrendo em <var>expr</var> ser&aacute; indicado usando o
s&iacute;mbolo <code>[]</code>.  Por exemplo, <code>[]p([m],[n])</code> representa
<code>g([],[i,j])*p([m],[n],i,j)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>conmetderiv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX898"></a>
</dt>
<dd><p>Simplifica express&otilde;es contendo derivadas comuns de
ambas as formas covariantes e contravariantes do tensor m&eacute;trico (a
restri&ccedil;&atilde;o corrente).  Por exemplo, <code>conmetderiv</code> pode relatar a
derivada do tensor contravariante m&eacute;trico com s&iacute;mbolos de
Christoffel como visto adiante:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>simpmetderiv</b><i> (<var>expr</var>)</i>
<a name="IDX899"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>simpmetderiv</b><i> (<var>expr</var>[, <var>stop</var>])</i>
<a name="IDX900"></a>
</dt>
<dd><p>Simplifica express&otilde;es contendo produtos de derivadas de
tensores m&eacute;tricos. Especificamente, <code>simpmetderiv</code> reconhece duas identidades:
</p>
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre>
<p>conseq&uuml;&ecirc;ntemente
</p>
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre>
<p>e
</p>
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre>
<p>que seguem de simetrias de s&iacute;mbolos de Christoffel.
</p>
<p>A fun&ccedil;&atilde;o <code>simpmetderiv</code> toma um par&acirc;metro opcional que, quando
presente, faz com que a fun&ccedil;&atilde;o pare ap&oacute;s a primeira substitui&ccedil;&atilde;o feita com
sucesso em uma express&atilde;o produto. A fun&ccedil;&atilde;o <code>simpmetderiv</code>
tamb&eacute;m faz uso da vari&aacute;vel global <var>flipflag</var> que determina
como aplicar uma ordena&ccedil;&atilde;o &quot;canonica&quot; para os &iacute;ndices de produto.
</p>
<p>Colocados juntos, essas compatibilidades podem ser usadas poderosamente para encontrar
simplifica&ccedil;&otilde;es que s&atilde;o dif&iacute;ceis ou imposs&iacute;veis de realizar de outra forma.
Isso &eacute; demonstrado atrav&eacute;s do seguinte exemplo que explicitamente usa o 
recurso de simplifica&ccedil;&atilde;o parcial de <code>simpmetderiv</code> para obter uma
express&atilde;o contract&iacute;vel:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre>
<p>Veja tamb&eacute;m <code>weyl.dem</code> para um exemplo que usa <code>simpmetderiv</code>
e <code>conmetderiv</code> juntos para simplificar contra&ccedil;&otilde;es do tensor de Weyl.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flush1deriv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX901"></a>
</dt>
<dd><p>Escolhe para zero, em <code>expr</code>, todas as ocorr&ecirc;ncias de <code>tensor</code> que possuem
exatamente um &iacute;ndice derivativo.
</p>
</dd></dl>

<hr size="6">
<a name="SEC97"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC96" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.4 Tensores em espa&ccedil;os curvos </h3>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>imetric</b><i> (<var>g</var>)</i>
<a name="IDX902"></a>
</dt>
<dt><u>Vari&aacute;vel de sistema:</u> <b>imetric</b>
<a name="IDX903"></a>
</dt>
<dd><p>Especifica a m&eacute;trica atrav&eacute;s de atribui&ccedil;&atilde;o &agrave; vari&aacute;vel <code>imetric:<var>g</var></code>
adicionalmente, as propriedades de contra&ccedil;&atilde;o da m&eacute;trica <var>g</var> s&atilde;o escolhidas atrav&eacute;s da
execu&ccedil;&atilde;o dos comandos <code>defcon(<var>g</var>),defcon(<var>g</var>,<var>g</var>,kdelta)</code>.
A vari&aacute;vel <code>imetric</code> (desassociada por padr&atilde;o), &eacute; associada &agrave; m&eacute;trica, atribuida pelo
comando <code>imetric(<var>g</var>)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>idim</b><i> (<var>n</var>)</i>
<a name="IDX904"></a>
</dt>
<dd><p>Escolhe as dimens&otilde;es da m&eacute;trica. Tamb&eacute;m inicializa as propriedades de
antisimetria dos s&iacute;mbolos de Levi-Civita para as dimens&otilde;es dadas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ichr1</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>])</i>
<a name="IDX905"></a>
</dt>
<dd><p>Retorna o s&iacute;mbolo de Christoffel de primeiro tipo via
defini&ccedil;&atilde;o
</p><pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre>
<p>Para avaliar os s&iacute;mbolos de Christoffel para uma m&eacute;trica particular, &agrave;
vari&aacute;vel <code>imetric</code> deve ser atribu&iacute;da um nome como no exemplo sob <code>chr2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ichr2</b><i> ([<var>i</var>, <var>j</var>], [<var>k</var>])</i>
<a name="IDX906"></a>
</dt>
<dd><p>Retorna o s&iacute;mbolo de Christoffel de segundo tipo
definido pela rela&ccedil;&atilde;o
</p><pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>icurvature</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</i>
<a name="IDX907"></a>
</dt>
<dd><p>Retorna o tensor da curvatura de
Riemann em termos de s&iacute;mbolos de Christoffel de segundo
tipo (<code>ichr2</code>).  A seguinte nota&ccedil;&atilde;o &eacute; usada:
</p><pre class="example">               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>covdiff</b><i> (<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</i>
<a name="IDX908"></a>
</dt>
<dd><p>Retorna a derivada da covariante de <var>expr</var> com
rela&ccedil;&atilde;o &agrave;s vari&aacute;veis <var>v_i</var> em termos de s&iacute;mbolos de Christoffel de
segundo tipo (<code>ichr2</code>).  Com o objetivo de avaliar esses, se pode usar
<code>ev(<var>expr</var>,ichr2)</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the &iacute;ndices covariantes: [i,j];
Enter a list of the &iacute;ndices contravariantes: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k            k     %1
(%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
             i %1      j s    %1 j      i s    i j,s        %1 s  i j
(%i4) imetric:g;
(%o4)            g
(%i5) ishow(ev(%th(2),ichr2))$
  %1 %4  k
 g      a     (g       - g       + g  )
  i %1   s %4,j  j s,%4    j %4,s
(%t5) - ------------------------------------------
       2
    %1 %3  k
   g   a     (g       - g    + g     )
    %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
         2
    k %2  %1
   g     a    (g        - g    + g      )
   i j   s %2,%1    %1 s,%2    %1 %2,s   k
 + ------------------------------------------- + a
   2     i j,s
(%i6) 
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lorentz_gauge</b><i> (<var>expr</var>)</i>
<a name="IDX909"></a>
</dt>
<dd><p>Imp&otilde;e a condi&ccedil;&atilde;o de Lorentz atrav&eacute;s da substitui&ccedil;&atilde;o de 0 para todos os
objetos indexados em <var>expr</var> que possui um &iacute;ndice de derivada id&ecirc;ntico ao
&iacute;ndice contravariante.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>igeodesic_coords</b><i> (<var>expr</var>, <var>nome</var>)</i>
<a name="IDX910"></a>
</dt>
<dd><p>Faz com que s&iacute;mbolos de Christoffel n&atilde;o diferenciados e
a primeira derivada do tensor m&eacute;trico tendam para zero em <var>expr</var>. O <var>nome</var>
na fun&ccedil;&atilde;o <code>igeodesic_coords</code> refere-se &agrave; m&eacute;trica <var>nome</var>
(se isso aparecer em <var>expr</var>) enquando os coeficientes de conec&ccedil;&atilde;o devem ser
chamados com os nomes <code>ichr1</code> e/ou <code>ichr2</code>. O seguinte exemplo
demonstra a verifica&ccedil;&atilde;o da identidade c&iacute;clica satisfeita atrav&eacute;s do tensor da
curvatura de Riemann usando a fun&ccedil;&atilde;o <code>igeodesic_coords</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u            u         %1
(%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
             r t,s        %1 s      r t        r s,t        %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t        r t,s

                                                                  u
                                                           + ichr2
                                                                  r s,t
(%i5) canform(%);
(%o5)                                  0

</pre>
</dd></dl>

<hr size="6">
<a name="SEC98"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC97" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC99" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.5 Molduras m&oacute;veis </h3>

<p>Maxima atualmente tem a habilidade de executar c&aacute;lculos usando molduras m&oacute;veis.
Essas podem ser molduras ortonormais (tetrads, vielbeins) ou uma moldura arbitr&aacute;ria.
</p>
<p>Para usar molduras, voc&ecirc; primeiro escolhe <code>iframe_flag</code> para <code>true</code>. Isso
faz com que os s&iacute;mbolos de Christoffel, <code>ichr1</code> e <code>ichr2</code>, sejam substitu&iacute;dos
pelas molduras mais gerais de coeficientes de conec&ccedil;&atilde;o <code>icc1</code> e <code>icc2</code>
em c&aacute;lculos. Especialmente, o comportamento de <code>covdiff</code> e
<code>icurvature</code> s&atilde;o alterados.
</p>
<p>A moldura &eacute; definida atrav&eacute;s de dois tensores: o campo de moldura inversa (<code>ifri</code>),
a base tetrad dual),
e a m&eacute;trica da moldura <code>ifg</code>. A m&eacute;trica da moldura &eacute; a matriz identidade para
molduras ortonormais, ou a m&eacute;trica de Lorentz para molduras ortonormais no espa&ccedil;o-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores unit&aacute;rios).
Propriedades de contra&ccedil;&atilde;o s&atilde;o definidas para o campo de moldura e para a m&eacute;trica da moldura.
</p>
<p>Quando <code>iframe_flag</code> for <code>true</code>, muitas express&otilde;es <code>itensor</code> usam a m&eacute;trica da
moldura <code>ifg</code> em lugar da m&eacute;trica definida atrav&eacute;s de <code>imetric</code> para
o decremento e para o incremento de &iacute;ndices.
</p>
<p>IMPORTANTE: Escolhendo a vari&aacute;vel <code>iframe_flag</code> para <code>true</code> N&Atilde;O
remove a defini&ccedil;&atilde;o das propriedades de contra&ccedil;&atilde;o de uma m&eacute;trica definida atrav&eacute;s de uma chamada a
<code>defcon</code> ou <code>imetric</code>. Se um campo de moldura for usado, ele &eacute; melhor para
definir a m&eacute;trica atrav&eacute;s de atribui&ccedil;&atilde;o desse nome para a vari&aacute;vel <code>imetric</code>
e N&Atilde;O invoque a fun&ccedil;&atilde;o <code>imetric</code>.
</p>
<p>Maxima usa esses dois tensores para definir os coeficientes de moldura (<code>ifc1</code>
e <code>ifc2</code>) cuja forma parte dos coeficientes de conec&ccedil;&atilde;o (<code>icc1</code>
e <code>icc2</code>), como demonstra o seguinte exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                        %1      i           i        i
(%t4)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i5) ishow(ev(%,ifc2))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t5)      -------------------------------------------------- + v
                                   2                             ,j
(%i6) ishow(ifb([a,b,c]))$
                       %5    %4
(%t6)               ifr   ifr   (ifri        - ifri       )
                       a     b       c %4,%5       c %5,%4

</pre>
<p>Um m&eacute;todo alternativo &eacute; usado para calcular o suporte da moldura (<code>ifb</code>) se
o sinalizador <code>iframe_bracket_form</code> &eacute; escolhido para <code>false</code>:
</p>
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                       %7    %6        %6      %7
(%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                       a     b,%7      a,%7    b       c %6

</pre>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>iframes</b><i> ()</i>
<a name="IDX911"></a>
</dt>
<dd><p>Uma vez que nessa vers&atilde;o do Maxima, identidades de contra&ccedil;&atilde;o para <code>ifr</code> e
<code>ifri</code> s&atilde;o sempre definidas, como &eacute; o suporte da moldura (<code>ifb</code>), essa
fun&ccedil;&atilde;o n&atilde;o faz nada.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifb</b>
<a name="IDX912"></a>
</dt>
<dd><p>O suporte da moldura. A contribui&ccedil;&atilde;o da m&eacute;trica da moldura para os coeficientes
de conec&ccedil;&atilde;o &eacute; expressa usando o suporte da moldura:
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre>
<p>O suporte da moldura por si mesmo &eacute; definido em termos de campo de moldura e m&eacute;trica da
moldura. Dois m&eacute;todos alternativos de c&aacute;lculo s&atilde;o usados dependendo do
valor de <code>frame_bracket_form</code>. Se <code>true</code> (o padr&atilde;o) ou se o sinalizador
<code>itorsion_flag</code> for <code>true</code>:
</p>
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre>
<p>Otherwise:
</p>
<pre class="example">
             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre>

</dd></dl>


<dl>
<dt><u>Vari&aacute;vel:</u> <b>icc1</b>
<a name="IDX913"></a>
</dt>
<dd><p>Coeficientes de conec&ccedil;&atilde;o de primeiro tipo. Em <code>itensor</code>, definido como
</p>
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre>
<p>Nessa express&atilde;o, se <code>iframe_flag</code> for <code>true</code>, o s&iacute;mbolo de Christoffel
<code>ichr1</code> &eacute; substitu&iacute;do com o coeficiente de conec&ccedil;&atilde;o da moldura <code>ifc1</code>.
Se <code>itorsion_flag</code> for <code>false</code>, <code>ikt1</code>
ser&aacute; omitido. <code>ikt1</code> &eacute; tamb&eacute;m omitido se uma base de moldura for usada, como a
tors&atilde;o est&aacute; j&aacute; calculada como parte do suporte da moldura.
Ultimamente, como <code>inonmet_flag</code> &eacute; <code>false</code>,
<code>inmc1</code> n&atilde;o estar&aacute; presente.
</p>

</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>icc2</b>
<a name="IDX914"></a>
</dt>
<dd><p>Coeficientes de conec&ccedil;&atilde;o de segundo tipo. Em <code>itensor</code>, definido como
</p>
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre>
<p>Nessa express&atilde;o, se <code>iframe_flag</code> for <code>true</code>, o s&iacute;mbolo de Christoffel
<code>ichr2</code> &eacute; substitu&iacute;do com o coeficiente de conec&ccedil;&atilde;o <code>ifc2</code>.
Se <code>itorsion_flag</code> for <code>false</code>, <code>ikt2</code>
ser&aacute; omitido. <code>ikt2</code> tamb&eacute;m ser&aacute; omitido se uma base de moldura for usada, uma vez que a
tors&atilde;o j&aacute; est&aacute; calculada como parte do suporte da moldura.
Ultimamente, como <code>inonmet_flag</code> &eacute; <code>false</code>,
<code>inmc2</code> n&atilde;o estar&aacute; presente.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifc1</b>
<a name="IDX915"></a>
</dt>
<dd><p>Coeficiente de moldura de primeiro tipo (tamb&eacute;m conhecido como coeficientes de
rota&ccedil;&atilde;o de Ricci).  Esse tensor representa a contribui&ccedil;&atilde;o
da m&eacute;trica da moldura para o coeficiente de conec&ccedil;&atilde;o de primeiro tipo. Definido
como:
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifc2</b>
<a name="IDX916"></a>
</dt>
<dd><p>Coeficiente de moldura de primeiro tipo. Esse tensor representa a contribui&ccedil;&atilde;o
da m&eacute;trica da moldura para o coeficiente de conec&ccedil;&atilde;o de primeiro tipo. Definido
como uma permuta&ccedil;&atilde;o de suporte de moldura (<code>ifb</code>) com os &iacute;ndices
apropriados incrementados e decrementados como necess&aacute;rio:
</p>
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifr</b>
<a name="IDX917"></a>
</dt>
<dd><p>O campo da moldura. Contrai (<code>ifri</code>) para e com a forma do campo inverso da
moldura para formar a m&eacute;trica da moldura (<code>ifg</code>).
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifri</b>
<a name="IDX918"></a>
</dt>
<dd><p>O campo inverso da moldura. Especifica a base da moldura (vetores base duais). Juntamente
com a m&eacute;trica da moldura, forma a base de todos os c&aacute;lculos baseados em
molduras.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifg</b>
<a name="IDX919"></a>
</dt>
<dd><p>A m&eacute;trica da moldura. O valor padr&atilde;o &eacute; <code>kdelta</code>, mas pode ser mudada usando
<code>components</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ifgi</b>
<a name="IDX920"></a>
</dt>
<dd><p>O inverso da m&eacute;trica da moldura. Contrai com a m&eacute;trica da moldura (<code>ifg</code>)
para <code>kdelta</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de Op&ccedil;&atilde;o:</u> <b>iframe_bracket_form</b>
<a name="IDX921"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Especifica como o suporte da moldura (<code>ifb</code>) &eacute; calculado.
</p>
</dd></dl>

<hr size="6">
<a name="SEC99"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC98" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC100" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.6 Tors&atilde;o e n&atilde;o metricidade </h3>

<p>Maxima pode trabalhar com tors&atilde;o e n&atilde;o metricidade. Quando o sinalizador
<code>itorsion_flag</code> for escolhido para <code>true</code>, a contribui&ccedil;&atilde;o de tors&atilde;o
&eacute; adicionada aos coeficientes de conec&ccedil;&atilde;o. Similarmente, quando o sinalizador
<code>inonmet_flag</code> for <code>true</code>, componentes de n&atilde;o metricidades s&atilde;o inclu&iacute;dos.
</p>
<dl>
<dt><u>Vari&aacute;vel:</u> <b>inm</b>
<a name="IDX922"></a>
</dt>
<dd><p>O vetor de n&atilde;o metricidade. Conforme a n&atilde;o metricidade est&aacute; definida atrav&eacute;s da
derivada covariante do tensor m&eacute;trico. Normalmente zero, o tensor da
m&eacute;trica derivada covariante ir&aacute; avaliar para o seguinte quando
<code>inonmet_flag</code> for escolhido para <code>true</code>:
</p>
<pre class="example">
g     =- g  inm
 ij;k     ij  k

</pre>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel:</u> <b>inmc1</b>
<a name="IDX923"></a>
</dt>
<dd><p>Permuta&ccedil;&atilde;o covariante de componentes do vetor de n&atilde;o metricidade. Definida como
</p>
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre>
<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura m&eacute;trica for usada.)
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>inmc2</b>
<a name="IDX924"></a>
</dt>
<dd><p>Permuta&ccedil;&atilde;o covariante de componentes do vetor de n&atilde;o metricidade. Usada
nos coeficicientes de conec&ccedil;&atilde;o se <code>inonmet_flag</code> for <code>true</code>. Definida
como:
</p>
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre>
<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura m&eacute;trica for usada.)
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ikt1</b>
<a name="IDX925"></a>
</dt>
<dd><p>Permuta&ccedil;&atilde;o covariante do tensor de tors&atilde;o (tamb&eacute;m conhecido como contors&atilde;o).
Definido como:
</p>
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre>
<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura m&eacute;trica for usada.)
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>ikt2</b>
<a name="IDX926"></a>
</dt>
<dd><p>Permuta&ccedil;&atilde;o contravariante do tensor de tors&atilde;o (tamb&eacute;m conhecida como contors&atilde;o).
Definida como:
</p>
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre>
<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura m&eacute;trica for usada.)
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>itr</b>
<a name="IDX927"></a>
</dt>
<dd><p>O tensor de tors&atilde;o. Para uma m&eacute;trica com tors&atilde;o, diferencia&ccedil;&atilde;o covariante
repetida sobre uma fun&ccedil;&agrave;o escalar n&atilde;o ir&aacute; comutar,como demonstrado
atrav&eacute;s do seguinte exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre>
</dd></dl>

<hr size="6">
<a name="SEC100"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC99" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC101" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.7 &Aacute;lgebra externa (como em produto externo) </h3>

<p>O pacote <code>itensor</code> pode executar opera&ccedil;&otilde;es sobre campos tensores
covariantes totalmente antisim&eacute;tricos. Um campo tensor totalmente antisim&eacute;trico de classe
(0,L) corresponde a uma forma diferencial L. Sobre esses objetos, uma
opera&ccedil;&atilde;o de multiplica&ccedil;&atilde;o funciona como um produto externo, ou produto cunha,
&eacute; definido.
</p>
<p>Desafortunadamente, nem todos os autores concordam sobre a defini&ccedil;&atilde;o de produto
cunha. Alguns autores preferem uma defini&ccedil;&atilde;o que corresponde &agrave;
no&ccedil;&atilde;o de antisimetriza&ccedil;&atilde;o: nessas palavras, o produto cunha de
dois campos vetoriais, por exemplo, pode ser definido como
</p>
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre>
<p>Mais geralmente, o produto de uma forma p e uma forma q pode ser definido como
</p>
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>onde <code>D</code> simboliza o delta de Kronecker.
</p>
<p>Outros autores, todavia, preferem uma defini&ccedil;&atilde;o &quot;geom&eacute;trica&quot; que corresponde &agrave;
nota&ccedil;&atilde;o de elemento volume:
</p>
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre>
<p>e, no caso geral
</p>
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>Uma vez que <code>itensor</code> &eacute; um pacote de algebra de tensores, a primeira dessas duas
defini&ccedil;&otilde;es aparenta ser a mais natural por si mesma. Muitas aplica&ccedil;&otilde;es, todavia,
usam a segunda defini&ccedil;&atilde;o. Para resolver esse dilema, um sinalizador tem sido
implementado que controla o comportamento do produto cunha: se
<code>igeowedge_flag</code> for <code>false</code> (o padr&atilde;o), a primeira, defini&ccedil;&atilde;o
&quot;tensorial&quot; &eacute; usada, de outra forma a segunda, defini&ccedil;&atilde;o &quot;geom&eacute;trica&quot; ir&aacute;
ser aplicada.
</p>
<dl>
<dt><u>Operador:</u> <b>~</b>
<a name="IDX928"></a>
</dt>
<dd><p>O operador do produto cunha &eacute; definido como sendo o acento til <code>~</code>. O til &eacute;
um operador bin&aacute;rio. Seus argumentos podem ser express&otilde;es envolvendo escalares,
tensores covariantes de categoria 1, ou tensores covariantes de categoria <code>l</code> que
tiverem sido declarados antisim&eacute;tricos em todos os &iacute;ndices covariantes.
</p>
<p>O comportamento do operador do produto cunha &eacute; controlado atrav&eacute;s do
sinalizador <code>igeowedge_flag</code>, como no seguinte exemplo:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>|</b>
<a name="IDX929"></a>
</dt>
<dd><p>A barra vertical <code>|</code> denota a opera&ccedil;&atilde;o bin&aacute;ria
&quot;contra&ccedil;&atilde;o com um vetor&quot;. Quando um tensor covariante totalmente antisim&eacute;trico &eacute; contra&iacute;do
com um vetor contravariante, o resultado &eacute; o mesmo independente de qual &iacute;ndice
foi usado para a contra&ccedil;&atilde;o. Dessa forma, &eacute; poss&iacute;vel definir a
opera&ccedil;&atilde;o de contra&ccedil;&atilde;o de uma forma livre de &iacute;ndices.
</p>
<p>No pacote <code>itensor</code>, contra&ccedil;&atilde;o com um vetor &eacute; sempre realizada
com rela&ccedil;&atilde;o ao primeiro &iacute;ndice na ordem literal de ordena&ccedil;&atilde;o. Isso garante
uma melhor simplifica&ccedil;&atilde;o de express&otilde;es envolvendo o operador <code>|</code>. Por exemplo:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre>
<p>Note que isso &eacute; essencial que os tensores usado como o operador <code>|</code> seja
declarado totalmente antisim&eacute;trico em seus &iacute;ndices covariantes. De outra forma,
os resultados ser&atilde;o incorretos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>extdiff</b><i> (<var>expr</var>, <var>i</var>)</i>
<a name="IDX930"></a>
</dt>
<dd><p>Calcula a derivada externa de <var>expr</var> com rela&ccedil;&atilde;o ao &iacute;ndice
<var>i</var>. A derivada externa &eacute; formalmente definida como o produto
cunha do operador de derivada parcial e uma forma diferencial. Como
tal, essa opera&ccedil;&atilde;o &eacute; tamb&eacute;m controlada atrav&eacute;s da escolha de <code>igeowedge_flag</code>.
Por exemplo:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                      a      - a      + a
                            j k,i    i k,j    i j,k
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>hodge</b><i> (<var>expr</var>)</i>
<a name="IDX931"></a>
</dt>
<dd><p>Calcula o Hodge dual de <var>expr</var>. Por exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g        g
                                                     %1 %106  %2 %107
                                            g        g      A        /6
                                             %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de Op&ccedil;&atilde;o:</u> <b>igeowedge_flag</b>
<a name="IDX932"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Controla o comportamento de produto cunha e derivada externa. Quando
for esconhida para <code>false</code> (o padr&atilde;o), a no&ccedil;&atilde;o de formas diferenciais ir&aacute;
corresponder &agrave;quela de um campo tensor covariante totalmente antisim&eacute;trico.
Quando escolhida para <code>true</code>, formas diferenciais ir&atilde;o concordar com a no&ccedil;&atilde;o do
elemento volume.
</p>
</dd></dl>


<hr size="6">
<a name="SEC101"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC100" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC102" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.8 Exportando express&otilde;es TeX </h3>

<p>O pacote <code>itensor</code> fornece suporte limitado &agrave; exporta&ccedil;&atilde;o de express&otilde;es
de tensores para o TeX.  Uma vez que express&otilde;es <code>itensor</code> aparecem como chamada a fun&ccedil;&otilde;es,
o comando regular <code>tex</code> do Maxima n&atilde;o produzir&aacute; a sa&iacute;da
esperada. Voc&ecirc; pode tentar em seu lugar o comando <code>tentex</code>, o qual tenta
traduzir express&otilde;es de tensores dentro de objetos TeX indexados apropriadamente.
</p>
<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tentex</b><i> (<var>expr</var>)</i>
<a name="IDX933"></a>
</dt>
<dd><p>Para usar a fun&ccedil;&atilde;o <code>tentex</code>, voc&ecirc; deve primeiro chamar <code>tentex</code>,
como no seguinte exemplo:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i            i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
            j k      m1 l        j l      m1 k        j l,k        j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

</pre>
<p>Note o uso da declara&ccedil;&atilde;o <code>idummyx</code>, para evitar o aparecimento
do sinal de porcentagem na express&atilde;o TeX, o qual pode induzir a erros de compila&ccedil;&atilde;o.
</p>
<p>Note Bem: Essa ves&atilde;o da fun&ccedil;&atilde;o <code>tentex</code> &eacute; um tanto quanto experimental.
</p>
</dd></dl>

<hr size="6">
<a name="SEC102"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC101" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC103" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.9 Interagindo com o pacote <code>ctensor</code> </h3>

<p>O pacote <code>itensor</code> possui a habilidade de gerar c&oacute;digo Maxima que pode
ent&atilde;o ser executado no contexto do pacote <code>ctensor</code>. A fun&ccedil;&atilde;o que executa
essa tarefa &eacute; <code>ic_convert</code>.
</p>
<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ic_convert</b><i> (<var>eqn</var>)</i>
<a name="IDX934"></a>
</dt>
<dd><p>Converte a equa&ccedil;&atilde;o <var>eqn</var> na sintaxe <code>itensor</code> para uma declara&ccedil;&atilde;o de atribui&ccedil;&atilde;o <code>ctensor</code>.
Adi&ccedil;&otilde;es impl&iacute;citas sobre &iacute;ndices que ocorrem exatamente duas vezes s&atilde;o tornadas expl&iacute;citas enquanto objetos
indexados s&atilde;o transformados em arrays (os arrays subscritos est&atilde;o na
ordem de covari&acirc;ncia seguidos de &iacute;ndices contravariantes dos objetos
indexados). A derivada de um objeto indexado ser&aacute; substitu&iacute;da pela
forma substantiva de <code>diff</code> tomada com rela&ccedil;&atilde;o a <code>ct_coords</code> subscrita
pelo &iacute;ndice de deriva&ccedil;&atilde;o. Os s&iacute;mbolos de Christoffel <code>ichr1</code> e <code>ichr2</code>
ir&atilde;o ser traduzidos para <code>lcs</code> e <code>mcs</code>, respectivamente e se
<code>metricconvert</code> for <code>true</code> ent&atilde;o todas as ocorr&ecirc;ncias da m&eacute;trica
com dois &iacute;ndices covariantes (ou contravariantes) ir&atilde;o ser renomeadas para <code>lg</code>
(ou <code>ug</code>). Adicionalmente, ciclos <code>do</code> ir&atilde;o ser introduzidos adicionando sobre
todos os &iacute;ndices livres de forma que a
declara&ccedil;&atilde;o de atribui&ccedil;&atilde;o transformada pode ser avaliada atrav&eacute;s de apenas fazendo
<code>ev</code>. Os seguintes exemplos demonstam os recursos dessa
fun&ccedil;&atilde;o.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre>
</dd></dl>

<hr size="6">
<a name="SEC103"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC102" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.10 Palavras reservadas </h3>

<p>As palavras seguintes do Maxima s&atilde;o usadas internamente pelo pacote <code>itensor</code> e
n&atilde;o podem ser redefinidas:
</p>
<pre class="example">  Keyword    Comments
  ------------------------------------------
  indices2() vers&atilde;o interna de <code>indices()</code>
  conti      Lista de &iacute;ndices contravariantes
  covi       Lista de &iacute;ndices covariantes de um objeto indexado
  deri       Lista de &iacute;ndices de derivada de um objeto indexado
  name       Retorna o nome de um objeto indexado
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC104" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
