<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 5. Operadores</title>

<meta name="description" content="Manual do Maxima: 5. Operadores">
<meta name="keywords" content="Manual do Maxima: 5. Operadores">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Operadores"></a>
<a name="SEC12"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_4.html#SEC11" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC13" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_4.html#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 5. Operadores </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC13">5.1 N-Argumentos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC14">5.2 Operador n&atilde;o fixado</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC15">5.3 Operador P&oacute;sfixado</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC16">5.4 Operador Pr&eacute;fixado</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC17">5.5 Operadores Aritm&eacute;ticos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC18">5.6 Operadores Relacionais</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC19">5.7 Operadores Geral</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
</table>


<hr size="6">
<a name="N_002dArgumentos"></a>
<a name="SEC13"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC12" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC14" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.1 N-Argumentos </h2>
<p>Um operador <code>nary</code> &eacute; usado para denotar uma fun&ccedil;&atilde;o com qualquer n&uacute;mero de
argumentos, cada um dos quais &eacute; separado por uma ocorr&ecirc;ncia do
operador, e.g. A+B ou A+B+C.  A fun&ccedil;&atilde;o <code>nary(&quot;x&quot;)</code>  &eacute; uma fun&ccedil;&atilde;o
de extens&atilde;o sint&aacute;tica para declarar x como sendo um operador <code>nary</code>.
Fun&ccedil;&otilde;es podem ser declaradas para serem
<code>nary</code>.  Se <code>declare(j,nary);</code> &eacute; conclu&iacute;da, diz ao simplicador para
simplificar, e.g. <code>j(j(a,b),j(c,d))</code> para <code>j(a, b, c, d)</code>.
</p>
<p>Veja tamb&eacute;m <code>syntax</code>.
</p>
<hr size="6">
<a name="Operador-n_00e3o-fixado"></a>
<a name="SEC14"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC13" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC15" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.2 Operador n&atilde;o fixado </h2>
<p>Operadores <code>nofix</code> s&atilde;o usados para denotar fun&ccedil;&otilde;es sem argumentos.
A mera presen&ccedil;a de tal operador em um comando far&aacute; com que a
fun&ccedil;&atilde;o correspondente seja avaliada.  Por exemplo, quando se digita
&quot;exit;&quot; para sair de uma parada do Maxima, &quot;exit&quot; tem comportamento similar a um
operador <code>nofix</code>.  A fun&ccedil;&atilde;o <code>nofix(&quot;x&quot;)</code> &eacute; uma fun&ccedil;&atilde;o de extens&atilde;o
sint&aacute;tica que declara x como sendo um operador <code>nofix</code>. 
</p>
<p>Veja tamb&eacute;m <code>syntax</code>.
</p>
<hr size="6">
<a name="Operador-P_00f3sfixado"></a>
<a name="SEC15"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC14" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC16" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.3 Operador P&oacute;sfixado </h2>
<p>Operadores <code>postfix</code> como a variedade <code>prefix</code> denotam fun&ccedil;&otilde;es
de um argumento simples, mas nesse caso  o argumento sucede
imediatamente uma ocorr&ecirc;ncia do operador na seq&uuml;&ecirc;ncia de caracteres de entrada, e.g. 3! .
Uma fun&ccedil;&atilde;o <code>postfix(&quot;x&quot;)</code> &eacute; uma fun&ccedil;&atilde;o de extens&atilde;o
sint&aacute;tica que declara x como sendo um operador <code>postfix</code>.
</p>
<p>Veja tamb&eacute;m <code>syntax</code>.
</p>
<hr size="6">
<a name="Operador-Pr_00e9fixado"></a>
<a name="SEC16"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC15" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.4 Operador Pr&eacute;fixado </h2>
<p>Um operador <code>prefix</code> &eacute; um que significa uma fun&ccedil;&atilde;o de um
argumento, o qual imediatamente segue uma ocorr&ecirc;ncia do
operador.  <code>prefix(&quot;x&quot;)</code> &eacute; uma fun&ccedil;&atilde;o de extens&atilde;o
sint&aacute;tica que declara x como sendo um operador <code>prefix</code>.
</p>
<p>Veja tamb&eacute;m <code>syntax</code>.
</p>
<hr size="6">
<a name="Operadores-Aritm_00e9ticos"></a>
<a name="SEC17"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC16" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.5 Operadores Aritm&eacute;ticos </h2>

<dl>
<dt><u>Operador:</u> <b>+</b>
<a name="IDX56"></a>
</dt>
<dt><u>Operador:</u> <b>-</b>
<a name="IDX57"></a>
</dt>
<dt><u>Operador:</u> <b>*</b>
<a name="IDX58"></a>
</dt>
<dt><u>Operador:</u> <b>/</b>
<a name="IDX59"></a>
</dt>
<dt><u>Operador:</u> <b>^</b>
<a name="IDX60"></a>
</dt>
<dd><p>Os s&iacute;mbolos <code>+</code> <code>*</code> <code>/</code> e <code>^</code> representam
adi&ccedil;&atilde;o, multiplica&ccedil;&atilde;o, divis&atilde;o, e exponencia&ccedil;&atilde;o, respectivamente.
O nome desses operadores s&atilde;o <code>&quot;+&quot;</code> <code>&quot;*&quot;</code> <code>&quot;/&quot;</code> e <code>&quot;^&quot;</code>,
os quais podem aparecer em lugares onde o nome da fun&ccedil;&atilde;o ou operador &eacute; requerido.
</p>
<p>Os s&iacute;mbolos <code>+</code> e <code>-</code> representam a adi&ccedil;&atilde;o un&aacute;ria e a nega&ccedil;&atilde;o un&aacute;ria, respectivamente,
e os nomes desses operadores s&atilde;o <code>&quot;+&quot;</code> e <code>&quot;-&quot;</code>, respectivamente.
</p>
<p>A subtra&ccedil;&atilde;o <code>a - b</code> &eacute; representada dentro do Maxima como a adi&ccedil;&atilde;o, <code>a + (- b)</code>.
Express&otilde;es tais como <code>a + (- b)</code> s&atilde;o mostradas como subtra&ccedil;&atilde;o.
Maxima reconhece <code>&quot;-&quot;</code> somente como o nome do operador un&aacute;rio de nega&ccedil;&atilde;o,
e n&atilde;o como o nome do operador bin&aacute;rio de subra&ccedil;&atilde;o.
</p>
<p>A divis&atilde;o <code>a / b</code> &eacute; representada dentro do Maxima como multiplica&ccedil;&atilde;o, <code>a * b^(- 1)</code>.
Express&otilde;es tais como <code>a * b^(- 1)</code> s&atilde;o mostradas como divis&atilde;o.
Maxima reconhece <code>&quot;/&quot;</code> como o nome do operador de divis&atilde;o.
</p>
<p>A adi&ccedil;&atilde;o e a multiplica&ccedil;&atilde;o s&atilde;o operadores en&aacute;rios e comutativos.
a divis&atilde;o e a exponencia&ccedil;&atilde;o s&atilde;o operadores bin&aacute;rios e n&atilde;o comutativos.
</p>
<p>Maxima ordena os operandos de operadores n&atilde;o comutativos para construir uma representa&ccedil;&atilde;o can&ocirc;nica.
Para armazenamento interno, a ordem &eacute; determinada por <code>orderlessp</code>.
Para mostrar na tela, a ordem para adi&ccedil;&atilde;o &eacute; determinada por <code>ordergreatp</code>,
e para a multiplica&ccedil;&atilde;o, a ordem &eacute; a mesma da ordena&ccedil;&atilde;o para armazenamento interno.
</p>
<p>Computa&ccedil;&otilde;es aritim&eacute;ticas s&atilde;o realizadas sobre n&uacute;meros literais
(inteiro, racionais, n&uacute;meros comuns em ponto flutuante, e grandes n&uacute;meros em ponto flutuante de dupla precis&atilde;o).
Execto a exponencia&ccedil;&atilde;o, todas as opera&ccedil;&otilde;es aritm&eacute;ticas sobre n&uacute;meros s&atilde;o simplificadas para n&uacute;meros.
A exponencia&ccedil;&atilde;o &eacute; simplificada para um n&uacute;mero se ou o operando &eacute; um n&uacute;mero comum em ponto flutuante ou um grande n&uacute;mero em ponto flutuante de dupla precis&atilde;o
ou se o resultado for um inteiro exato ou um racional exato;
de outra forma uma exponencia&ccedil;&atilde;o pode ser simplificada para <code>sqrt</code> ou outra exponencia&ccedil;&atilde;o ou permanecer inalterada.
</p>
<p>A propaga&ccedil;&atilde;o de n&uacute;meros em ponto flutuante aplica-se a computa&ccedil;&otilde;es aritim&eacute;ticas:
Se qualquer operando for um grande n&uacute;mero em ponto flutuante, o resultado &eacute; um grande n&uacute;mero em ponto flutuante;
de outra forma, se qualquer operando for um n&uacute;mero em ponto flutuante comum, o resultado &eacute; um n&uacute;mero comum em ponto flutuante;
de outra forma, se os operandos forem racioanis ou inteiros e o resultado ser&aacute; um racional ou inteiro.
</p>
<p>Computa&ccedil;&atilde;oes aritim&eacute;ticas s&atilde;o uma simplifica&ccedil;&atilde;o, n&atilde;o uma avalia&ccedil;&atilde;o.
Dessa forma a aritm&eacute;tica &eacute; realizada em  express&otilde;es com ap&oacute;strofo (mas simplificadas).
</p>
<p>Opera&ccedil;&otilde;es aritm&eacute;ticas s&atilde;o aplicadas elemento-por-elemento
para listas quando a vari&aacute;vel global <code>listarith</code> for <code>true</code>,
e sempre aplicada elemento-por-elemento para matrizes.
Quando um operando for uma lista ou uma matriz e outro for um operando de algum outro tipo,
o outro operando &eacute; combinado com cada um dos elementos da lista ou matriz.
</p>
<p>Exemplos:
</p>
<p>Adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o s&atilde;o opeadores en&aacute;rios comutativos.
Maxima ordena os operandos para construir uma representa&ccedil;&atilde;o can&ocirc;nica.
Os nomes desses operadores s&atilde;o <code>&quot;+&quot;</code> e <code>&quot;*&quot;</code>.
</p>
<pre class="example">(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply (&quot;+&quot;, [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply (&quot;*&quot;, [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
</pre>
<p>Divis&atilde;o e exponencia&ccedil;&atilde;o s&atilde;o operadores bin&aacute;rios e n&atilde;o comutativos.
Os nomes desses operadores s&atilde;o <code>&quot;/&quot;</code> e <code>&quot;^&quot;</code>.
</p>
<pre class="example">(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply (&quot;/&quot;, [a, b]), apply (&quot;^&quot;, [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
</pre>
<p>Subtra&ccedil;&atilde;o e divis&atilde;o s&atilde;o representados internamente
em termos de adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o, respectivamente.
</p>
<pre class="example">(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
</pre>
<p>C&aacute;lculos s&atilde;o realizados sobre n&uacute;meros lterais.
A propaga&ccedil;&atilde;o de n&uacute;meros em poto flutuante aplica-se.
</p>
<pre class="example">(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
</pre>
<p>Computa&ccedil;&otilde;es aritm&eacute;ticas s&atilde;o uma simplifica&ccedil;&atilde;o, n&atilde;o uma avalia&ccedil;&atilde;o.
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
</pre>
<p>A aritm&eacute;tica &eacute; realizada elemento-por-elemento para listas lists (dependendo de <code>listarith</code>) e dependendo de matrizes.
</p>
<pre class="example">(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
(%i2) 5 * matrix ([a, x], [h, u]);
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>**</b>
<a name="IDX61"></a>
</dt>
<dd><p>Operador de exponencia&ccedil;&atilde;o.
Maxima reconhece <code>**</code> como o mesmo operador que <code>^</code> em entrada,
e <code>**</code> &eacute; mostrado como <code>^</code> em sa&iacute;da unidimensional,
ou colocando o expoente  como sobrescrito em sa&iacute;da bidimensional.
</p>
<p>A fun&ccedil;&atilde;o <code>fortran</code> mostra o operador de exponencia&ccedil;&atilde;o com como <code>**</code>,
independente de a entrada ter sido na forma <code>**</code> ou a forma <code>^</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
</pre>
</dd></dl>

<hr size="6">
<a name="Operadores-Relacionais"></a>
<a name="SEC18"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC17" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.6 Operadores Relacionais </h2>

<dl>
<dt><u>Operador:</u> <b>&lt;</b>
<a name="IDX62"></a>
</dt>
<dt><u>Operador:</u> <b>&lt;=</b>
<a name="IDX63"></a>
</dt>
<dt><u>Operador:</u> <b>&gt;=</b>
<a name="IDX64"></a>
</dt>
<dt><u>Operador:</u> <b>&gt;</b>
<a name="IDX65"></a>
</dt>
</dl>

<hr size="6">
<a name="Operadores-Geral"></a>
<a name="SEC19"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC18" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.7 Operadores Geral </h2>

<dl>
<dt><u>Operador:</u> <b>^^</b>
<a name="IDX66"></a>
</dt>
</dl>

<dl>
<dt><u>Operador:</u> <b>!</b>
<a name="IDX67"></a>
</dt>
<dd><p>O operador fatorial.
Para qualquer n&uacute;mero complexo <code>x</code> (inclu&iacute;ndo n&uacute;meros inteiros, racionais, e reais) exceto para
inteiros negativos, <code>x!</code> &eacute; definido como <code>gamma(x+1)</code>.
</p>
<p>Para um inteiro <code>x</code>, <code>x!</code> simplifica para o produto de inteiros de 1 a <code>x</code> inclusive.
<code>0!</code> simplifica para 1.
Para um n&uacute;mero em ponto flutuante <code>x</code>, <code>x!</code> simplifica para o valor de <code>gamma (x+1)</code>.
Para <code>x</code> igual a <code>n/2</code> onde <code>n</code> &eacute; um inteiro &iacute;mpar,
<code>x!</code> simplifica para um fator racional vezes <code>sqrt (%pi)</code>
(uma vez que <code>gamma (1/2)</code> &eacute; igual a <code>sqrt (%pi)</code>).
Se <code>x</code> for qualquer outra coisa,
<code>x!</code> n&atilde;o &eacute; simplificado.
</p>
<p>As vari&aacute;veis
<code>factlim</code>, <code>minfactorial</code>, e <code>factcomb</code> controlam a simplifica&ccedil;&atilde;o
de express&otilde;es contendo fatoriais.
</p>
<p>As fun&ccedil;&otilde;es <code>gamma</code>, <code>bffac</code>, e <code>cbffac</code>
s&atilde;o variedades da fun&ccedil;&atilde;o <code>gamma</code>. 
<code>makegamma</code> substitui <code>gamma</code> para fun&ccedil;&otilde;es relacionadas a fatoriais.
</p>
<p>Veja tamb&eacute;m <code>binomial</code>.
</p>
<p>O fatorial de um inteiro, inteiro dividido por dois, ou argumento em ponto flutuante &eacute; simplificado
a menos que o operando seja maior que <code>factlim</code>.
</p>
<pre class="example">(%i1) factlim : 10;
(%o1)                          10
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
+            105 sqrt(%pi)
+(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
+                 16
</pre>
<p>O fatorial de um n&uacute;mero complexo, constante conhecida, ou express&atilde;o geral n&atilde;o &eacute; simplificado.
Ainda assim pode ser poss&iacute;vel simplificar o fatorial ap&oacute;s avaliar o operando.
</p>
<pre class="example">(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357, 
                                               1.227580202486819]
</pre>
<p>O fatorial de um s&iacute;mbolo n&atilde;o associado n&atilde;o &eacute; simplificado.
</p>
<pre class="example">(%i1) kill (foo);
(%o1)                         done
(%i2) foo!;
(%o2)                         foo!
</pre>
<p>Fatoriais s&atilde;o simplificados, n&atilde;o avaliados.
Dessa forma <code>x!</code> pode ser substitu&iacute;do mesmo em uma express&atilde;o com ap&oacute;strofo.
</p>
<pre class="example">(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                                             2432902008176640000]
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>!!</b>
<a name="IDX68"></a>
</dt>
<dd><p>O operador de duplo fatorial.
</p>
<p>Para um n&uacute;mero inteiro, n&uacute;mero em ponto flutuante, ou n&uacute;mero racional <code>n</code>,
<code>n!!</code> avalia para o produto <code>n (n-2) (n-4) (n-6) ... (n - 2 (k-1))</code>
onde <code>k</code> &eacute; igual a <code>entier (n/2)</code>,
que &eacute;, o maior inteiro menor que ou igual a <code>n/2</code>.
Note que essa defini&ccedil;&atilde;o n&atilde;o coincide com outras defini&ccedil;&otilde;es publicadas
para argumentos que n&atilde;o s&atilde;o inteiros.
</p>
<p>Para um inteiro par (ou &iacute;mpar) <code>n</code>, <code>n!!</code> avalia para o produto de
todos os inteiros consecutivos pares (ou &iacute;mpares) de 2 (ou 1) at&eacute; <code>n</code> inclusive.
</p>
<p>Para um argumento <code>n</code> que n&atilde;o &eacute; um n&uacute;mero inteiro, um n&uacute;mero em ponto flutuante, ou um n&uacute;mero racional,
<code>n!!</code> retorna uma forma substantiva <code>genfact (n, n/2, 2)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>#</b>
<a name="IDX69"></a>
</dt>
<dd><p>Representa a nega&ccedil;&atilde;o da igualdade sint&aacute;tica <code>=</code>.
</p>
<p>Note que pelo fato de as regras de avalia&ccedil;&atilde;o de express&otilde;es predicadas
(em particular pelo fato de <code>not <var>expr</var></code> fazer com que ocorra a avalia&ccedil;&atilde;o de <var>expr</var>),
a forma <code>not <var>a</var> = <var>b</var></code> n&atilde;o &eacute; equivalente &agrave; forma <code><var>a</var> # <var>b</var></code> em alguns casos.
</p>
<p>Note que devido &agrave;s regras para avalia&ccedil;&atilde;o de express&otilde;es predicadas
(em particular devido a <code>not <var>expr</var></code> fazer com que a avalia&ccedil;&atilde;o de <var>expr</var> ocorra),
<code>not <var>a</var> = <var>b</var></code> &eacute; equivalente a <code>is(<var>a</var> # <var>b</var>)</code>,
em lugar de ser equivalente a <code><var>a</var> # <var>b</var></code>.
</p>
<p>Exemplos:
</p><pre class="example">(%i1) a = b;
(%o1)                         a = b
(%i2) &eacute; (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) &eacute; (a # b);
(%o5)                         true
(%i6) &eacute; (not a = b);
(%o6)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>.</b>
<a name="IDX70"></a>
</dt>
<dd><p>O operador ponto, para multiplica&ccedil;&atilde;o (n&atilde;o comutativa) de matrizes.
Quando &quot;.&quot; &eacute; usado com essa finalidade, espa&ccedil;os devem ser colocados em ambos os lados desse
operador, e.g. A . B.  Isso disting&uuml;e o operador ponto plenamente de um ponto decimal em
um n&uacute;mero em ponto flutuante.
</p>
<p>Veja tamb&eacute;m
<code>dot</code>,
<code>dot0nscsimp</code>,
<code>dot0simp</code>,
<code>dot1simp</code>,
<code>dotassoc</code>,
<code>dotconstrules</code>,
<code>dotdistrib</code>,
<code>dotexptsimp</code>,
<code>dotident</code>,
e
<code>dotscrules</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>:</b>
<a name="IDX71"></a>
</dt>
<dd><p>O operador de atribui&ccedil;&atilde;o.  E.g. A:3 escolhe a vari&aacute;vel A para 3.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>::</b>
<a name="IDX72"></a>
</dt>
<dd><p>Operador de atribui&ccedil;&atilde;o.  :: atribui o valor da express&atilde;o
em seu lado direito para o valor da quantidade na sua esquerda, que pode
avaliar para uma vari&aacute;vel at&ocirc;mica ou vari&aacute;vel subscrita.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>::=</b>
<a name="IDX73"></a>
</dt>
<dd><p>Operador de defini&ccedil;&atilde;o de fun&ccedil;&atilde;o de macro.
<code>::=</code> define uma fun&ccedil;&atilde;o (chamada uma &quot;macro&quot; por raz&otilde;es hist&oacute;ricas)
que coloca um ap&oacute;strofo em seus argumentos (evitando avalia&ccedil;&atilde;o),
e a express&atilde;o que &eacute; retornada (chamada a &quot;expans&atilde;o de macro&quot;)
&eacute; avaliada no contexto a partir do qual a macro foi chamada.
Uma fun&ccedil;&atilde;o de macro &eacute; de outra forma o mesmo que uma fun&ccedil;&atilde;o comum.
</p>
<p><code>macroexpand</code> retorna uma expans&atilde;o de macro (sem avaliar a expans&atilde;o).
<code>macroexpand (foo (x))</code> seguida por <code>''%</code> &eacute; equivalente a <code>foo (x)</code>
quando <code>foo</code> for uma fun&ccedil;&atilde;o de macro.
</p>
<p><code>::=</code> coloca o nome da nova fun&ccedil;&atilde;o de macro dentro da lista global <code>macros</code>.
<code>kill</code>, <code>remove</code>, e <code>remfunction</code> desassocia defini&ccedil;&otilde;es de fun&ccedil;&atilde;o de macro
e remove nomes de <code>macros</code>.
</p>
<p><code>fundef</code> e <code>dispfun</code> retornam respectivamente uma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o de macro
e uma atribui&ccedil;&atilde;o dessa defini&ccedil;&atilde;o a um r&oacute;tulo, respectivamente.
</p>
<p>Fun&ccedil;&otilde;es de macro comumente possuem express&otilde;es <code>buildq</code> e
<code>splice</code> para construir uma express&atilde;o,
que &eacute; ent&atilde;o avaliada.
</p>
<p>Exemplos
</p>
<p>Uma fun&ccedil;&atilde;o de macro coloca um ap&oacute;strofo em seus argumentos evitando ent&atilde;o a avalia&ccedil;&atilde;o,
ent&atilde;o mensagem (1) mostra <code>y - z</code>, n&atilde;o o valor de <code>y - z</code>.
A expans&atilde;o de macro (a express&atilde;o com ap&oacute;strofo <code>'(print (&quot;(2) x is equal to&quot;, x))</code>
&eacute; avaliada no contexto a partir do qual a macro for chamada,
mostrando a mensagem (2).
</p>
<pre class="example">(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printq1 (x) ::= block (print (&quot;(1) x &eacute; igual a&quot;, x), '(print (&quot;(2) x &eacute; igual a&quot;, x)));
(%o4) printq1(x) ::= block(print(&quot;(1) x &eacute; igual a&quot;, x), 
                                '(print(&quot;(2) x &eacute; igual a&quot;, x)))
(%i5) printq1 (y - z);
(1) x &eacute; igual a y - z 
(2) x &eacute; igual a %pi 
(%o5)                          %pi
</pre>
<p>Uma fun&ccedil;&atilde;o comum avalia seus argumentos, ent&atilde;o message (1) mostra o valor de <code>y - z</code>.
O valor de retorno n&atilde;o &eacute; avaliado, ent&atilde;o mensagem (2) n&atilde;o &eacute; mostrada
at&eacute; a avalia&ccedil;&atilde;o expl&iacute;cita <code>''%</code>.
</p>
<pre class="example">(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printe1 (x) := block (print (&quot;(1) x &eacute; igual a&quot;, x), '(print (&quot;(2) x &eacute; igual a&quot;, x)));
(%o4) printe1(x) := block(print(&quot;(1) x &eacute; igual a&quot;, x), 
                                '(print(&quot;(2) x &eacute; igual a&quot;, x)))
(%i5) printe1 (y - z);
(1) x &eacute; igual a 1234 - 1729 w 
(%o5)              print((2) x &eacute; igual a, x)
(%i6) ''%;
(2) x &eacute; igual a %pi 
(%o6)                          %pi
</pre>
<p><code>macroexpand</code> retorna uma expans&atilde;o de macro.
<code>macroexpand (foo (x))</code> seguido por <code>''%</code> &eacute; equivalente a <code>foo (x)</code>
quando <code>foo</code> for uma fun&ccedil;&atilde;o de macro.
</p>
<pre class="example">(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) g (x) ::= buildq ([x], print (&quot;x &eacute; igual a&quot;, x));
(%o4)    g(x) ::= buildq([x], print(&quot;x &eacute; igual a&quot;, x))
(%i5) macroexpand (g (y - z));
(%o5)              print(x &eacute; igual a, y - z)
(%i6) ''%;
x &eacute; igual a 1234 - 1729 w 
(%o6)                     1234 - 1729 w
(%i7) g (y - z);
x &eacute; igual a 1234 - 1729 w 
(%o7)                     1234 - 1729 w
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>:=</b>
<a name="IDX74"></a>
</dt>
<dd><p>O operador de defini&ccedil;&atilde;o de fun&ccedil;&atilde;o.  E.g. <code>f(x):=sin(x)</code> define
uma fun&ccedil;&atilde;o <code>f</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>=</b>
<a name="IDX75"></a>
</dt>
<dd><p>O operador de equa&ccedil;&atilde;o.
</p>
<p>Uma express&atilde;o <code><var>a</var> = <var>b</var></code>, por si mesma, representa
uma equa&ccedil;&atilde;o n&atilde;o avaliada, a qual pode ou n&atilde;o se manter.
Equa&ccedil;&otilde;es n&atilde;o avaliadas podem aparecer como argumentos para <code>solve</code> e <code>algsys</code>
ou algumas outras fun&ccedil;&otilde;es.
</p>
<p>A fun&ccedil;&atilde;o <code>is</code> avalia <code>=</code> para um valor Booleano.
<code>is(<var>a</var> = <var>b</var>)</code> avalia <code><var>a</var> = <var>b</var></code> para <code>true</code> quando <var>a</var> e <var>b</var>
forem id&ecirc;nticos. Isto &eacute;, <var>a</var> e <var>b</var> forem &aacute;tomos que s&atilde;o id&ecirc;nticos,
ou se eles n&atilde;o forem &aacute;tomos e seus operadores forem id&ecirc;nticos e seus argumentos forem id&ecirc;nticos.
De outra forma, <code>is(<var>a</var> = <var>b</var>)</code> avalia para <code>false</code>;
<code>is(<var>a</var> = <var>b</var>)</code> nunca avalia para <code>unknown</code>.
Quando <code>is(<var>a</var> = <var>b</var>)</code> for <code>true</code>, <var>a</var> e <var>b</var> s&atilde;o ditos para serem sintaticamente iguais,
em contraste para serem express&otilde;es equivalentes, para as quais <code>is(equal(<var>a</var>, <var>b</var>))</code> &eacute; <code>true</code>.
Express&otilde;es podem ser equivalentes e n&atilde;o sint&aacute;ticamente iguais.
</p>
<p>A nega&ccedil;&atilde;o de <code>=</code> &eacute; representada por <code>#</code>.
Da mesma forma que com <code>=</code>, uma express&atilde;o <code><var>a</var> # <var>b</var></code>, por si mesma, n&atilde;o &eacute; avaliada.
<code>is(<var>a</var> # <var>b</var>)</code> avalia <code><var>a</var> # <var>b</var></code> para
<code>true</code> ou <code>false</code>.
</p>
<p>Complementando a fun&ccedil;&atilde;o <code>is</code>,
alguns outros operadores avaliam <code>=</code> e <code>#</code> para <code>true</code> ou <code>false</code>,
a saber <code>if</code>, <code>and</code>, <code>or</code>, e <code>not</code>.
</p>
<p>Note que pelo fato de as regras de avalia&ccedil;&atilde;o de express&otilde;es predicadas
(em particular pelo fato de <code>not <var>expr</var></code> fazer com que ocorra a avalia&ccedil;&atilde;o de <var>expr</var>),
a forma <code>not <var>a</var> = <var>b</var></code> &eacute; equivalente a <code>is(<var>a</var> # <var>b</var>)</code>,
em lugar de ser equivalente a <code><var>a</var> # <var>b</var></code>.
</p>
<p><code>rhs</code> e <code>lhs</code> retornam o primeiro membro e o segundo membro de uma equa&ccedil;&atilde;o,
respectivamente, de uma equa&ccedil;&atilde;o ou inequa&ccedil;&atilde;o.
</p>
<p>Veja tamb&eacute;m <code>equal</code> e <code>notequal</code>.
</p>
<p>Exemplos:
</p>
<p>Uma express&atilde;o <code><var>a</var> = <var>b</var></code>, por si mesma, representa
uma equa&ccedil;&atilde;o n&atilde;o avaliada, a qual pode ou n&atilde;o se manter.
</p>
<pre class="example">(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
</pre>
<p><code>is(<var>a</var> = <var>b</var>)</code> avalia <code><var>a</var> = <var>b</var></code> para <code>true</code> quando <var>a</var> e <var>b</var>
s&atilde;o sintaticamente iguais (isto &eacute;, identicos).
Express&otilde;es podem ser equivalentes e n&atilde;o sintaticamente iguais.
</p>
<pre class="example">(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
</pre>
<p>Alguns operadores avaliam <code>=</code> e <code>#</code> para <code>true</code> ou <code>false</code>.
</p>
<pre class="example">(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
</pre>
<p>Devido a <code>not <var>expr</var></code> fazer com que a avalia&ccedil;&atilde;o de <var>expr</var> ocorra,
<code>not <var>a</var> = <var>b</var></code> &eacute; equivalente a <code>is(<var>a</var> # <var>b</var>)</code>.
</p>
<pre class="example">(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>and</b>
<a name="IDX76"></a>
</dt>
<dd><p>O operador l&oacute;gico de conjun&ccedil;&atilde;o.
<code>and</code> &eacute; um operador n-&aacute;rio infixo;
seus operandos s&atilde;o express&otilde;es Booleanas, e seu resultado &eacute; um valor Booleano.
</p>
<p><code>and</code> for&ccedil;a avalia&ccedil;&atilde;o (como <code>is</code>) de um ou mais operandos,
e pode for&ccedil;ar a avalia&ccedil;&atilde;o de todos os operandos.
</p>
<p>Operandos s&atilde;o avaliados na ordem em que aparecerem.
<code>and</code> avalia somente quantos de seus operandos forem necess&aacute;rios para determinar o resultado.
Se qualquer operando for <code>false</code>,
o resultado &eacute; <code>false</code> e os operandos restantes n&atilde;o s&atilde;o avaliados.
</p>
<p>O sinalizador global <code>prederror</code> governa o comportamento de <code>and</code>
quando um operando avaliado n&atilde;o pode ser determinado como sendo <code>true</code> ou <code>false</code>.
<code>and</code> imprime uma mensagem de erro quando <code>prederror</code> for <code>true</code>.  
De outra forma, operandos que n&atilde;o avaliam para <code>true</code> ou para <code>false</code> s&atilde;o aceitos,
and o resultado &eacute; uma express&atilde;o Booleana.
</p>
<p><code>and</code> n&atilde;o &eacute; comutativo:
<code>a and b</code> pode n&atilde;o ser igual a <code>b and a</code> devido ao tratamento de operandos indeterminados.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>or</b>
<a name="IDX77"></a>
</dt>
<dd><p>O operador l&oacute;gico de disjun&ccedil;&atilde;o.
<code>or</code> &eacute; um operador n-&aacute;rio infixo;
seus operandos s&atilde;o express&otilde;es Booleanas, e seu resultado &eacute; um valor Booleano.
</p>
<p><code>or</code> for&ccedil;a avalia&ccedil;&atilde;o (como <code>is</code>) de um ou mais operandos,
e pode for&ccedil;ar a avalia&ccedil;&atilde;o de todos os operandos.
</p>
<p>Operandos s&atilde;o avaliados na ordem em que aparecem.
<code>or</code> avalia somente quantos de seus operandos forem necess&aacute;rios para determinar o resultado.
Se qualquer operando for <code>true</code>,
o resultado &eacute; <code>true</code> e os operandos restantes n&atilde;o s&atilde;o avaliados.
</p>
<p>O sinalizador global <code>prederror</code> governa o comportamento de <code>or</code>
quando um operando avaliado n&atilde;o puder ser determinado como sendo <code>true</code> ou <code>false</code>.
<code>or</code> imprime uma mensagem de erro quando <code>prederror</code> for <code>true</code>.
De outra forma, operandos que n&atilde;o avaliam para <code>true</code> ou para <code>false</code> s&atilde;o aceitos,
E o resultado &eacute; uma express&atilde;o Booleana.
</p>
<p><code>or</code> n&atilde;o &eacute; comutativo:
<code>a or b</code> pode n&atilde;o ser igual a <code>b or a</code> devido ao tratamento de operando indeterminados.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>not</b>
<a name="IDX78"></a>
</dt>
<dd><p>O operador l&oacute;gico de nega&ccedil;&atilde;o.
<code>not</code> &eacute; operador prefixado;
Seu operando &eacute; uma express&atilde;o Booleana, e seu resultado &eacute; um valor Booleano.
</p>
<p><code>not</code> for&ccedil;a a avalia&ccedil;&atilde;o (como <code>is</code>) de seu operando.
</p>
<p>O sinalizador global <code>prederror</code> governa o comportamento de <code>not</code>
quando seu operando n&atilde;o pode ser determinado em termos de <code>true</code> ou <code>false</code>.
<code>not</code> imprime uma mensagem de erro quando <code>prederror</code> for <code>true</code>.
De outra forma, operandos que n&atilde;o avaliam para <code>true</code> ou para <code>false</code> s&atilde;o aceitos,
e o resultado &eacute; uma express&atilde;o Booleana.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>abs</b><i> (<var>expr</var>)</i>
<a name="IDX79"></a>
</dt>
<dd><p>Retorna o valor absoluto de <var>expr</var>.  Se <var>expr</var> for um n&uacute;mero complexo, retorna o m&oacute;dulo
complexo de <var>expr</var>.
</p>
</dd></dl>

<dl>
<dt><u>Palavra chave:</u> <b>additive</b>
<a name="IDX80"></a>
</dt>
<dd><p>Se <code>declare(f,additive)</code> tiver sido executado, ent&atilde;o:
</p>
<p>(1) Se <code>f</code> for uma fun&ccedil;&atilde;o de uma &uacute;nica vari&aacute;vel, sempre que o simplificador encontrar <code>f</code> aplicada
a uma adi&ccedil;&atilde;o, <code>f</code> ser&aacute; distribu&iacute;do sobre aquela adi&ccedil;&atilde;o.  I.e. <code>f(y+x)</code> ir&aacute;
simplificar para <code>f(y)+f(x)</code>.
</p>
<p>(2) Se <code>f</code> for uma fun&ccedil;&atilde;o de 2 ou mais argumentos, a adi&ccedil;&atilde;o &eacute; definida como 
adi&ccedil;&atilde;o no primeiro argumento para <code>f</code>, como no caso de <code>sum</code> ou  
<code>integrate</code>, i.e. <code>f(h(x)+g(x),x)</code> ir&aacute; simplificar para <code>f(h(x),x)+f(g(x),x)</code>.
Essa simplifica&ccedil;&atilde;o n&atilde;o ocorre quando <code>f</code> &eacute; aplicada para express&otilde;es da
forma <code>sum(x[i],i,lower-limit,upper-limit)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Palavra chave:</u> <b>allbut</b>
<a name="IDX81"></a>
</dt>
<dd><p>trabalha com os comandos <code>part</code> (i.e. <code>part</code>, <code>inpart</code>, <code>substpart</code>,
<code>substinpart</code>, <code>dpart</code>, e <code>lpart</code>).  Por exemplo,
</p>
<pre class="example">(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
</pre>
<p>enquanto
</p>
<pre class="example">(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
</pre>
<p><code>allbut</code> &eacute; tamb&eacute;m reconhecido por <code>kill</code>.
</p> 
<pre class="example">(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
</pre>
<p><code>kill(allbut(<var>a_1</var>, <var>a_2</var>, ...))</code> tem o mesmo efeito que <code>kill(all)</code>
exceto que n&atilde;o elimina os s&iacute;mbolos <var>a_1</var>, <var>a_2</var>, ... .
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>antisymmetric</b>
<a name="IDX82"></a>
</dt>
<dd><p>Se <code>declare(h,antisymmetric)</code> &eacute; conclu&iacute;da, diz ao
simplicador que <code>h</code> &eacute; uma fun&ccedil;&atilde;o antisim&eacute;trica.  E.g. <code>h(x,z,y)</code> simplificar&aacute; para
<code>- h(x, y, z)</code>.  Isto &eacute;, dar&aacute; (-1)^n vezes o resultado dado por
<code>symmetric</code> ou <code>commutative</code>, quando n for o n&uacute;mero de interescolhas de dois
argumentos necess&aacute;rios para converter isso naquela forma.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cabs</b><i> (<var>expr</var>)</i>
<a name="IDX83"></a>
</dt>
<dd><p>Retorna o valor absoluto complexo (o m&oacute;dulo complexo) de
<var>expr</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ceiling</b><i> (<var>x</var>)</i>
<a name="IDX84"></a>
</dt>
<dd><p>Quando <var>x</var> for um n&uacute;mero real, retorna o &uacute;ltimo inteiro que 
&eacute; maior que ou igual a <var>x</var>.  
</p>
<p>Se <var>x</var> for uma express&atilde;o constante (<code>10 * %pi</code>, por exemplo), 
<code>ceiling</code> avalia <var>x</var> usando grandes n&uacute;meros em ponto flutuante, e 
aplica <code>ceiling</code> para o grande n&uacute;mero em ponto flutuante resultante. Porque <code>ceiling</code> usa
avalia&ccedil;&atilde;o de ponto flutuante, &eacute; poss&iacute;vel, embora improv&aacute;vel, 
que <code>ceiling</code> possa retornar uma valor err&ocirc;neo para entradas
constantes. Para prevenir erros, a avalia&ccedil;&atilde;o de ponto flutuante
&eacute; conclu&iacute;da usando tr&ecirc;s valores para <code>fpprec</code>.
</p>
<p>Para entradas n&atilde;o constantes, <code>ceiling</code> tenta retornar um valor
simplificado.  Aqui est&aacute; um exemplo de simplifica&ccedil;&otilde;es que <code>ceiling</code>
conhece:
</p>
<pre class="example">(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x &gt; 0, x &lt; 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                         false
</pre>
<p>A fun&ccedil;&atilde;o <code>ceiling</code> n&atilde;o mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, <code>ceiling</code> retorna 
uma forma substantiva.
</p>
<p>Se o intervalo de uma fun&ccedil;&atilde;o &eacute; um subconjunto dos inteiros, o intervalo pode ser
declarado <code>integervalued</code>. Ambas as fun&ccedil;&otilde;es <code>ceiling</code> e <code>floor</code>
podem usar essa informa&ccedil;&atilde;o; por exemplo:
</p>
<pre class="example">(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>charfun</b><i> (<var>p</var>)</i>
<a name="IDX85"></a>
</dt>
<dd><p>Retorna 0 quando o predicado <var>p</var> avaliar para <code>false</code>; retorna
1 quando o predicado avaliar para <code>true</code>.  Quando o predicado
avaliar para alguma coisa que n&atilde;o <code>true</code> ou <code>false</code> (<code>unknown</code>), 
retorna uma forma substantiva.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) charfun (x &lt; 1);
(%o1)                    charfun(x &lt; 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('&quot;and&quot; (-1 &lt; x, x &lt; 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
</pre>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>commutative</b>
<a name="IDX86"></a>
</dt>
<dd><p>Se <code>declare(h,commutative)</code> &eacute; conclu&iacute;da, diz ao
simplicador que <code>h</code> &eacute; uma fun&ccedil;&atilde;o comutativa.  E.g. <code>h(x,z,y)</code> ir&aacute;
simplificar para <code>h(x, y, z)</code>.  Isto &eacute; o mesmo que <code>symmetric</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compare</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX87"></a>
</dt>
<dd><p>Retorna um operador de compara&ccedil;&atilde;o <var>op</var>
(<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>=</code>, ou <code>#</code>) tal que
<code>is (<var>x</var> <var>op</var> <var>y</var>)</code> avalia para <code>true</code>;
quando ou <var>x</var> ou <var>y</var> dependendo de <code>%i</code> e
<code><var>x</var> # <var>y</var></code>, retorna <code>notcomparable</code>;
Quando n&atilde;o existir tal operador ou
Maxima n&atilde;o estiver apto a determinar o operador, retorna <code>unknown</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) compare (1, 2);
(%o1)                           &lt;
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          &lt;=
</pre>
<p>A fun&ccedil;&atilde;o <code>compare</code> n&atilde;o tenta de terminar se o dom&iacute;nio real de
seus argumentos &eacute; n&atilde;o vazio; dessa forma
</p>
<pre class="example">(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           &lt;
</pre>
<p>O dom&iacute;nio real de <code>acos (x^2 + 1)</code> &eacute; vazio.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>entier</b><i> (<var>x</var>)</i>
<a name="IDX88"></a>
</dt>
<dd><p>Retorna o &uacute;ltimo inteiro menor que ou igual a <var>x</var> onde <var>x</var> &eacute; num&eacute;rico.  <code>fix</code> (como em
<code>fixnum</code>) &eacute; um sin&ocirc;nimo disso, ent&atilde;o <code>fix(<var>x</var>)</code> &eacute; precisamente o mesmo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>equal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX89"></a>
</dt>
<dd><p>Representa a equival&ecirc;ncia, isto &eacute;, valor igual.
</p> 
<p>Por si mesma, <code>equal</code> n&atilde;o avalia ou simplifica.
A fun&ccedil;&atilde;o <code>is</code> tenta avaliar <code>equal</code> para um valor Booleano.
<code>is(equal(<var>a</var>, <var>b</var>))</code> 
retorna <code>true</code> (ou <code>false</code>) se
e somente se <var>a</var> e <var>b</var> forem iguais (ou n&atilde;o iguais) para todos os poss&iacute;veis
valores de suas vari&aacute;veis, como determinado atrav&eacute;s da avalia&ccedil;&atilde;o de <code>ratsimp(<var>a</var> - <var>b</var>)</code>;
se <code>ratsimp</code> retornar 0, as duas express&otilde;es s&atilde;o consideradas equivalentes.
Duas express&otilde;es podem ser equivalentes mesmo se mesmo se elas n&atilde;o forem sintaticamente iguais (i.e., identicas).
</p>
<p>Quando <code>is</code> falhar em reduzir <code>equal</code> a <code>true</code> ou <code>false</code>,
o resultado &eacute; governado atrav&eacute;s do sinalizador global <code>prederror</code>.
Quando <code>prederror</code> for <code>true</code>,
<code>is</code> reclama com uma mensagem de erro.
De outra forma, <code>is</code> retorna <code>unknown</code>.
</p>
<p>Complementando <code>is</code>,
alguns outros operadores avaliam <code>equal</code> e <code>notequal</code> para <code>true</code> ou <code>false</code>,
a saber <code>if</code>, <code>and</code>, <code>or</code>, e <code>not</code>.
</p>

<p>A nega&ccedil;&atilde;o de <code>equal</code> &eacute; <code>notequal</code>.
</p>
<p>Exemplos:
</p>
<p>Por si mesmo, <code>equal</code> n&atilde;o avalia ou simplifica.
</p>
<pre class="example">(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
</pre>
<p>A fun&ccedil;&atilde;o <code>is</code> tenta avaliar <code>equal</code> para um valor Booleano.
<code>is(equal(<var>a</var>, <var>b</var>))</code> retorna <code>true</code> quando <code>ratsimp(<var>a</var> - <var>b</var>)</code> retornar 0.
Duas express&otilde;es podem ser equivalentes mesmo se n&atilde;o forem sintaticamente iguais (i.e., identicas).
</p>
<pre class="example">(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
</pre> 
<p>Quando <code>is</code> falha em reduzir <code>equal</code> a <code>true</code> ou <code>false</code>,
o resultado &eacute; governado atrav&eacute;s do sinalizador global <code>prederror</code>.
</p> 
 <pre class="example">(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
 (%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
</pre>
<p>Alguns operadores avaliam <code>equal</code> e <code>notequal</code> para <code>true</code> ou <code>false</code>.
</p>
<pre class="example">(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
</pre>
<p>Devido a <code>not <var>expr</var></code> fazer com que ocorra a avalia&ccedil;&atilde;o de <var>expr</var>,
<code>not equal(<var>a</var>, <var>b</var>)</code> &eacute; equivalente a <code>is(notequal(<var>a</var>, <var>b</var>))</code>.
</p>
<pre class="example">(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>floor</b><i> (<var>x</var>)</i>
<a name="IDX90"></a>
</dt>
<dd><p>Quando <var>x</var> for um n&uacute;mero real, retorna o maior inteiro que 
&eacute; menor que ou igual a <var>x</var>.
</p>
<p>Se <var>x</var> for uma express&atilde;o constante (<code>10 * %pi</code>, for exemplo), 
<code>floor</code> avalia <var>x</var> usando grandes n&uacute;meros em ponto flutuante, e 
aplica <code>floor</code> ao grande n&uacute;mero em ponto flutuante resultante. Porque <code>floor</code> usa
avalia&ccedil;&atilde;o em ponto flutuante, &eacute; poss&iacute;vel, embora improv&aacute;vel, 
que <code>floor</code> n&atilde;o possa retornar um valor err&ocirc;neo para entradas
constantes.  Para prevenir erros, a avalia&ccedil;&atilde;o de ponto flutuante
&eacute; conclu&iacute;da usando tr&ecirc;s valores para <code>fpprec</code>.
</p>
<p>Para entradas n&atilde;o constantes, <code>floor</code> tenta retornar um valor
simplificado.  Aqui est&aacute; exemplos de simplifica&ccedil;&otilde;es que <code>floor</code>
conhece:
</p>
<pre class="example">(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x &gt; 0, x &lt; 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
</pre>
<p>A fun&ccedil;&atilde;o <code>floor</code> n&atilde;o mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, <code>floor</code> retorna
uma forma substantiva.
</p>
<p>Se o intervalo de uma fun&ccedil;&atilde;o for um subconjunto dos inteiros, o intervalo pode ser
declarado <code>integervalued</code>. Ambas as fun&ccedil;&otilde;es <code>ceiling</code> e <code>floor</code>
podem usar essa informa&ccedil;&atilde;o; por exemplo:
</p>
<pre class="example">(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>notequal</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX91"></a>
</dt>
<dd><p>Represents the negation of <code>equal(<var>a</var>, <var>b</var>)</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a &gt; b);
(%o6)                        [a &gt; b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>eval</b>
<a name="IDX92"></a>
</dt>
<dd><p>Como um argumento em uma chamada a <code>ev (<var>expr</var>)</code>,
<code>eval</code> causa uma avalia&ccedil;&atilde;o extra de <var>expr</var>.
Veja <code>ev</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>evenp</b><i> (<var>expr</var>)</i>
<a name="IDX93"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> for um inteiro sempre.
<code>false</code> &eacute; retornado em todos os outros casos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fix</b><i> (<var>x</var>)</i>
<a name="IDX94"></a>
</dt>
<dd><p>Um sin&ocirc;nimo para <code>entier (<var>x</var>)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fullmap</b><i> (<var>f</var>, <var>expr_1</var>, ...)</i>
<a name="IDX95"></a>
</dt>
<dd><p>Similar a <code>map</code>, mas <code>fullmap</code> mant&eacute;m mapeadas para
baixo todas as subexpress&otilde;es at&eacute; que os operadores principais n&atilde;o mais sejam os
mesmos.
</p>
<p><code>fullmap</code> &eacute; usada pelo simplificador do
Maxima para certas manipula&ccedil;&otilde;es de matrizes; dessa forma, Maxima algumas vezes gera
uma mensagem de erro concernente a <code>fullmap</code> mesmo apesar de <code>fullmap</code> n&atilde;o ter sido
explicitamente chamada pelo usu&aacute;rio.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fullmapl</b><i> (<var>f</var>, <var>list_1</var>, ...)</i>
<a name="IDX96"></a>
</dt>
<dd><p>Similar a <code>fullmap</code>, mas <code>fullmapl</code> somente mapeia sobre
listas e matrizes.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>is</b><i> (<var>expr</var>)</i>
<a name="IDX97"></a>
</dt>
<dd><p>Tenta determinar se a <var>expr</var> predicada (express&otilde;es que avaliam para <code>true</code>
ou <code>false</code>) &eacute; dedut&iacute;vel de fatos localizados na base de dados de <code>assume</code>.
</p>
<p>Se a dedutibilidade do predicado for <code>true</code> ou <code>false</code>,
<code>is</code> retorna <code>true</code> ou <code>false</code>, respectivamente.
De outra forma, o valor de retorno &eacute; governado atrav&eacute;s do sinalizador global <code>prederror</code>.
Quando <code>prederror</code> for <code>true</code>,
<code>is</code> reclama com uma mensagem de erro.
De outra forma, <code>is</code> retorna <code>unknown</code>.
</p>
<p><code>ev(<var>expr</var>, pred)</code>
(que pode ser escrita da forma  <code><var>expr</var>, pred</code> na linha de comando interativa)
&eacute; equivalente a <code>is(<var>expr</var>)</code>.
</p>
<p>Veja tamb&eacute;m <code>assume</code>, <code>facts</code>, e <code>maybe</code>.
</p>
<p>Exemplos:
</p>
<p><code>is</code> causa avalia&ccedil;&atilde;o de predicados.
</p>
<pre class="example">(%i1) %pi &gt; %e;
(%o1)                       %pi &gt; %e
(%i2) &eacute; (%pi &gt; %e);
(%o2)                         true
</pre>
<p><code>is</code> tenta derivar predicados da base de dados do <code>assume</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) assume (b &gt; c);
(%o2)                        [b &gt; c]
(%i3) &eacute; (a &lt; b);
(%o3)                         false
(%i4) &eacute; (a &gt; c);
(%o4)                         true
(%i5) &eacute; (equal (a, c));
(%o5)                         false
</pre>
<p>Se <code>is</code> n&atilde;o puder nem comprovar nem refutar uma forma predicada a partir da base de dados de <code>assume</code>,
o sinalizador global <code>prederror</code> governa o comportamento de <code>is</code>.
</p>
<pre class="example">(%i1) assume (a &gt; b);
(%o1)                        [a &gt; b]
(%i2) prederror: true$
(%i3) &eacute; (a &gt; 0);
Maxima was unable to evaluate the predicate:
a &gt; 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) &eacute; (a &gt; 0);
(%o5)                        unknown
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>maybe</b><i> (<var>expr</var>)</i>
<a name="IDX98"></a>
</dt>
<dd><p>Tenta determinar se a <var>expr</var> predicada
&eacute; dedut&iacute;vel dos fatos na base de dados de <code>assume</code>.
</p>
<p>Se a dedutibilidade do predicado for <code>true</code> ou <code>false</code>,
<code>maybe</code> retorna <code>true</code> ou <code>false</code>, respectivamente.
De outra forma, <code>maybe</code> retorna <code>unknown</code>.
</p>
<p><code>maybe</code> &eacute; funcinalmente equivalente a <code>is</code> com <code>prederror: false</code>,
mas o resultado &eacute; computado sem atualmente atribuir um valor a <code>prederror</code>.
</p>
<p>Veja tamb&eacute;m <code>assume</code>, <code>facts</code>, e <code>is</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) maybe (x &gt; 0);
(%o1)                        unknown
(%i2) assume (x &gt; 1);
(%o2)                        [x &gt; 1]
(%i3) maybe (x &gt; 0);
(%o3)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>isqrt</b><i> (<var>x</var>)</i>
<a name="IDX99"></a>
</dt>
<dd><p>Retorna o &quot;inteiro ra&iacute;z quadrada&quot;
do valor absoluto de <var>x</var>,
que &eacute; um inteiro.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lmax</b><i> (<var>L</var>)</i>
<a name="IDX100"></a>
</dt>
<dd><p>Quando <var>L</var> for uma lista ou um conjunto, retorna <code>apply ('max, args (<var>L</var>))</code>.  Quando <var>L</var> n&atilde;o for uma
lista ou tamb&eacute;m n&atilde;o for um conjunto, sinaliza um erro.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lmin</b><i> (<var>L</var>)</i>
<a name="IDX101"></a>
</dt>
<dd><p>Quando <var>L</var> for uma lista ou um conjunto, retorna <code>apply ('min, args (<var>L</var>))</code>. Quando <var>L</var> n&atilde;o for uma
lista ou ou tamb&eacute;m n&atilde;o for um conjunto, sinaliza um erro.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>max</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX102"></a>
</dt>
<dd><p>Retorna um valor simplificado para o m&aacute;ximo entre as express&otilde;es <var>x_1</var> a <var>x_n</var>.
Quando <code>get (trylevel, maxmin)</code>, for dois ou mais, <code>max</code> usa a simplifica&ccedil;&atilde;o 
<code>max (e, -e) --&gt; |e|</code>.  Quando <code>get (trylevel, maxmin)</code> for 3 ou mais, <var>max</var> tenta
eliminar express&otilde;es que estiverem entre dois outros argumentos; por exemplo,
<code>max (x, 2*x, 3*x) --&gt; max (x, 3*x)</code>. Para escolher o valor de <code>trylevel</code> para 2, use
<code>put (trylevel, 2, maxmin)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>min</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX103"></a>
</dt>
<dd><p>Retorna um valor simplificado para o m&iacute;nimo entre as express&otilde;es <code>x_1</code> at&eacute; <code>x_n</code>.
Quando <code>get (trylevel, maxmin)</code>, for 2 ou mais, <code>min</code> usa a simplifica&ccedil;&atilde;o 
<code>min (e, -e) --&gt; -|e|</code>.  Quando <code>get (trylevel, maxmin)</code> for 3 ou mais, <code>min</code> tenta
eliminar express&otilde;es que estiverem entre dois outros argumentos; por exemplo,
<code>min (x, 2*x, 3*x) --&gt; min (x, 3*x)</code>. Para escolher o valor de <code>trylevel</code> para 2, use
<code>put (trylevel, 2, maxmin)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>polymod</b><i> (<var>p</var>)</i>
<a name="IDX104"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>polymod</b><i> (<var>p</var>, <var>m</var>)</i>
<a name="IDX105"></a>
</dt>
<dd><p>Converte o polin&ocirc;mio <var>p</var> para uma representa&ccedil;&atilde;o modular
com rela&ccedil;&atilde;o ao m&oacute;dulo corrente que &eacute; o valor da vari&aacute;vel
<code>modulus</code>.  
</p>
<p><code>polymod (<var>p</var>, <var>m</var>)</code> especifica um m&oacute;dulo <var>m</var> para ser usado 
em lugar do valor corrente de <code>modulus</code>.
</p>
<p>Veja <code>modulus</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>mod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX106"></a>
</dt>
<dd><p>Se <var>x</var> e <var>y</var> forem n&uacute;meros reais e <var>y</var> for n&atilde;o nulo,
retorna <code><var>x</var> - <var>y</var> * floor(<var>x</var> / <var>y</var>)</code>.
Adicionalmente para todo real <var>x</var>, n&oacute;s temos <code>mod (<var>x</var>, 0) = <var>x</var></code>. Para uma discurs&atilde;o da
defini&ccedil;&atilde;o <code>mod (<var>x</var>, 0) = <var>x</var></code>, veja a Se&ccedil;&atilde;o 3.4, de &quot;Concrete Mathematics,&quot; 
por Graham, Knuth, e Patashnik. A fun&ccedil;&atilde;o <code>mod (<var>x</var>, 1)</code> 
&eacute; uma fun&ccedil;&atilde;o dente de serra com per&iacute;odo 1 e com <code>mod (1, 1) = 0</code> e 
<code>mod (0, 1) = 0</code>.
</p>
<p>Para encontrar o argumento (um n&uacute;mero no intervalo <code>(-%pi, %pi]</code>) de um 
n&uacute;mero complexo, use a fun&ccedil;&atilde;o <code><var>x</var> |-&gt; %pi - mod (%pi - <var>x</var>, 2*%pi)</code>, onde 
<var>x</var> &eacute; um argumento.
</p>
<p>Quando <var>x</var> e <var>y</var> forem express&otilde;es constantes (<code>10 * %pi</code>, por exemplo), <code>mod</code>
usa o mesmo esquema de avalia&ccedil;&atilde;o em ponto flutuante que <code>floor</code> e <code>ceiling</code> usam.
Novamente, &eacute; poss&iacute;vel, embora improv&aacute;vel, que <code>mod</code> possa retornar um
valor err&ocirc;neo nesses casos.
</p>
<p>Para argumentos n&atilde;o num&eacute;ricos <var>x</var> ou <var>y</var>, <code>mod </code>conhece muitas regras de
simplifica&ccedil;&atilde;o:
</p>
<pre class="example">(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>oddp</b><i> (<var>expr</var>)</i>
<a name="IDX107"></a>
</dt>
<dd><p>&eacute; <code>true</code> se <var>expr</var> for um inteiro &iacute;mpar.
<code>false</code> &eacute; retornado em todos os outros casos.
</p>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>pred</b>
<a name="IDX108"></a>
</dt>
<dd><p>Como um argumento em uma chamada a <code>ev (<var>expr</var>)</code>,
<code>pred</code> faz com que predicados (express&otilde;es que avaliam para <code>true</code>
ou <code>false</code>) sejam avaliados.
Veja <code>ev</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>make_random_state</b><i> (<var>n</var>)</i>
<a name="IDX109"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>make_random_state</b><i> (<var>s</var>)</i>
<a name="IDX110"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>make_random_state</b><i> (true)</i>
<a name="IDX111"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>make_random_state</b><i> (false)</i>
<a name="IDX112"></a>
</dt>
<dd><p>Um objeto de estado rand&ocirc;mico representa o estado do gerador de n&uacute;meros rand&ocirc;micos (aleat&oacute;rios).
O estado compreende 627 palavras de 32 bits.
</p>
<p><code>make_random_state (<var>n</var>)</code> retorna um novo objeto de estado rand&ocirc;mico
criado de um valor inteiro semente igual a <var>n</var> modulo 2^32.  
<var>n</var> pode ser negativo.
</p>

<p><code>make_random_state (<var>s</var>)</code> retorna uma copia do estado rand&ocirc;mico <var>s</var>.
</p>
<p><code>make_random_state (true)</code> retorna um novo objeto de estado rand&ocirc;mico,
usando a hora corrente  do rel&oacute;gio do computador como semente.
</p>
<p><code>make_random_state (false)</code> retorna uma c&oacute;pia do estado corrente
do gerador de n&uacute;meros rand&ocirc;micos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>set_random_state</b><i> (<var>s</var>)</i>
<a name="IDX113"></a>
</dt>
<dd><p>Copia <var>s</var> para o estado do gerador de n&uacute;meros rand&ocirc;micos.
</p>
<p><code>set_random_state</code> sempre retorna <code>done</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>random</b><i> (<var>x</var>)</i>
<a name="IDX114"></a>
</dt>
<dd><p>Retorna um n&uacute;mero pseudorand&ocirc;mico. Se <var>x</var> &eacute; um inteiro, <code>random (<var>x</var>)</code> retorna um
inteiro de 0 a <code><var>x</var> - 1</code> inclusive. Se <var>x</var> for um n&uacute;mero em ponto flutuante,
<code>random (<var>x</var>)</code> retorna um n&uacute;mero n&atilde;o negativo em ponto flutuante menor que <var>x</var>.
<code>random</code> reclama com um erro se <var>x</var> n&atilde;o for nem um inteiro nem um n&uacute;mero em ponto flutuante,
ou se <var>x</var> n&atilde;o for positivo.
</p>
<p>As fun&ccedil;&otilde;es <code>make_random_state</code> e <code>set_random_state</code>
mant&eacute;m o estado do gerador de n&uacute;meros rand&ocirc;micos.
</p>
<p>O gerador de n&uacute;meros rand&ocirc;micos do Maxima &eacute; uma implementa&ccedil;&atilde;o do algor&iacute;tmo de Mersenne twister MT 19937.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rationalize</b><i> (<var>expr</var>)</i>
<a name="IDX115"></a>
</dt>
<dd><p>Converte todos os n&uacute;meros em ponto flutuante de precis&atilde;o dupla e grandes n&uacute;meros em ponto flutuante na express&atilde;o do Maxima
<var>expr</var> para seus exatos equivalentes racionais. Se voc&ecirc; n&atilde;o estiver faminilarizado com
a representa&ccedil;&atilde;o bin&aacute;ria de n&uacute;meros em ponto flutuante, voc&ecirc; pode se
surpreender que <code>rationalize (0.1)</code> n&atilde;o seja igual a 1/10.  Esse comportamento
n&atilde;o &eacute; especial para o Maxima - o n&uacute;mero 1/10 tem uma representa&ccedil;&atilde;o bin&aacute;ria
repetitiva e n&atilde;o terminada.
</p>
<pre class="example">(%i1) rationalize (0.5);
                                1
(%o1)                           -
                                2
(%i2) rationalize (0.1);
                               1
(%o2)                          --
                               10
 (%i3) fpprec : 5$
(%i4) rationalize (0.1b0);
                             209715
(%o4)                        -------
                             2097152
(%i5) fpprec : 20$
(%i6) rationalize (0.1b0);
                     236118324143482260685
(%o6)                ----------------------
                     2361183241434822606848
(%i7) rationalize (sin (0.1*x + 5.6));
                              x    28
(%o7)                     sin(-- + --)
                              10   5
</pre>
<p>Exemplo de utiliza&ccedil;&atilde;o:
</p>
<pre class="example">(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then error(&quot;The input to 'unitfrac' must be a rational number&quot;),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf)); 
(%o1) unitfrac(r) := block([uf : [], q], 
if not ratnump(r) then error(&quot;The input to 'unitfrac' must be a rational number&quot;
                                     1
), while r # 0 do (uf : cons(q : ----------, uf), r : r - q), 
                                         1
                                 ceiling(-)
                                         r
reverse(uf))
(%i2) unitfrac (9/10);
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) apply (&quot;+&quot;, %);
                               9
(%o3)                          --
                               10
(%i4) unitfrac (-9/10);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) apply (&quot;+&quot;, %);
                                9
(%o5)                         - --
                                10
(%i6) unitfrac (36/37);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) apply (&quot;+&quot;, %);
                               36
(%o7)                          --
                               37
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sign</b><i> (<var>expr</var>)</i>
<a name="IDX116"></a>
</dt>
<dd><p>Tenta determinar o sinal de <var>expr</var>
a partir dos fatos na base de dados corrente.  Retorna uma das
seguintes respostar: <code>pos</code> (positivo), <code>neg</code> (negativo), <code>zero</code>, <code>pz</code>
(positivo ou zero), <code>nz</code> (negativo ou zero), <code>pn</code> (positivo ou negativo),
ou <code>pnz</code> (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da epress&atilde;o).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>signum</b><i> (<var>x</var>)</i>
<a name="IDX117"></a>
</dt>
<dd><p>Para um <var>x</var> num&eacute;rico retorna 0 se <var>x</var> for 0, de outra forma retorna -1 ou +1
&agrave; medida que <var>x</var> seja menor ou maior que 0, respectivamente.
</p>
<p>Se <var>x</var> n&atilde;o for num&eacute;rico ent&atilde;o uma forma simplificada mas equivalente &eacute; retornada.
Por exemplo, <code>signum(-x)</code> fornece <code>-signum(x)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sort</b><i> (<var>L</var>, <var>P</var>)</i>
<a name="IDX118"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sort</b><i> (<var>L</var>)</i>
<a name="IDX119"></a>
</dt>
<dd><p>Organiza uma lista <var>L</var> coforme o predicado <code>P</code> de dois argumentos,
de forma que <code><var>P</var> (<var>L</var>[k], <var>L</var>[k + 1])</code> seja <code>true</code>
para qualquer dois elementos sucessivos.
O predicado pode ser especificado como o nome de uma fun&ccedil;&atilde;o ou operador bin&aacute;rio infixo,
ou como uma express&atilde;o <code>lambda</code>.
Se especificado como o nome de um operador,
o nome deve ser contido entre &quot;aspas duplas&quot;.
</p>
<p>A lista ordenada &eacute; retornada como novo objeto;
o argumento <var>L</var> n&atilde;o &eacute; modificado.
Para construir o valor de retorno,
<code>sort</code> faz uma c&oacute;pia superficial dos elementos de <var>L</var>.
Se o predicado <var>P</var> n&atilde;o for uma ordem total sobre os elementos de <var>L</var>,
ent&atilde;o <code>sort</code> possivelvente pode executar para concluir sem error,
mas os resultados s&atilde;o indefinidos.
<code>sort</code> reclama se o predicado avaliar para alguma outra coisa
que n&atilde;o seja <code>true</code> ou <code>false</code>.
</p>
<p><code>sort (<var>L</var>)</code> &eacute; equivalente a <code>sort (<var>L</var>, orderlessp)</code>.
Isto &eacute;, a ordem padr&atilde;o de organiza&ccedil;&atilde;o &eacute; ascendente,
como determinado por <code>orderlessp</code>.
Todos os &aacute;tomos do Maxima e express&otilde;es s&atilde;o compar&aacute;veis sob <code>orderlessp</code>,
embora exista exemplos isolados de express&otilde;es para as quais <code>orderlessp</code> n&atilde;o &eacute; transitiva;
isso &eacute; uma falha.
</p> 
<p>Exemplos:
</p> 
<pre class="example">(%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
               5
(%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
               2
(%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                   5
(%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                   2
(%i3) sort ([%pi, 3, 4, %e, %gamma]);
(%o3)                [3, 4, %e, %gamma, %pi]
(%i4) sort ([%pi, 3, 4, %e, %gamma], &quot;&lt;&quot;);
(%o4)                [%gamma, %e, 3, %pi, 4]
(%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
(%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
(%i6) sort (my_list);
(%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
(%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
(%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]
</pre> 
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sqrt</b><i> (<var>x</var>)</i>
<a name="IDX120"></a>
</dt>
<dd><p>A ra&iacute;z quadrada de <var>x</var>. &Eacute; representada internamente por
<code><var>x</var>^(1/2)</code>.  Veja tamb&eacute;m <code>rootscontract</code>.
</p>
<p><code>radexpand</code> se <code>true</code> far&aacute; com que n-&eacute;simas ra&iacute;zes de fatores de um produto
que forem pot&ecirc;ncias de n sejam colocados fora do radical, e.g.
<code>sqrt(16*x^2)</code> retonar&aacute; <code>4*x</code> somente se <code>radexpand</code> for <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>sqrtdispflag</b>
<a name="IDX121"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>sqrtdispflag</code> for <code>false</code>,
faz com que <code>sqrt</code> seja mostrado como expoente 1/2.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sublis</b><i> (<var>lista</var>, <var>expr</var>)</i>
<a name="IDX122"></a>
</dt>
<dd><p>Faz multiplas substitui&ccedil;&otilde;es paralelas dentro de uma express&atilde;o.
</p>
<p>A vari&aacute;vel <code>sublis_apply_lambda</code> controla a simplifica&ccedil;&atilde;o ap&oacute;s
<code>sublis</code>.
</p>
<p>Exemplo:
</p>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sublist</b><i> (<var>lista</var>, <var>p</var>)</i>
<a name="IDX123"></a>
</dt>
<dd><p>Retorna a lista de elementos da <var>lista</var> da qual o
predicado <code>p</code> retornar <code>true</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) L: [1, 2, 3, 4, 5, 6];
(%o1)                  [1, 2, 3, 4, 5, 6]
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>sublis_apply_lambda</b>
<a name="IDX124"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code> - controla se os substitutos de
<code>lambda</code> s&atilde;o aplicados na simplifica&ccedil;&atilde;o ap&oacute;s as <code>sublis</code> serem usadas ou
se voc&ecirc; tem que fazer um <code>ev</code> para pegar coisas para aplicar.  <code>true</code> significa fa&ccedil;a a
aplica&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>subst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX125"></a>
</dt>
<dd><p>Substitue <var>a</var> por <var>b</var> em <var>c</var>.  <var>b</var> deve ser um &aacute;tomo ou uma
subexpress&atilde;o completa de <var>c</var>.  Por exemplo, <code>x+y+z</code> &eacute; uma subexpress&atilde;o
completa de <code>2*(x+y+z)/w</code> enquanto <code>x+y</code> n&atilde;o &eacute;. Quando <var>b</var> n&atilde;o tem
essas caracter&iacute;sticas, pode-se algumas vezes usar <code>substpart</code> ou <code>ratsubst</code>
(veja abaixo).  Alternativamente, se <var>b</var> for da forma de <code>e/f</code> ent&atilde;o se poder&aacute;
usar <code>subst (a*f, e, c)</code> enquanto se <var>b</var> for da forma <code>e^(1/f)</code> ent&atilde;o se poder&aacute;
usar <code>subst (a^f, e, c)</code>.  O comando <code>subst</code> tamb&eacute;m discerne o <code>x^y</code> de <code>x^-y</code>
de modo que <code>subst (a, sqrt(x), 1/sqrt(x))</code> retorna <code>1/a</code>.  <var>a</var> e <var>b</var> podem tamb&eacute;m ser
operadores de uma express&atilde;o contida entre aspas duplas <code>&quot;</code> ou eles podem ser nomes de
fun&ccedil;&atilde;o.  Se se desejar substituir por uma vari&aacute;vel independente em
formas derivadas ent&atilde;o a fun&ccedil;&atilde;o <code>at</code> (veja abaixo) poder&aacute; ser usada.
</p>
<p><code>subst</code> &eacute; um &aacute;lias para <code>substitute</code>.
</p>
<p><code>subst (<var>eq_1</var>, <var>expr</var>)</code> ou <code>subst ([<var>eq_1</var>, ..., <var>eq_k</var>], <var>expr</var>)</code>
s&atilde;o outras formas
permitidas.  As <var>eq_i</var> s&atilde;o equa&ccedil;&otilde;es indicando substitui&ccedil;&otilde;es a serem feitas.
Para cada equa&ccedil;&atilde;o, o lado direito ser&aacute; substitu&iacute;do pelo lado esquerdo na
express&atilde;o <var>expr</var>.
</p>
<p><code>exptsubst</code> se <code>true</code> permite que substitui&ccedil;&otilde;es
como <code>y</code> por <code>%e^x</code> em <code>%e^(a*x)</code> ocorram.
</p>
<p>Quando <code>opsubst</code> for <code>false</code>,
<code>subst</code> tentar&aacute; substituir dentro do operador de uma express&atilde;o.
E.g. <code>(opsubst: false, subst (x^2, r, r+r[0]))</code> trabalhar&aacute;.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
</pre>

<p>Para exemplos adicionais, fa&ccedil;a <code>example (subst)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>substinpart</b><i> (<var>x</var>, <var>expr</var>, <var>n_1</var>, ..., <var>n_k</var>)</i>
<a name="IDX126"></a>
</dt>
<dd><p>Similar a <code>substpart</code>, mas <code>substinpart</code> trabalha sobre a
representa&ccedil;&atilde;o interna de <var>expr</var>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
</pre>
<p>Se o &uacute;ltimo argumento para a fun&ccedil;&atilde;o <code>part</code> for uma lista de &iacute;ndices ent&atilde;o
muitas subexpress&otilde;es s&atilde;o escolhidas, cada uma correspondendo a um
&iacute;ndice da lista.  Dessa forma
</p>
<pre class="example">(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
</pre>
<p><code>piece</code> recebe o valor da &uacute;ltima express&atilde;o selecionada quando usando as
fun&ccedil;&otilde;es <code>part</code>.  <code>piece</code> &eacute; escolhida durante a execu&ccedil;&atilde;o da fun&ccedil;&atilde;o e
dessa forma pode ser referenciada para a pr&oacute;pria fun&ccedil;&atilde;o como mostrado abaixo.
Se <code>partswitch</code> for escolhida para <code>true</code> ent&atilde;o <code>end</code> &eacute; retornado quando uma
parte selecionada de uma express&atilde;o n&atilde;o existir, de outra forma uma mensagem
de erro &eacute; fornecida.
</p>
<pre class="example">(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
</pre>
<p>Tamb&eacute;m, escolhendo a op&ccedil;&atilde;o <code>inflag</code> para <code>true</code> e chamando <code>part</code> ou <code>substpart</code> &eacute;
o mesmo que chamando <code>inpart</code> ou <code>substinpart</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>substpart</b><i> (<var>x</var>, <var>expr</var>, <var>n_1</var>, ..., <var>n_k</var>)</i>
<a name="IDX127"></a>
</dt>
<dd><p>Substitue <var>x</var> para a subexpress&atilde;o
selecionada pelo resto dos argumentos como em <code>part</code>.  Isso retorna o
novo valor de <var>expr</var>.  <var>x</var> pode ser algum operador a ser substitu&iacute;do por um
operador de <var>expr</var>.  Em alguns casos <var>x</var> precisa ser contido em aspas duplas <code>&quot;</code>
(e.g.  <code>substpart (&quot;+&quot;, a*b, 0)</code> retorna <code>b + a</code>).
</p>
<pre class="example">(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart (&quot;+&quot;, %, 1, 0);
(%o4)                    x + f(b, y) + a
</pre>
<p>Tamb&eacute;m, escolhendo a op&ccedil;&atilde;o <code>inflag</code> para <code>true</code> e chamando <code>part</code> ou <code>substpart</code> &eacute;
o mesmo que chamando <code>inpart</code> ou <code>substinpart</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>subvarp</b><i> (<var>expr</var>)</i>
<a name="IDX128"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> for uma vari&aacute;vel subscrita (i.e. que possui &iacute;ndice ou subscrito em sua grafia), por exemplo
<code>a[i]</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>symbolp</b><i> (<var>expr</var>)</i>
<a name="IDX129"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> for um s&iacute;mbolo, de outra forma retorna <code>false</code>.
com efeito, <code>symbolp(x)</code> &eacute; equivalente ao predicado <code>atom(x) and not numberp(x)</code>.
</p>
<p>Veja tamb&eacute;m <a href="maxima_6.html#SEC24">Identificadores</a>
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>unorder</b><i> ()</i>
<a name="IDX130"></a>
</dt>
<dd><p>Disabilita a a&ccedil;&atilde;o de alias criada pelo &uacute;ltimo uso dos comandos
de ordena&ccedil;&atilde;o <code>ordergreat</code> e <code>orderless</code>. <code>ordergreat</code> e <code>orderless</code> n&atilde;o podem
ser usados mais que uma vez cada sem chamar <code>unorder</code>. 
Veja tamb&eacute;m <code>ordergreat</code> e <code>orderless</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
 %th(1) - %th(3);
                             2
(%o4)                       a  + b x
(%i5) unorder();
                              2    2
(%o5)                        a  - a
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>vectorpotential</b><i> (<var>givencurl</var>)</i>
<a name="IDX131"></a>
</dt>
<dd><p>Retorna o potencial do vetor de um dado
vetor de tor&ccedil;&atilde;o, no sistema de coordenadas corrente.
<code>potentialzeroloc</code> tem um papel similar ao de <code>potential</code>, mas a ordem dos
lados esquerdos das equa&ccedil;&otilde;es deve ser uma permuta&ccedil;&atilde;o c&iacute;clica das
vari&aacute;veis de coordenadas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>xthru</b><i> (<var>expr</var>)</i>
<a name="IDX132"></a>
</dt>
<dd><p>Combina todos os termos de <var>expr</var> (o qual pode ser uma adi&ccedil;&atilde;o) sobre um
denominador comum sem produtos e somas exponenciadas
como <code>ratsimp</code> faz.  <code>xthru</code> cancela fatores comuns no numerador e
denominador de express&otilde;es racionais mas somente se os fatores s&atilde;o
expl&iacute;citos.
</p>
<p>Algumas vezes &eacute; melhor usar <code>xthru</code> antes de <code>ratsimp</code> em uma
express&atilde;o com o objetivo de fazer com que fatores explicitos do m&aacute;ximo divisor comum entre o
numerador e o denominador seja cancelado simplificando dessa forma a
express&atilde;o a ser aplicado o <code>ratsimp</code>.
</p>
<pre class="example">(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>zeroequiv</b><i> (<var>expr</var>, <var>v</var>)</i>
<a name="IDX133"></a>
</dt>
<dd><p>Testa se a express&atilde;o <var>expr</var> na vari&aacute;vel
<var>v</var> &eacute; equivalente a zero, retornando <code>true</code>, <code>false</code>, ou
<code>dontknow</code> (n&atilde;o sei).
</p>
<p><code>zeroequiv</code> Tem essas restri&ccedil;&otilde;es:
</p><ol>
<li>
N&atilde;o use fun&ccedil;&otilde;es que o Maxima n&atilde;o sabe como
diferenciar e avaliar.
</li><li>
Se a express&atilde;o tem postes sobre o eixo real, podem existir erros
no resultado (mas isso &eacute; improv&aacute;vel ocorrer).
</li><li>
Se a express&atilde;o contem fun&ccedil;&otilde;es que n&atilde;o s&atilde;o solu&ccedil;&otilde;es para
equa&ccedil;&otilde;es diferenciais de primeira ordem (e.g.  fun&ccedil;&otilde;es de Bessel) pode ocorrer
resultados incorretos.
</li><li>
O algor&iacute;tmo usa avalia&ccedil;&atilde;o em pontos aleat&oacute;riamente escolhidos para
subexpress&otilde;es selecionadas cuidadosamente.  Isso &eacute; sempre neg&oacute;cio um tanto
quanto perigoso, embora o algor&iacute;tmo tente minimizar o
potencial de erro.
</li></ol>

<p>Por exemplo
 <code>zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)</code> retorna
<code>true</code> e <code>zeroequiv (%e^x + x, x)</code> retorna <code>false</code>.
Por outro lado <code>zeroequiv (log(a*b) - log(a) - log(b), a)</code> retorna <code>dontknow</code> devido &agrave;
presen&ccedil;a de um par&acirc;metro extra <code>b</code>.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
