<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 7. Simplifica&ccedil;&atilde;o</title>

<meta name="description" content="Manual do Maxima: 7. Simplifica&ccedil;&atilde;o">
<meta name="keywords" content="Manual do Maxima: 7. Simplifica&ccedil;&atilde;o">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Simplifica_00e7_00e3o"></a>
<a name="SEC29"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_6.html#SEC28" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_6.html#SEC20" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_8.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 7. Simplifica&ccedil;&atilde;o </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC30">7.1 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Simplifica&ccedil;&atilde;o</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Simplifica_00e7_00e3o"></a>
<a name="SEC30"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC29" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_8.html#SEC31" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC29" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC29" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_8.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.1 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Simplifica&ccedil;&atilde;o </h2>

<dl>
<dt><u>Vari&aacute;vel de sistema:</u> <b>askexp</b>
<a name="IDX197"></a>
</dt>
<dd><p>Quando <code>asksign</code> &eacute; chamada,
<code>askexp</code> &eacute; a express&atilde;o que <code>asksign</code> est&aacute; testando.
</p>
<p>Antigamente, era poss&iacute;vel para um usu&aacute;rio inspecionar <code>askexp</code>
entrando em uma parada do Maxima com control-A.
</p></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>askinteger</b><i> (<var>expr</var>, integer)</i>
<a name="IDX198"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>askinteger</b><i> (<var>expr</var>)</i>
<a name="IDX199"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>askinteger</b><i> (<var>expr</var>, even)</i>
<a name="IDX200"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>askinteger</b><i> (<var>expr</var>, odd)</i>
<a name="IDX201"></a>
</dt>
<dd><p><code>askinteger (<var>expr</var>, integer)</code> tenta determinar a partir da base de dados do <code>assume</code>
se <var>expr</var> &eacute; um inteiro.
<code>askinteger</code> pergunta ao usu&aacute;rio pela linha de comando se isso n&atilde;o puder ser feito de outra forma,
e tenta instalar a informa&ccedil;&atilde;o na base de dados do <code>assume</code> se for poss&iacute;vel.
<code>askinteger (<var>expr</var>)</code> &eacute; equivalente a <code>askinteger (<var>expr</var>, integer)</code>.
</p>
<p><code>askinteger (<var>expr</var>, even)</code> e <code>askinteger (<var>expr</var>, odd)</code>
da mesma forma tentam determinar se <var>expr</var> &eacute; um inteiro par ou inteiro &iacute;mpar, respectivamente.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>asksign</b><i> (<var>expr</var>)</i>
<a name="IDX202"></a>
</dt>
<dd><p>Primeiro tenta determinar se a express&atilde;o
especificada &eacute; positiva, negativa, ou zero.  Se isso n&atilde;o for poss&iacute;vel, <code>asksign</code> pergunta ao
usu&aacute;rio pelas quest&otilde;es necess&aacute;rias para completar a sua dedu&ccedil;&atilde;o.  As respostas
do usu&aacute;rio s&atilde;o guardadas na base de dados pelo tempo que durar a computa&ccedil;&atilde;o
corrente. O valor de retorno de <code>asksign</code> &eacute; um entre <code>pos</code>, <code>neg</code>,
ou <code>zero</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>demoivre</b><i> (<var>expr</var>)</i>
<a name="IDX203"></a>
</dt>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>demoivre</b>
<a name="IDX204"></a>
</dt>
<dd><p>A fun&ccedil;&atilde;o <code>demoivre (expr)</code> converte uma express&atilde;o
sem escolher a vari&aacute;vel global <code>demoivre</code>.
</p>
<p>Quando a vari&aacute;vel <code>demoivre</code> for <code>true</code>,
exponenciais complexas s&atilde;o convertidas em express&otilde;es equivalentes em termos de fun&ccedil;&otilde;es circulares:
<code>exp (a + b*%i)</code> simplifica para <code>%e^a * (cos(b) + %i*sin(b))</code>
se <code>b</code> for livre de <code>%i</code>.
<code>a</code> e <code>b</code> n&atilde;o s&atilde;o expandidos.
</p>
<p>O valor padr&atilde;o de <code>demoivre</code> &eacute; <code>false</code>.
</p>
<p><code>exponentialize</code> converte fun&ccedil;&otilde;es circulares e hiperb&oacute;licas para a forma exponencial.
<code>demoivre</code> e <code>exponentialize</code> n&atilde;o podem
ambas serem <code>true</code> ao mesmo tempo.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>domain</b>
<a name="IDX205"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>real</code>
</p>
<p>Quando <code>domain</code> for escolhida para <code>complex</code>, <code>sqrt (x^2)</code> permanecer&aacute;
<code>sqrt (x^2)</code> em lugar de retornar <code>abs(x)</code>.
</p>

</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>expand</b><i> (<var>expr</var>)</i>
<a name="IDX206"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>expand</b><i> (<var>expr</var>, <var>p</var>, <var>n</var>)</i>
<a name="IDX207"></a>
</dt>
<dd><p>Expande a express&atilde;o <var>expr</var>.
Produtos de somas e somas exponenciadas s&atilde;o
multiplicadas para fora, numeradores de express&otilde;es racionais que s&atilde;o adi&ccedil;&otilde;es s&atilde;o
quebradas em suas respectivas parcelas, e multiplica&ccedil;&atilde;o (comutativa
e n&atilde;o comutativa) &eacute; distribu&iacute;da sobre a adi&ccedil;&atilde;o em todos os n&iacute;veis de
<var>expr</var>.
</p>
<p>Para polin&ocirc;mios se pode usar freq&uuml;&ecirc;ntemente <code>ratexpand</code> que possui um
algor&iacute;tmo mais eficiente.
</p>
<p><code>maxnegex</code> e <code>maxposex</code> controlam o m&aacute;ximo expoente negativo e
o m&aacute;ximo expoente positivo, respectivamente, que ir&atilde;o expandir.
</p>
<p><code>expand (<var>expr</var>, <var>p</var>, <var>n</var>)</code> expande <var>expr</var>, 
usando <var>p</var> para <code>maxposex</code> e <var>n</var> para <code>maxnegex</code>.
Isso &eacute; &uacute;til com o objetivo de expandir partes mas n&atilde;o tudo em uma express&atilde;o.
</p>
<p><code>expon</code> - o expoente da maior pot&ecirc;ncia negativa que &eacute;
automaticamente expandida (independente de chamadas a <code>expand</code>).  Por Exemplo
se <code>expon</code> for 4 ent&atilde;o <code>(x+1)^(-5)</code> n&atilde;o ser&aacute; automaticamente expandido.
</p>
<p><code>expop</code> - o maior expoente positivo que &eacute; automaticamente
expandido.  Dessa forma <code>(x+1)^3</code>, quando digitado, ser&aacute; automaticamente expandido
somente se <code>expop</code> for maior que ou igual a 3.  Se for desejado ter
<code>(x+1)^n</code> expandido onde <code>n</code> &eacute; maior que <code>expop</code> ent&atilde;o executando
<code>expand ((x+1)^n)</code> trabalhar&aacute; somente se <code>maxposex</code> n&atilde;o for menor que <code>n</code>.
</p>
<p>O sinalizador <code>expand</code> usado com <code>ev</code> causa expans&atilde;o.
</p>
<p>O arquivo <tt>`simplification/facexp.mac'</tt>
cont&eacute;m muitas fun&ccedil;&otilde;es relacionadas (em particular <code>facsum</code>, <code>factorfacsum</code>
e <code>collectterms</code>, que s&atilde;o chamadas automaticamente) e vari&aacute;veis (<code>nextlayerfactor</code>
e <code>facsum_combine</code>) que fornecem ao usu&aacute;rio com a habilidade para estruturar
express&otilde;es por expans&atilde;o controlada.
Descri&ccedil;&otilde;es breves de fun&ccedil;&atilde;o est&atilde;o dispon&iacute;vel em <tt>`simplification/facexp.usg'</tt>.
Um arquivo demonstrativo est&aacute; dispon&iacute;vel fazendo <code>demo(&quot;facexp&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>expandwrt</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX208"></a>
</dt>
<dd><p>Expande a express&atilde;o <code>expr</code> com rela&ccedil;&atilde;o &agrave;s 
vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var>.
Todos os produtos envolvendo as vari&aacute;veis aparecem explicitamente.  A forma retornada
ser&aacute; livre de produtos de somas de express&otilde;es que n&atilde;o est&atilde;o livres das
vari&aacute;veis.   <var>x_1</var>, ..., <var>x_n</var>
podem ser vari&aacute;veis, operadores, ou express&otilde;es.
</p>
<p>Por padr&atilde;o, denominadores n&atilde;o s&atilde;o expandidos, mas isso pode ser controlado
atrav&eacute;s do comutador <code>expandwrt_denom</code>.
</p>
<p>Essa fun&ccedil;&atilde;o, <code>expandwrt</code>, n&atilde;o &eacute; automaticamente chamada a partir de
<tt>`simplification/stopex.mac'</tt>.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>expandwrt_denom</b>
<a name="IDX209"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p><code>expandwrt_denom</code> controla o tratamento de express&otilde;es
racionais por <code>expandwrt</code>.  Se <code>true</code>, ent&atilde;o ambos o numerador e
o denominador da express&atilde;o ser&atilde;o expandidos conforme os
argumentos de <code>expandwrt</code>, mas se <code>expandwrt_denom</code> for <code>false</code>, ent&atilde;o somente
o numerador ser&aacute; expandido por aquele caminho.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>expandwrt_factored</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX210"></a>
</dt>
<dd><p>&eacute; similar a <code>expandwrt</code>, mas trata express&otilde;es que s&atilde;o produtos um tanto quanto diferentemente.
<code>expandwrt_factored</code> expande somente sobre esses fatores de <code>expr</code>
que contiverem as vari&aacute;veis <var>x_1</var>, ..., <var>x_n</var>.
</p>
<p>Essa fun&ccedil;&atilde;o &eacute; automaticamente chamada a aprtir de <tt>`simplification/stopex.mac'</tt>.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>expon</b>
<a name="IDX211"></a>
</dt>
<dd><p>Valor padr&atilde;o: 0
</p>
<p><code>expon</code> &eacute; o expoente da maior pot&ecirc;ncia negativa que
&eacute; automaticamente expandido (independente de chamadas a <code>expand</code>).  Por
exemplo, se <code>expon</code> for 4 ent&atilde;o <code>(x+1)^(-5)</code> n&atilde;o ser&aacute; automaticamente
expandido.
</p>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>exponentialize</b><i> (<var>expr</var>)</i>
<a name="IDX212"></a>
</dt>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>exponentialize</b>
<a name="IDX213"></a>
</dt>
<dd><p>A fun&ccedil;&atilde;o <code>exponentialize (expr)</code> converte 
fun&ccedil;&otilde;es circulares e hiperb&oacute;licas em <var>expr</var> para exponenciais,
sem escolher a vari&aacute;vel global <code>exponentialize</code>.
</p>
<p>Quando a vari&aacute;vel <code>exponentialize</code> for <code>true</code>,
todas as fun&ccedil;&otilde;es circulares e hiperb&oacute;licas  s&atilde;o convertidas para a forma exponencial.
O valor padr&atilde;o &eacute; <code>false</code>.
</p>
<p><code>demoivre</code> converte exponenciais complexas em fun&ccedil;&otilde;es circulares.
<code>exponentialize</code> e <code>demoivre</code> n&atilde;o podem
ambas serem <code>true</code> ao mesmo tempo.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>expop</b>
<a name="IDX214"></a>
</dt>
<dd><p>Valor padr&atilde;o: 0
</p>
<p><code>expop</code> - o maior expoente positivo que &eacute; 
automaticamente expandido.  Dessa forma <code>(x+1)^3</code>, quando digitado, ser&aacute;
automaticamente expandido somente se <code>expop</code> for maior que ou igual a 3.  
Se for desejado ter <code>(x+1)^n</code> expandido onde <code>n</code> &eacute; maior que 
<code>expop</code> ent&atilde;o executando <code>expand ((x+1)^n)</code> trabalhar&aacute; somente se <code>maxposex</code> n&atilde;o for 
menor que <code>n</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>factlim</b>
<a name="IDX215"></a>
</dt>
<dd><p>Valor padr&atilde;o: -1
</p>
<p><code>factlim</code> especifica o maior fatorial que &eacute;
automaticamente expandido.  Se for -1 ent&atilde;o todos os inteiros s&atilde;o expandidos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>intosum</b><i> (<var>expr</var>)</i>
<a name="IDX216"></a>
</dt>
<dd><p>Move fatores multiplicativos fora de um somat&oacute;rio para dentro.
Se o &iacute;ndice for usado na
express&atilde;o de fora, ent&atilde;o a fun&ccedil;&atilde;o tentar&aacute; achar um &iacute;ndice
razo&aacute;vel, o mesmo que &eacute; feito para <code>sumcontract</code>.  Isso &eacute; essencialmente a
id&eacute;ia inversa da propriedade <code>outative</code> de somat&oacute;rios, mas note que isso
n&atilde;o remove essa propriedade, somente pula sua verifica&ccedil;&atilde;o.
</p>
<p>Em alguns casos,
um <code>scanmap (multthru, <var>expr</var>)</code> pode ser necess&aacute;rio antes de <code>intosum</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>lassociative</b>
<a name="IDX217"></a>
</dt>
<dd><p><code>declare (g, lassociative)</code> diz ao
simplificador do Maxima que <code>g</code> &eacute; associativa &agrave; esquerda.  E.g., <code>g (g (a, b), g (c, d))</code> ir&aacute;
simplificar para <code>g (g (g (a, b), c), d)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>linear</b>
<a name="IDX218"></a>
</dt>
<dd><p>Uma das propriedades operativas do Maxima.  Para fun&ccedil;&otilde;es de uma &uacute;nica vari&aacute;vel <code>f</code> ent&atilde;o
declarada, a &quot;expans&atilde;o&quot; <code>f(x + y)</code> retorna <code>f(x) + f(y)</code>,
<code>f(a*x)</code> retorna <code>a*f(x)</code> tomando
lugar onde <code>a</code> for uma &quot;constante&quot;.  para fun&ccedil;&otilde;es de dois ou mais argumentos,
&quot;linearidade&quot; &eacute; definida para ser como no caso de <code>sum</code> ou <code>integrate</code>,
i.e., <code>f (a*x + b, x)</code> retorna <code>a*f(x,x) + b*f(1,x)</code>
para <code>a</code> e <code>b</code> livres de <code>x</code>.
</p>
<p><code>linear</code> &eacute; equivalente a <code>additive</code> e <code>outative</code>.
Veja tamb&eacute;m <code>opproperties</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>mainvar</b>
<a name="IDX219"></a>
</dt>
<dd><p>Voc&ecirc; pode declarar vari&aacute;veis para serem <code>mainvar</code> (vari&aacute;vel principal).  A escala de
ordena&ccedil;&atilde;o para &aacute;tomos &eacute; essencialmente: n&uacute;meros &lt; constantes (e.g., <code>%e</code>, <code>%pi</code>) &lt;
escalares &lt; outras vari&aacute;veis &lt; mainvars.  E.g., compare <code>expand ((X+Y)^4)</code>
com <code>(declare (x, mainvar), expand ((x+y)^4))</code>.  (Nota: Cuidado deve ser
tomado se voc&ecirc; eleger o uso desse recurso acima.  E.g., se voc&ecirc; subtrair uma
express&atilde;o na qual <code>x</code> for uma <code>mainvar</code> de uma na qual <code>x</code> n&atilde;o seja uma
<code>mainvar</code>, resimplifica&ccedil;&atilde;o e.g. com <code>ev (expr, simp)</code> pode ser
necess&aacute;ria se for para ocorrer um cancelamento.  Tamb&eacute;m, se voc&ecirc; grava uma
express&atilde;o na qual <code>x</code> &eacute; uma <code>mainvar</code>, voc&ecirc; provavelmente pode tamb&eacute;m gravar <code>x</code>.)
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>maxapplydepth</b>
<a name="IDX220"></a>
</dt>
<dd><p>Valor padr&atilde;o: 10000
</p>
<p><code>maxapplydepth</code> &eacute; a m&aacute;xima defini&ccedil;&atilde;o para a qual <code>apply1</code>
e <code>apply2</code> ir&atilde;o pesquisar.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>maxapplyheight</b>
<a name="IDX221"></a>
</dt>
<dd><p>Valor padr&atilde;o: 10000
</p>
<p><code>maxapplyheight</code> &eacute; a eleva&ccedil;&atilde;o m&aacute;xima a qual <code>applyb1</code>
ir&aacute; alcan&ccedil;ar antes de abandonar.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>maxnegex</b>
<a name="IDX222"></a>
</dt>
<dd><p>Valor padr&atilde;o: 1000
</p>
<p><code>maxnegex</code> &eacute; o maior expoente negativo que ser&aacute;
expandido pelo comando <code>expand</code> (veja tamb&eacute;m <code>maxposex</code>).
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>maxposex</b>
<a name="IDX223"></a>
</dt>
<dd><p>Valor padr&atilde;o: 1000
</p>
<p><code>maxposex</code> &eacute; o maior expoente que ser&aacute;
expandido com o comando <code>expand</code> (veja tamb&eacute;m <code>maxnegex</code>).
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>multiplicative</b>
<a name="IDX224"></a>
</dt>
<dd><p><code>declare (f, multiplicative)</code> diz ao simplificador do Maxima que <code>f</code> &eacute; multiplicativa.
</p>
<ol>
<li>
Se <code>f</code> for uma fun&ccedil;&atilde;o de uma &uacute;nica vari&aacute;vel, sempre que o simplificador encontrar <code>f</code> aplicada
a um produto, <code>f</code> distribue sobre aquele produto.  E.g., <code>f(x*y)</code>
simplifica para <code>f(x)*f(y)</code>.
</li><li>
Se <code>f</code> &eacute; uma fun&ccedil;&atilde;o de 2 ou mais argumentos, multiplicatividade &eacute;
definida como multiplicatividade no primeiro argumento para <code>f</code>, e.g.,
<code>f (g(x) * h(x), x)</code> simplifica para <code>f (g(x) ,x) * f (h(x), x)</code>.
</li></ol>

<p>Essa simplifica&ccedil;&atilde;o n&atilde;o ocorre quando <code>f</code> &eacute; aplicada a express&otilde;es da
forma <code>product (x[i], i, m, n)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>negdistrib</b>
<a name="IDX225"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>negdistrib</code> for <code>true</code>, -1 distribue
sobre uma express&atilde;o.  E.g., <code>-(x + y)</code> transforma-se em <code>- y - x</code>.  Mudando o valor de <code>negdistrib</code> para <code>false</code>
permitir&aacute; que <code>- (x + y)</code> seja mostrado como foi escrito.  Isso algumas vezes &eacute; &uacute;til
mas seja muito cuidadoso: como o sinalizador <code>simp</code>, isso &eacute; um sinalizador que voc&ecirc; pode n&atilde;o
querer escolher para <code>false</code> como algo natural ou necess&aacute;rio com excess&atilde;o
de usar localmente no seu Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>negsumdispflag</b>
<a name="IDX226"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>negsumdispflag</code> for <code>true</code>, <code>x - y</code> &eacute; mostrado como <code>x - y</code>
em lugar de como <code>- y + x</code>.  Escolhendo isso para <code>false</code> faz com que a verifica&ccedil;&atilde;o especial em
visualiza&ccedil;&atilde;o para a diferen&ccedil;a das duas express&otilde;es n&atilde;o seja conclu&iacute;da.  Uma
aplica&ccedil;&atilde;o &eacute; que dessa forma <code>a + %i*b</code> e <code>a - %i*b</code> podem ambos serem mostrados pelo
mesmo caminho.
</p>
</dd></dl>

<dl>
<dt><u>S&iacute;mbolo especial:</u> <b>noeval</b>
<a name="IDX227"></a>
</dt>
<dd><p><code>noeval</code> suprime a fase de avalia&ccedil;&atilde;o de <code>ev</code>.  Isso &eacute; &uacute;til em
conjun&ccedil;&atilde;o com outros comutadores e para fazer com que express&otilde;es      
sejam resimplificadas sem serem reavaliadas.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>noun</b>
<a name="IDX228"></a>
</dt>
<dd><p><code>noun</code> &eacute; uma das op&ccedil;&otilde;es do comando <code>declare</code>.  Essa op&ccedil;&atilde;o faz com que um
fun&ccedil;&atilde;o seja declarada como &quot;noun&quot; (substantivo), significando que ela n&atilde;o deve ser avaliada
automaticamente.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>noundisp</b>
<a name="IDX229"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>noundisp</code> for <code>true</code>, substantivos (nouns) s&atilde;o mostrados com
um ap&oacute;strofo.  Esse comutador &eacute; sempre <code>true</code> quando mostrando defini&ccedil;&otilde;es de
fun&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>S&iacute;mbolo especial:</u> <b>nouns</b>
<a name="IDX230"></a>
</dt>
<dd><p><code>nouns</code> &eacute; um <code>evflag</code> (sinalizador de avalia&ccedil;&atilde;o). Quando usado como uma op&ccedil;&atilde;o para o comando <code>ev</code>,
<code>nouns</code> converte todas as
formas substantivas (&quot;noun&quot;) que ocorrem na express&atilde;o que est&aacute; sendo avaliada para verbos (&quot;verbs&quot;), i.e.,
avalia essas express&otilde;es.  Veja tamb&eacute;m <code>noun</code>, <code>nounify</code>, <code>verb</code>, e <code>verbify</code>.
</p>
</dd></dl>

<dl>
<dt><u>S&iacute;mbolo especial:</u> <b>numer</b>
<a name="IDX231"></a>
</dt>
<dd><p><code>numer</code> faz com que algumas fun&ccedil;&otilde;es matem&aacute;ticas (incluindo exponencia&ccedil;&atilde;o)
com argumentos num&eacute;ricos sejam avaliados em ponto flutuante. Isso faz com que
vari&aacute;veis em <code>expr</code> &agrave;s quais tenham sido dados valores num&eacute;ricos a elas sejam substitu&iacute;das pelos
seus valores correspondentes.  <code>numer</code> tamb&eacute;m escolhe o sinalizador <code>float</code> para <code>on</code>.
</p>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>numerval</b><i> (<var>x_1</var>, <var>expr_1</var>, ..., <var>var_n</var>, <var>expr_n</var>)</i>
<a name="IDX232"></a>
</dt>
<dd><p>Declara as vari&aacute;veis <code>x_1</code>, ..., <var>x_n</var> para terem
valores num&eacute;ricos iguais a <code>expr_1</code>, ..., <code>expr_n</code>.
O valor num&eacute;rico &eacute; avaliado e substituido para a vari&aacute;vel
em quaisquer express&otilde;es na qual a vari&aacute;vel ocorra se o sinalizador <code>numer</code> for
<code>true</code>. Veja tamb&eacute;m <code>ev</code>.
</p>
<p>As express&otilde;es <code>expr_1</code>, ..., <code>expr_n</code> podem ser quaisquer express&otilde;es,
n&atilde;o necessariamente num&eacute;ricas.
</p></dd></dl>


<dl>
<dt><u>Vari&aacute;vel de sistema:</u> <b>opproperties</b>
<a name="IDX233"></a>
</dt>
<dd><p><code>opproperties</code> &eacute; a lista de propriedades de operadores especiais reconhecidas pelo
simplificador do Maxima:
<code>linear</code>, <code>additive</code>, <code>multiplicative</code>, <code>outative</code> (veja logo abaixo), <code>evenfun</code>,
<code>oddfun</code>, <code>commutative</code>, <code>symmetric</code>, <code>antisymmetric</code>, <code>nary</code>, 
<code>lassociative</code>, <code>rassociative</code>.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>opsubst</b>
<a name="IDX234"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>opsubst</code> for <code>false</code>, <code>subst</code> n&atilde;o tenta
substituir dentro de um operador de uma express&atilde;o.  E.g., 
<code>(opsubst: false, subst (x^2, r, r+r[0]))</code> ir&aacute; trabalhar.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>outative</b>
<a name="IDX235"></a>
</dt>
<dd><p><code>declare (f, outative)</code> diz ao simplificador do Maxima que fatores constantes
no argumento de <code>f</code> podem ser puxados para fora.
</p>
<ol>
<li>
Se <code>f</code> for uma fun&ccedil;&atilde;o de uma &uacute;nica vari&aacute;vel, sempre que o simplificador encontrar <code>f</code> aplicada
a um produto, aquele produto ser&aacute; particionado em fatores que s&atilde;o
constantes e fatores que n&atilde;o s&atilde;o e os fatores constantes ser&atilde;o
puxados para fora.  E.g., <code>f(a*x)</code> simplificar&aacute; para <code>a*f(x)</code> onde <code>a</code> &eacute; uma
constante.  Fatores de constantes n&atilde;o at&ocirc;micas n&atilde;o ser&atilde;o puxados para fora.
</li><li>
Se <code>f</code> for uma fun&ccedil;&atilde;o de 2 ou mais argumentos, a coloca&ccedil;&atilde;o para fora &eacute; definida
como no caso de <code>sum</code> ou <code>integrate</code>, i.e., <code>f (a*g(x), x)</code> ir&aacute; simplificar
para <code>a * f(g(x), x)</code> sendo <code>a</code> livre de <code>x</code>.
</li></ol>

<p><code>sum</code>, <code>integrate</code>, e <code>limit</code> s&atilde;o todas <code>outative</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>posfun</b>
<a name="IDX236"></a>
</dt>
<dd><p><code>declare (f, posfun)</code> declara <code>f</code> para ser uma fun&ccedil;&atilde;o positiva.
<code>is (f(x) &gt; 0)</code> retorna <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>radcan</b><i> (<var>expr</var>)</i>
<a name="IDX237"></a>
</dt>
<dd><p>Simplifica <var>expr</var>, que pode conter logar&iacute;tmos, exponenciais, e
radicais, convertendo essa express&atilde;o em uma forma que &eacute; can&ocirc;nica sobre uma ampla
classe de express&otilde;es e uma dada ordena&ccedil;&atilde;o de vari&aacute;veis; isto &eacute;, todas
formas funcionalmente equivalentes s&atilde;o mapeadas em uma &uacute;nica forma.  Para uma
classe um tanto quanto ampla de express&otilde;es, <code>radcan</code> produz uma forma regular.
Duas express&otilde;es equivalentes nessa classe n&atilde;o possuem necess&aacute;riamente a
mesma apar&ecirc;ncia, mas suas diferen&ccedil;as podem ser simplificadas por <code>radcan</code> para
zero.
</p>
<p>Para algumas express&otilde;es <code>radcan</code> &eacute; que consome inteiramente o tempo.  Esse
&eacute; o custo de explorar certos relacionamentos entre os componentes da
express&atilde;o para simplifica&ccedil;&otilde;es baseadas sobre fatora&ccedil;&atilde;o e
expans&otilde;es de fra&ccedil;&atilde;o-parcial de expoentes.  
</p>
<p>Quando <code>%e_to_numlog</code> for <code>true</code>, 
<code>%e^(r*log(expr))</code> simplifica para <code>expr^r</code> se <code>r</code> for um n&uacute;mero racional.
</p>
<p>Quando <code>radexpand</code> for <code>false</code>, certas transforma&ccedil;&otilde;es s&atilde;o inibidas.
<code>radcan (sqrt (1-x))</code> permanece <code>sqrt (1-x)</code>
e n&atilde;o &eacute; simplificada para <code>%i sqrt (x-1)</code>. 
<code>radcan (sqrt (x^2 - 2*x + 11))</code> permanece <code>sqrt (x^2 - 2*x + 1)</code>
e n&atilde;o &eacute; simplificada para <code>x - 1</code>.
</p>
<p><code>example (radcan)</code> mostra alguns exemplos.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>radexpand</b>
<a name="IDX238"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p><code>radexpand</code> controla algumas simplifica&ccedil;&otilde;es de radicais.
</p>
<p>Quando <code>radexpand</code> for <code>all</code>, faz com que n-&eacute;simas ra&iacute;zes de
fatores de um produto que s&atilde;o pot&ecirc;ncias de n sejam puxados para fora do
radical.  E.g. Se <code>radexpand</code> for <code>all</code>, <code>sqrt (16*x^2)</code> simplifica para <code>4*x</code>.
</p>
<p>Mais particularmente, considere <code>sqrt (x^2)</code>.
</p><ul>
<li>
Se <code>radexpand</code> for <code>all</code> or <code>assume (x &gt; 0)</code> tiver sido executado, 
<code>sqrt(x^2)</code> simplifica para <code>x</code>.
</li><li>
Se <code>radexpand</code> for <code>true</code> e <code>domain</code> for <code>real</code> (isso &eacute; o padr&atilde;o), 
<code>sqrt(x^2)</code> simplifica para <code>abs(x)</code>.
</li><li>
Se <code>radexpand</code> for <code>false</code>, ou <code>radexpand</code> for <code>true</code> e <code>domain</code> for <code>complex</code>, 
<code>sqrt(x^2)</code> n&atilde;o &eacute; simplificado.
</li></ul>

<p>Note que <code>domain</code> somente interessa quando <code>radexpand</code> for <code>true</code>.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>radsubstflag</b>
<a name="IDX239"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p><code>radsubstflag</code>, se <code>true</code>, permite a <code>ratsubst</code> fazer
substitui&ccedil;&otilde;es tais como <code>u</code> por <code>sqrt (x)</code> em <code>x</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>rassociative</b>
<a name="IDX240"></a>
</dt>
<dd><p><code>declare (g, rassociative)</code> diz ao simplificador do
Maxima que <code>g</code> &eacute; associativa &agrave; direita.  E.g.,
<code>g(g(a, b), g(c, d))</code> simplifica para <code>g(a, g(b, g(c, d)))</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>scsimp</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX241"></a>
</dt>
<dd><p>Simplifica&ccedil;&atilde;o Seq&uuml;&ecirc;ncial Comparativa (m&eacute;todo devido a Stoute).
<code>scsimp</code> tenta simplificar <var>expr</var>
conforme as regras <var>rule_1</var>, ..., <var>rule_n</var>.
Se uma express&atilde;o pequena for obtida, o processo
repete-se.  De outra forma ap&oacute;s todas as simplifica&ccedil;&otilde;es serem tentadas, <code>scsimp</code> retorna
a resposta original.
</p>
<p><code>example (scsimp)</code> mostra alguns exemplos.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>simpsum</b>
<a name="IDX242"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>simpsum</code> for <code>true</code>, o resultado de uma <code>sum</code> &eacute;
simplificado.  Essa simplifica&ccedil;&atilde;o pode algumas vezes estar apta a produzir uma
forma fechada.  Se <code>simpsum</code> for <code>false</code> ou se a forma com ap&oacute;strofo <code>'sum</code> for usada, o valor &eacute; uma
forma substantiva aditiva que &eacute; uma representa&ccedil;&atilde;o da nota&ccedil;&atilde;o sigma usada em
matem&aacute;tica.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sumcontract</b><i> (<var>expr</var>)</i>
<a name="IDX243"></a>
</dt>
<dd><p>Combina todas as parcelas de um somat&oacute;rio que possuem
limites superiores e inferiores que diferem por constantes. O resultado &eacute; uma
express&atilde;o contendo um somat&oacute;rio para cada escolha de cada tais somat&oacute;rios
adicionados a todos os termos extras apropriados que tiveram de ser extra&iacute;dos para a forma
dessa adi&ccedil;&atilde;o.  <code>sumcontract</code> combina todas as somas compat&iacute;veis e usa os
indices de uma as somas se puder, e ent&atilde;o tenta formar um
&iacute;ndice razo&aacute;vel se n&atilde;o for usar qualquer dos fornecidos.
</p>
<p>Isso pode ser necess&aacute;rio fazer um <code>intosum (<var>expr</var>)</code> antes de <code>sumcontract</code>.
</p>
</dd></dl>


<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>sumexpand</b>
<a name="IDX244"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>sumexpand</code> for <code>true</code>, produtos de somas e
somas exponeciadas simplificam para somas aninhadas.
</p>
<p>Veja tamb&eacute;m <code>cauchysum</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                &gt;      &gt;     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                &gt;      &gt;     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>sumsplitfact</b>
<a name="IDX245"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>sumsplitfact</code> for <code>false</code>,
<code>minfactorial</code> &eacute; aplicado ap&oacute;s um <code>factcomb</code>.
</p>
</dd></dl>

<dl>
<dt><u>Declara&ccedil;&atilde;o:</u> <b>symmetric</b>
<a name="IDX246"></a>
</dt>
<dd><p><code>declare (h, symmetric)</code> diz ao simplificador
do Maxima que <code>h</code> &eacute; uma fun&ccedil;&atilde;o sim&eacute;trica.  E.g., <code>h (x, z, y)</code> 
simplifica para <code>h (x, y, z)</code>.
</p>
<p><code>commutative</code> &eacute; sin&ocirc;nimo de <code>symmetric</code>.
</p>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>unknown</b><i> (<var>expr</var>)</i>
<a name="IDX247"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> cont&eacute;m um operador ou fun&ccedil;&atilde;o
n&atilde;o reconhecida pelo simplificador do Maxima.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC29" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_8.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
