<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 39. Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o</title>

<meta name="description" content="Manual do Maxima: 39. Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o">
<meta name="keywords" content="Manual do Maxima: 39. Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Defini_00e7_00e3o-de-Fun_00e7_00e3o"></a>
<a name="SEC158"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_38.html#SEC157" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC159" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_38.html#SEC151" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 39. Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC159">39.1 Introdu&ccedil;&atilde;o a Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC160">39.2 Fun&ccedil;&atilde;o</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC163">39.3 Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC164">39.4 Fun&ccedil;&otilde;es e Vari&aacute;veis para Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Defini_00e7_00e3o-de-Fun_00e7_00e3o"></a>
<a name="SEC159"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC158" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC160" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 39.1 Introdu&ccedil;&atilde;o a Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o </h2>

<hr size="6">
<a name="Fun_00e7_00e3o"></a>
<a name="SEC160"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC159" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC161" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 39.2 Fun&ccedil;&atilde;o </h2>
<hr size="6">
<a name="SEC161"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC160" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC162" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC160" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 39.2.1 Ordinary functions </h3>

<p>Para definir uma fun&ccedil;&atilde;o no Maxima voc&ecirc; usa o operador <code>:=</code>.
E.g.
</p>
<pre class="example">f(x) := sin(x)
</pre>

<p>define uma fun&ccedil;&atilde;o <code>f</code>.
Fun&ccedil;&otilde;es an&ocirc;nimas podem tamb&eacute;m serem criadas usando <code>lambda</code>.
Por exemplo
</p>
<pre class="example">lambda ([i, j], ...)
</pre>

<p>pode ser usada em lugar de <code>f</code>
onde
</p>
<pre class="example">f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
</pre>

<p>retornar&aacute; uma lista com 1 adicionado a cada termo.
</p>
<p>Voc&ecirc; pode tamb&eacute;m definir uma fun&ccedil;&atilde;o com um n&uacute;mero vari&aacute;vel de argumentos,
teno um argumento final que &eacute; atribu&iacute;do para uma lista de argumentos
extras:
</p>
<pre class="example">(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
</pre>
<p>O lado direito de uma fun&ccedil;&atilde;o &eacute; uma express&atilde;o.  Desse modo
Se voc&ecirc; quer uma seq&uuml;&ecirc;ncia de express&otilde;es, voc&ecirc; faz
</p>
<pre class="example">f(x) := (expr1, expr2, ...., exprn);
</pre>
<p>e o valor de <var>exprn</var> &eacute; que &eacute; retornado pela fun&ccedil;&atilde;o.
</p>
<p>Se voc&ecirc; deseja fazer um <code>return</code> de alguma express&atilde;o dentro da
fun&ccedil;&atilde;o ent&atilde;o voc&ecirc; deve usar <code>block</code> e <code>return</code>.
</p>
<pre class="example">block ([], expr1, ..., if (a &gt; 10) then return(a), ..., exprn)
</pre>
<p>&eacute; em si mesma uma express&atilde;o, e ent&atilde;o poder&aacute; ocupar o lugar do
lado direito de uma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o.  Aqui pode acontecer
que o retorno aconte&ccedil;a mais facilmente que no exemplo anterior a essa &uacute;ltima express&atilde;o.
</p>
<p>O primeiro <code>[]</code> no bloco, pode conter uma lista de vari&aacute;veis e
atribui&ccedil;&otilde;es de vari&aacute;veis, tais como <code>[a: 3, b, c: []]</code>, que far&atilde;o com que as
tr&ecirc;s vari&aacute;veis <code>a</code>,<code>b</code>,e <code>c</code> n&atilde;o se refiram a seus
valores globais, mas ao contr&aacute;rio tenham esses valores especiais enquanto o
c&oacute;digo estiver executando a parte dentro do bloco <code>block</code>, ou dentro da fun&ccedil;&otilde;es chamadas de
dentro do bloco <code>block</code>.  Isso &eacute; chamado associa&ccedil;&atilde;o <i>dynamic</i>, uma vez que as
vari&aacute;veis permanecem do in&iacute;cio do bloco pelo tempo que ele existir.  Uma vez que
voc&ecirc; retorna do <code>block</code>, ou descarta-o, os valores antigos (quaisquer que
sejam) das vari&aacute;veis ser&atilde;o restaurados.   &Eacute; certamente uma boa id&eacute;ia
para proteger suas vari&aacute;veis nesse caminho.   Note que as atribui&ccedil;&otilde;es
em vari&aacute;veis do bloco, s&atilde;o conclu&iacute;das em paralelo.   Isso significa, que se
tiver usado <code>c: a</code> acima, o valor de <code>c</code> ser&aacute;
o valor de <code>a</code> a partir do momento em que voc&ecirc;ntrou no bloco,
mas antes <code>a</code> foi associado.   Dessa forma fazendo alguma coisa como
</p>
<pre class="example">block ([a: a], expr1, ...  a: a+3, ..., exprn)
</pre>
<p>proteger&aacute; o valor externo de <code>a</code> de ser alterado, mas
impedir&aacute; voc&ecirc; acessar o valor antigo.   Dessa forma o lado direito
de atribui&ccedil;&otilde;es, &eacute; avaliado no contexto inserido, antes que
qualquer avalia&ccedil;&atilde;o ocorra.
Usando apenas <code>block ([x], ...</code> faremos com que o <code>x</code> tenha a si mesmo
como valor, apenas como x teria se voc&ecirc; tivesse entrado numa breve sess&atilde;o do
<b>Maxima</b>.
</p>
<p>Os atuais argumentos para uma fun&ccedil;&atilde;o s&atilde;o tratados exatamente da mesma que
as vari&aacute;veis em um bloco.  Dessa forma em
</p>
<pre class="example">f(x) := (expr1, ..., exprn);
</pre>
<p>e
</p>
<pre class="example">f(1);
</pre>
<p>teremos um contexto similar para avalia&ccedil;&atilde;o de express&otilde;es
como se tiv&eacute;ssemos conclu&iacute;do
</p>
<pre class="example">block ([x: 1], expr1, ..., exprn)
</pre>
<p>Dentro de fun&ccedil;&otilde;es, quando o lado direito de uma defini&ccedil;&atilde;o,
pode ser calculado em tempo de execu&ccedil;&atilde;o, isso &eacute; &uacute;ti para usar <code>define</code> e
possivelmente <code>buildq</code>.  
</p>
<hr size="6">
<a name="SEC162"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC161" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC163" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC160" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 39.2.2 Fun&ccedil;&atilde;o de Array </h3>

<p>Uma fun&ccedil;&atilde;o de Array armazena o valor da fun&ccedil;&atilde;o na primeira vez que ela for chamada com um argumento dado,
e retorna o valor armazenado, sem recalcular esse valor, quando o mesmo argumento for fornecido.
De modo que uma fun&ccedil;&atilde;o &eacute; muitas vezes chamada uma <i>fun&ccedil;&atilde;o de memoriza&ccedil;&atilde;o</i>.
</p>
<p>Nomes de fun&ccedil;&otilde;es de Array s&atilde;o anexados ao final da lista global <code>arrays</code>
(n&atilde;o na lista global <code>functions</code>).
O comando <code>arrayinfo</code> retorna a lista de argumentos para os quais exite valores armazenados,
e <code>listarray</code> retorna os valores armazenados. 
Os comandos <code>dispfun</code> e <code>fundef</code> retornam a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o de array.
</p>
<p>O comando <code>arraymake</code> contr&oacute;i uma chamada de fun&ccedil;&atilde;o de array,
an&aacute;logamente a <code>funmake</code> para fun&ccedil;&otilde;es comuns.
O comando <code>arrayapply</code> aplica uma fun&ccedil;&atilde;o de array a seus argmentos,
an&aacute;logamente a <code>apply</code> para fun&ccedil;&otilde;es comuns.
N&atilde;o existe nada exatamente an&aacute;logo a <code>map</code> para fun&ccedil;&otilde;es de array,
embora <code>map(lambda([<var>x</var>], <var>a</var>[<var>x</var>]), <var>L</var>)</code> ou
<code>makelist(<var>a</var>[<var>x</var>], <var>x</var>, <var>L</var>)</code>, onde <var>L</var> &eacute; uma lista,
n&atilde;o estejam t&atilde;o longe disso.
</p>
<p>O comando <code>remarray</code> remove uma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o de array (incluindo qualquer valor armazenado pela fun&ccedil;&atilde;o removida),
an&aacute;logo a <code>remfunction</code> para fun&ccedil;&otilde;es comuns.
</p>
<p>o comando <code>kill(<var>a</var>[<var>x</var>])</code> remove o valor da fun&ccedil;&atilde;o de array <var>a</var>
armazenado para o argumento <var>x</var>;
a pr&oacute;xima vez que <var>a</var> foor chamada com o argumento <var>x</var>,
o valor da fun&ccedil;&atilde;o &eacute; recomputado.
Todavia, n&atilde;o exite caminho para remover todos os valores armazenados de uma vez,
exceto para <code>kill(<var>a</var>)</code> ou <code>remarray(<var>a</var>)</code>,
o qual remove tamb&eacute;m remove a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o de array.
</p>
<hr size="6">
<a name="Macros"></a>
<a name="SEC163"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC162" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC164" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 39.3 Macros </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>buildq</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX1296"></a>
</dt>
<dd><p>Substitue vari&aacute;veis nomeadas pela lista <var>L</var> dentro da express&atilde;o <var>expr</var>,
paralelamente,
sem avaliar <var>expr</var>.
A express&atilde;o resultante &eacute; simplificada,
mas n&atilde;o avaliada,
ap&oacute;s <code>buildq</code> realizar a substitui&ccedil;&atilde;o.
</p>
<p>Os elementos de <var>L</var> s&atilde;o s&iacute;mbolos ou express&otilde;es de atribui&ccedil;&atilde;o <code><var>s&iacute;mbolo</var>: <var>valor</var></code>,
avaliadas paralelamente.
Isto &eacute;, a associa&ccedil;&atilde;o de uma vari&aacute;vel sobre o lado direito de uma atribui&ccedil;&atilde;o
&eacute; a associa&ccedil;&atilde;o daquela vari&aacute;vel no contexto do qual <code>buildq</code> for chamada,
n&atilde;o a associa&ccedil;&atilde;o daquela vari&aacute;vel na lista <var>L</var> de vari&aacute;veis.
Se alguma vari&aacute;vel em <var>L</var> n&atilde;o dada como uma atribui&ccedil;&atilde;o expl&iacute;cita,
sua associa&ccedil;&atilde;o em <code>buildq</code> &eacute; a mesma que no contexto no qual <code>buildq</code> for chamada.
</p>
<p>Ent&atilde;o as vari&aacute;veis nomeadas em <var>L</var> s&atilde;o substituidas em <var>expr</var> paralelamente.
Isto &eacute;, a substitui&ccedil;&atilde;o para cada vari&aacute;vel &eacute; determinada antes que qualquer substitui&ccedil;&atilde;o seja feita,
ent&atilde;o a substitui&ccedil;&atilde;o para uma vari&aacute;vel n&atilde;o tem efeito sobre qualquer outra.
</p>
<p>Se qualquer vari&aacute;vel <var>x</var> aparecer como <code>splice (<var>x</var>)</code> em <var>expr</var>,
ent&atilde;o <var>x</var> deve estar associada para uma lista,
e a lista recebe uma aplica&ccedil;&atilde;o da fun&ccedil;&atilde;o <code>splice</code> (&eacute; interpolada) na <var>expr</var> em lugar de substitu&iacute;da.
</p>
<p>Quaisquer vari&aacute;veis em <var>expr</var> n&atilde;o aparecendo em <var>L</var> s&atilde;o levados no resultado tal como foram escritos,
mesmo se elas tiverem associa&ccedil;&otilde;es no contexto do qual <code>buildq</code> tiver sido chamada.
</p>
<p>Exemplos
</p>
<p><code>a</code> &eacute; explicitamente associada a <code>x</code>,
enquanto <code>b</code> tem a mesma associa&ccedil;&atilde;o (nomeadamente 29) como no contexto chamado,
e <code>c</code> &eacute; levada do come&ccedil;o ao fim da forma como foi escrita.
A express&atilde;o resultante n&atilde;o &eacute; avaliada at&eacute; a avalia&ccedil;&atilde;o expl&iacute;cita ( com duplo ap&oacute;strofo - n&atilde;o com aspas - <code>''%</code>.
</p>
<pre class="example">(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
</pre>
<p><code>e</code> est&aacute; associado a uma lista, a qual aparece tamb&eacute;m como tal nos argumentos de <code>foo</code>,
e interpolada nos argumentos de <code>bar</code>.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
</pre>
<p>O resultado &eacute; simplificado ap&oacute;s substitui&ccedil;&atilde;o.
Se a simplifica&ccedil;&atilde;o for aplicada antes da substitui&ccedil;&atilde;o, esses dois resultados podem ser iguais.
</p><pre class="example">(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
</pre>
<p>As vari&aacute;veis em <var>L</var> s&atilde;o associadas em paralelo; se associadas seq&uuml;&ecirc;ncialmente,
o primeiro resultado pode ser <code>foo (b, b)</code>.
Substitui&ccedil;&otilde;es s&atilde;o realizadas em paralelo;
compare o segundo resultado com o resultado de <code>subst</code>,
que realiza substitui&ccedil;&otilde;es seq&uuml;&ecirc;ncialmente.
</p>
<pre class="example">(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
</pre>
<p>Constr&oacute;i uma lista de euq&ccedil;&otilde;es com algumas vari&aacute;veis ou express&otilde;es sobre o lado esquerdo
e seus valores sobre o lado direito.
<code>macroexpand</code> mostra a express&atilde;o retornada por <code>show_values</code>.
</p>
<pre class="example">(%i1) show_values ([L]) ::= buildq ([L], map (&quot;=&quot;, 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map(&quot;=&quot;, 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>macroexpand</b><i> (<var>expr</var>)</i>
<a name="IDX1297"></a>
</dt>
<dd><p>Retorna a expans&atilde;o da macro de <var>expr</var> sem avaliar a express&atilde;o,
quando <code>expr</code> for uma chamada de fun&ccedil;&atilde;o de macro.
De outra forma, <code>macroexpand</code> retorna <var>expr</var>.
</p>
<p>Se a expans&atilde;o de <var>expr</var> retorna outra chamada de fun&ccedil;&atilde;o de macro,
aquela chamada de fun&ccedil;&atilde;o de macro &eacute; tamb&eacute;m expandida.
</p>
<p><code>macroexpand</code> coloca ap&oacute;strofo em seus argumentos, isto &eacute;, n&atilde;o os avalia.
Todavia, se a expans&atilde;o de uma chamada de fun&ccedil;&atilde;o de macro tiver algum efeito,
esse efeito colateral &eacute; executado.
</p>
<p>Veja tamb&eacute;m <code>::=</code>, <code>macros</code>, e <code>macroexpand1</code>.
</p>
<p>Exemplos
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>macroexpand1</b><i> (<var>expr</var>)</i>
<a name="IDX1298"></a>
</dt>
<dd><p>Retorna a expans&atilde;o de macro de <var>expr</var> sem avaliar a express&atilde;o,
quando <code>expr</code> for uma chamada de fun&ccedil;&atilde;o de macro.
De outra forma, <code>macroexpand1</code> retorna <var>expr</var>.
</p>
<p><code>macroexpand1</code> n&atilde;o avalia seus argumentos.
Todavia, se a expans&atilde;o de uma chamada de fun&ccedil;&atilde;o de macro tiver algum efeito,
esse efeito colateral &eacute; executado.
</p>
<p>Se a expans&atilde;o de <var>expr</var> retornar outra chamada de fun&ccedil;&atilde;o de macro,
aquela chamada de fun&ccedil;&atilde;o de macro n&atilde;o &eacute; expandida.
</p>
<p>Veja tamb&eacute;m <code>::=</code>, <code>macros</code>, e <code>macroexpand</code>.
</p>
<p>Exemplos
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
</dd></dl>

<dl>
<dt><u>Global variable:</u> <b>macros</b>
<a name="IDX1299"></a>
</dt>
<dd><p>Default value: <code>[]</code>
</p>
<p><code>macros</code> &eacute; a lista de fun&ccedil;&otilde;es de macro definidas pelo usu&aacute;rio.
O operador de defini&ccedil;&atilde;o de fun&ccedil;&atilde;o de macro <code>::=</code> coloca uma nova fun&ccedil;&atilde;o de macro nessa lista,
e <code>kill</code>, <code>remove</code>, e <code>remfunction</code> removem fun&ccedil;&otilde;es de macro da lista.
</p>
<p>Veja tamb&eacute;m <code>infolists</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>splice</b><i> (<var>a</var>)</i>
<a name="IDX1300"></a>
</dt>
<dd><p>Une como se fosse um elo de liga&ccedil;&atilde;o (interpola) a lista nomeada atrav&eacute;s do &aacute;tomo <var>a</var> em uma express&atilde;o,
mas somente se <code>splice</code> aparecer dentro de <code>buildq</code>;
de outra forma, <code>splice</code> &eacute; tratada como uma fun&ccedil;&atilde;o indefinida.
Se aparecer dentro de <code>buildq</code> com <var>a</var> sozinho (sem <code>splice</code>),
<var>a</var> &eacute; substituido (n&atilde;o interpolado) como uma lista no resultado.
O argumento de <code>splice</code> pode somente ser um &aacute;tomo;
n&atilde;o pode ser uma lista lateral ou uma express&atilde;o que retorna uma lista.
</p>
<p>Tipicamente <code>splice</code> fornece os argumentos para uma fun&ccedil;&atilde;o ou operador.
Para uma fun&ccedil;&atilde;o <code>f</code>, a express&atilde;o <code>f (splice (<var>a</var>))</code> dentro de <code>buildq</code>
expande para <code>f (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>.
Para um operador <code>o</code>, a express&atilde;o <code>&quot;o&quot; (splice (<var>a</var>)</code> dentro de <code>buildq</code>
expande para <code>&quot;o&quot; (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>,
onde <code>o</code> pode ser qualquer tipo de operador (tipicamente um que toma multiplos argumentos).
Note que o operador deve ser contido dentro de aspas duplas <code>&quot;</code>.
</p>
<p>Exemplos
</p>
<pre class="example">(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], &quot;/&quot; (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix (&quot;&lt;&gt;&quot;, &quot;&lt;&gt;&quot;);
(%o3)                          &lt;&gt;
(%i4) buildq ([x: [1, %pi, z - y]], &quot;&lt;&gt;&quot; (splice (x)));
(%o4)                   &lt;&gt;1, %pi, z - y&lt;&gt;
</pre>
</dd></dl>


<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-para-Defini_00e7_00e3o-de-Fun_00e7_00e3o"></a>
<a name="SEC164"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC163" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 39.4 Fun&ccedil;&otilde;es e Vari&aacute;veis para Defini&ccedil;&atilde;o de Fun&ccedil;&atilde;o </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>apply</b><i> (<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX1301"></a>
</dt>
<dd><p>Constr&oacute;i e avalia uma express&atilde;p <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
</p>
<p><code>apply</code> n&atilde;o tenta distinguir fun&ccedil;&otilde;es de array de fun&ccedil;&otilde;es comuns;
quando <var>F</var> for o nome de uma fun&ccedil;&atilde;o de array,
<code>apply</code> avalia <code><var>F</var>(...)</code>
(isto &eacute;, uma chamada de fun&ccedil;&atilde;o com par&ecirc;ntesis em lugar de colch&ecirc;tes).
<code>arrayapply</code> avalia uma chamada de fun&ccedil;&atilde;o com colch&ecirc;tes nesse caso.
</p>
<p>Exemplos:
</p>
<p><code>apply</code> avalia seus argumentos.
Nesse exemplo, <code>min</code> &eacute; aplicado a <code>L</code>.
</p>
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre>
<p><code>apply</code> avalia argumentos, mesmo se a fun&ccedil;&atilde;o <var>F</var> disser que os argumentos n&atilde;o devem ser avaliados.
</p>
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre>
<p><code>apply</code> avalia o nome de fun&ccedil;&atilde;o <var>F</var>.
Ap&oacute;strofo <code>'</code> evita avalia&ccedil;&atilde;o.
<code>demoivre</code> &eacute; o nome de uma vari&aacute;vel global e tamb&eacute;m de uma fun&ccedil;&atilde;o.
</p>
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>block</b><i> ([<var>v_1</var>, ..., <var>v_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1302"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>block</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1303"></a>
</dt>
<dd><p><code>block</code> avalia <var>expr_1</var>, ..., <var>expr_n</var> em seq&uuml;&ecirc;ncia
e retorna o valor da &uacute;ltima express&atilde;o avaliada.
A seq&uuml;&ecirc;ncia pode ser modificada pelas fun&ccedil;&otilde;es <code>go</code>, <code>throw</code>, e <code>return</code>.
A &uacute;ltima express&atilde;o &eacute; <var>expr_n</var> a menos que <code>return</code> ou uma express&atilde;o contendo <code>throw</code>
seja avaliada.
Algumas vari&aacute;veis <var>v_1</var>, ..., <var>v_m</var> podem ser declaradas locais para o bloco;
essas s&atilde;o distinguidas das vari&aacute;veis globais dos mesmos nomes.
Se vari&aacute;veis n&atilde;o forem declaradas locais ent&atilde;o a lista pode ser omitida.
Dentro do bloco,
qualquer vari&aacute;vel que n&atilde;o <var>v_1</var>, ..., <var>v_m</var> &eacute; uma vari&aacute;vel global.
</p>
<p><code>block</code> salva os valores correntes das vari&aacute;veis <var>v_1</var>, ..., <var>v_m</var> (quaisquer valores)
na hora da entrada para o bloco,
ent&atilde;o libera as vari&aacute;veis dessa forma eles avaliam para si mesmos.
As vari&aacute;veis locais podem ser associadas a valores arbitr&aacute;rios dentro do bloco mas quando o
bloco &eacute; encerrado o valores salvos s&atilde;o restaurados,
e os valores atribu&iacute;dos dentro do bloco s&atilde;o perdidos.
</p>
<p><code>block</code> pode aparecer dentro de outro <code>block</code>.
Vari&aacute;veis locais s&atilde;o estabelecidas cada vez que um novo <code>block</code> &eacute; avaliado.
Vari&aacute;veis locais parecem ser globais para quaisquer blocos fechados.
Se uma vari&aacute;vel &eacute; n&atilde;o local em um bloco,
seu valor &eacute; o valor mais recentemente atribu&iacute;do por um bloco fechado, quaisquer que sejam,
de outra forma, seu valor &eacute; o valor da vari&aacute;vel no ambiente global.
Essa pol&iacute;tica pode coincidir com o entendimento usual de &quot;escopo din&acirc;mico&quot;.
</p>
<p>Se isso for desejado para salvar e restaurar outras propriedades locais
ao lado de <code>value</code>, por exemplo <code>array</code> (exceto para arrays completos),
<code>function</code>, <code>dependencies</code>, <code>atvalue</code>, <code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, e
<code>nonscalar</code> ent&atilde;o a fun&ccedil;&atilde;o <code>local</code> pode ser usada dentro do bloco
com argumentos sendo o nome das vari&aacute;veis.
</p>
<p>O valor do bloco &eacute; o valor da &uacute;ltima declara&ccedil;&atilde;o ou o
valor do argumento para a fun&ccedil;&atilde;o <code>return</code> que pode ser usada para sair
explicitamente do bloco.  A fun&ccedil;&atilde;o <code>go</code> pode ser usada para transferir o
controle para a declara&ccedil;&atilde;o do bloco que &eacute; identificada com o argumento
para <code>go</code>.  Para identificar uma declara&ccedil;&atilde;o, coloca-se antes dela um argumento at&ocirc;mico como
outra declara&ccedil;&atilde;o no bloco.  Por exemplo:
<code>block ([x], x:1, loop, x: x+1, ..., go(loop), ...)</code>.  O argumento para <code>go</code> deve
ser o nome de um identificador que aparece dentro do bloco.  N&atilde;o se deve usar <code>go</code> para
transferir para um identificador em um outro bloco a n&atilde;o ser esse que cont&eacute;m o <code>go</code>.
</p>
<p>Blocos tipicamente aparecem do lado direito de uma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o
mas podem ser usados em outros lugares tamb&eacute;m.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>break</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1304"></a>
</dt>
<dd><p>Avalia e imprime <var>expr_1</var>, ..., <var>expr_n</var> e ent&atilde;o
causa uma parada do Maxima nesse ponto e o usu&aacute;rio pode examinar e alterar
seu ambiente.  Nessa situa&ccedil;&atilde;o digite <code>exit;</code> para que o c&aacute;lculo seja retomado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>catch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1305"></a>
</dt>
<dd><p>Avalia <var>expr_1</var>, ..., <var>expr_n</var> uma por uma; se qualquer avalia&ccedil;&atilde;o
levar a uma avalia&ccedil;&atilde;o de uma express&atilde;o da
forma <code>throw (arg)</code>, ent&atilde;o o valor de <code>catch</code> &eacute; o valor de
<code>throw (arg)</code>, e express&otilde;es adicionais n&atilde;o s&atilde;o avaliadas.
Esse &quot;retorno n&atilde;o local&quot; atravessa assim qualquer profundidade de
aninhar para o mais pr&oacute;ximo contendo <code>catch</code>.
Se n&atilde;o existe nenhum <code>catch</code> contendo um <code>throw</code>, uma mensagem de erro &eacute; impressa.
</p>
<p>Se a avalia&ccedil;&atilde;o de argumentos n&atilde;o leva para a avalia&ccedil;&atilde;o de qualquer <code>throw</code>
ent&atilde;o o valor de <code>catch</code> &eacute; o valor de <var>expr_n</var>.
</p>
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre>
<p>A fun&ccedil;&atilde;o <code>g</code> retorna uma lista de <code>f</code> de cada elemento de <code>l</code> se <code>l</code>
consiste somente de n&uacute;meros n&atilde;o negativos; de outra forma, <code>g</code> &quot;captura&quot; o
primeiro elemento negativo de <code>l</code> e &quot;arremessa-o&quot;.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compfile</b><i> (<var>nomearquivo</var>, <var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1306"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compfile</b><i> (<var>nomearquivo</var>, fun&ccedil;&otilde;es)</i>
<a name="IDX1307"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compfile</b><i> (<var>nomearquivo</var>, all)</i>
<a name="IDX1308"></a>
</dt>
<dd><p>Traduz fu&ccedil;&otilde;es Maxima para Lisp 
e escreve o c&oacute;digo traduzido no arquivo <var>nomearquivo</var>.
</p>
<p><code>compfile(<var>nomearquivo</var>, <var>f_1</var>, ..., <var>f_n</var>)</code> traduz as
fun&ccedil;&otilde;es especificadas.
<code>compfile(<var>nomearquivo</var>, functions)</code> e <code>compfile(<var>nomearquivo</var>, all)</code>
traduz todas as fun&ccedil;&otilde;es definidas pelo usu&aacute;rio.
</p>
<p>As tradu&ccedil;&otilde;es Lisp n&atilde;o s&atilde;o avaliadas, nem &eacute; o arquivo de sa&iacute;da processado pelo compilador Lisp.
<code>translate</code> cria e avalia tradu&ccedil;&otilde;es Lisp.
<code>compile_file</code> traduz Maxima para Lisp, e ent&atilde;o executa o compilador Lisp.  
</p>
<p>Veja tamb&eacute;m <code>translate</code>, <code>translate_file</code>, e <code>compile_file</code>.
</p>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1309"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile</b><i> (fun&ccedil;&otilde;es)</i>
<a name="IDX1310"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile</b><i> (all)</i>
<a name="IDX1311"></a>
</dt>
<dd><p>Traduz fun&ccedil;&otilde;es Maxima <var>f_1</var>, ..., <var>f_n</var> para Lisp, avalia a tradu&ccedil;&atilde;o Lisp,
e chama a fun&ccedil;&atilde;o Lisp <code>COMPILE</code> sobre cada fun&ccedil;&atilde;o traduzida.
<code>compile</code> retorna uma lista de nomes de fun&ccedil;&otilde;es compiladas.
</p>
<p><code>compile (all)</code> ou <code>compile (fun&ccedil;&otilde;es)</code> compila todas as fun&ccedil;&otilde;es definidas pelo usu&aacute;rio.
</p>
<p><code>compile</code> n&atilde;o avalia seus argumentos; 
o operador ap&oacute;strofo-ap&oacute;strofo <code>''</code> faz com que ocorra avalia&ccedil;&atilde;o sobrepondo-se ao ap&oacute;strofo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define</b><i> (<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>), <var>expr</var>)</i>
<a name="IDX1312"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define</b><i> (<var>f</var>[<var>x_1</var>, ..., <var>x_n</var>], <var>expr</var>)</i>
<a name="IDX1313"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define</b><i> (funmake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1314"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define</b><i> (arraymake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1315"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define</b><i> (ev (<var>expr_1</var>), <var>expr_2</var>)</i>
<a name="IDX1316"></a>
</dt>
<dd><p>Define uma fun&ccedil;&atilde;o chamada <var>f</var> com argumentos <var>x_1</var>, ..., <var>x_n</var> e corpo da fun&ccedil;&atilde;o <var>expr</var>.
<code>define</code> sempre avalia seu segundo argumento (a menos que expl&iacute;citamente receba um apostrofo de forma a evitar a avalia&ccedil;&atilde;o).
A fun&ccedil;&atilde;o ent&atilde;o definida pode ser uma fun&ccedil;&atilde;o comum do Maxima (com argumentos contidos entre par&ecirc;tesis)
ou uma fun&ccedil;&atilde;o de array (com argumentos contidos entre colch&ecirc;tes).
</p>
<p>Quando o &uacute;ltimo ou &uacute;nico argumento da fun&ccedil;&atilde;o <var>x_n</var> for uma lista de um elemento,
a fun&ccedil;&atilde;o definida por <code>define</code> aceita um n&uacute;mero vari&aacute;vel de argumentos.
Os argumentos atuais s&atilde;o atribu&iacute;dos um a um a argumentos formais <var>x_1</var>, ..., <var>x_(n - 1)</var>,
e quaisquer argumentos adicionais atuais, se estiverem presentes, s&atilde;o atribu&iacute;dos a <var>x_n</var> como uma lista.
</p>
<p>Quando o primeiro argumento de <code>define</code> for uma express&atilde;o da forma
<code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> or <code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>,
os argumentos s&atilde;o avaliados mas <var>f</var> n&atilde;o &eacute; avaliada,
mesmo se j&aacute; existe anteriormente uma fun&ccedil;&atilde;o ou vari&aacute;vel com aquele nome.
</p>
<p>Quando o primeiro argumento for uma express&atilde;o com operador <code>funmake</code>, <code>arraymake</code>, ou <code>ev</code>,
o primeiro argumento ser&aacute; avaliado;
isso permite para o nome da fun&ccedil;&atilde;o seja calculado, tamb&eacute;m como o corpo.
</p>
<p>Todas as defini&ccedil;&otilde;es de fun&ccedil;&atilde;o aparecem no mesmo n&iacute;vel de escopo e visibilidade;
definindo uma fun&ccedil;&atilde;o <code>f</code> dentro de outra fun&ccedil;&atilde;o <code>g</code>
n&atilde;o limita o escopo de <code>f</code> a <code>g</code>.
</p>
<p>Se algum argumento formal <var>x_k</var> for um s&iacute;mbolo com ap&oacute;strofo (ap&oacute;s ter sido feita uma avalia&ccedil;&atilde;o),
a fun&ccedil;&atilde;o definida por <code>define</code> n&atilde;o avalia o correspondente atual argumento.
de outra forma todos os argumentos atuais s&atilde;o avaliados.
</p>
<p>Veja tamb&eacute;m <code>:=</code> and <code>::=</code>.
</p>
<p>Exemplos:
</p>
<p><code>define</code> sempre avalia seu segundo argumento (a menos que expl&iacute;citamente receba um apostrofo de forma a evitar a avalia&ccedil;&atilde;o).
</p>
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre>
<p>A fun&ccedil;&atilde;o definida por <code>define</code> pode ser uma fun&ccedil;&atilde;o comum do Maxima ou uma fun&ccedil;&atilde;o de array.
</p>
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre>
<p>Quando o &uacute;ltimo ou &uacute;nico argumento da fun&ccedil;&atilde;o <var>x_n</var> for uma lista de um &uacute;nico elemento,
a fun&ccedil;&atilde;o definida por <code>define</code> aceita um n&uacute;mero vari&aacute;vel de argumentos.
</p>
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre>
<p>When the first argument is an expression with operator <code>funmake</code>, <code>arraymake</code>, or <code>ev</code>,
the first argument is evaluated.
</p>
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>define_variable</b><i> (<var>name</var>, <var>default_value</var>, <var>mode</var>)</i>
<a name="IDX1317"></a>
</dt>
<dd><p>Introduz uma vari&aacute;vel global dentro do ambiente Maxima.
<code>define_variable</code> &eacute; &uacute;til em pacotes escritos pelo usu&aacute;rio, que s&atilde;o muitas vezes traduzidos ou compilados.
</p>
<p><code>define_variable</code> realiza os seguintes passos:
</p>
<ol>
<li>
<code>mode_declare (<var>name</var>, <var>mode</var>)</code> declara o modo de <var>name</var> para o tradutor.
Veja <code>mode_declare</code> para uma lista dos modos poss&iacute;veis.

</li><li>
Se a vari&aacute;vel &eacute; n&atilde;o associada, <var>default_value</var> &eacute; atribu&iacute;do para <var>name</var>.

</li><li>
<code>declare (<var>name</var>, special)</code> declara essa vari&aacute;vel especial.

</li><li>
Associa <var>name</var> com uma fun&ccedil;&atilde;o de teste
para garantir que a <var>name</var> seja somente atribu&iacute;do valores do modo declarado.
</li></ol>



<p>A propriedade <code>value_check</code> pode ser atribu&iacute;da a qualquer vari&aacute;vel que tenha sido definida
via <code>define_variable</code> com um outro modo que n&atilde;o <code>any</code>.
A propriedade <code>value_check</code> &eacute; uma express&atilde;o lambda ou o nome de uma fun&ccedil;&atilde;o de uma vari&aacute;vel,
que &eacute; chamada quando uma tentativa &eacute; feita para atribuir um valor a uma vari&aacute;vel.
O argumento da  fun&ccedil;&atilde;o <code>value_check</code> &eacute; o valor que ser&aacute; atribu&iacute;do.
</p>
<p><code>define_variable</code> avalia <code>default_value</code>, e n&atilde;o avalia <code>name</code> e <code>mode</code>.
<code>define_variable</code> retorna o valor corrente de <code>name</code>,
que &eacute; <code>default_value</code> se <code>name</code> n&atilde;o tiver sido associada antes,
e de outra forma isso &eacute; o valor pr&eacute;vio de <code>name</code>.
</p>
<p>Exemplos:
</p>
<p><code>foo</code> &eacute; uma vari&aacute;vel Booleana, com o valor inicial <code>true</code>.
</p>
<pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre>
<p><code>bar</code> &eacute; uma vari&aacute;vel inteira, que deve ser um n&uacute;mero primo.
</p>
<pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 &eacute; not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre>
<p><code>baz_quux</code> &eacute; uma vari&aacute;vel que n&atilde;o pode receber a atribui&ccedil;&atilde;o de um valor.
O modo <code>any_check</code> &eacute; como <code>any</code>, 
mas <code>any_check</code> habilita o mecanismo <code>value_check</code>, e <code>any</code> n&atilde;o habilita.
</p>
<pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>dispfun</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1318"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>dispfun</b><i> (all)</i>
<a name="IDX1319"></a>
</dt>
<dd><p>Mostra a defini&ccedil;&atilde;o de fun&ccedil;&otilde;es definidas pelo usu&aacute;rio <var>f_1</var>, ..., <var>f_n</var>.
Cada argumento pode ser o nome de uma macro (definida com <code>::=</code>),
uma fun&ccedil;&atilde;o comum (definida com <code>:=</code> ou <code>define</code>),
uma fun&ccedil;&atilde;o array (definida com <code>:=</code> ou com <code>define</code>,
mas contendo argumentos entre colch&ecirc;tes <code>[ ]</code>),
uma fun&ccedil;&atilde;o subscrita, (definida com <code>:=</code> ou <code>define</code>,
mas contendo alguns argumentos entre colch&ecirc;tes e outros entre par&ecirc;ntesis <code>( )</code>)
uma da fam&iacute;lia de fun&ccedil;&otilde;es subscritas selecionadas por um valor subscrito particular,
ou uma fun&ccedil;&atilde;o subscrita definida com uma constante subscrita.
</p>
<p><code>dispfun (all)</code> mostra todas as fun&ccedil;&otilde;es definidas pelo usu&aacute;rio como
dadas pelas <code>functions</code>, <code>arrays</code>, e listas de <code>macros</code>,
omitindo fun&ccedil;&otilde;es subscritas definidas com constantes subscritas.
</p>
<p><code>dispfun</code> cria um R&oacute;tulo de express&atilde;o intermedi&aacute;ria
(<code>%t1</code>, <code>%t2</code>, etc.)
para cada fun&ccedil;&atilde;o mostrada, e atribui a defini&ccedil;&atilde;o de fun&ccedil;&atilde;o para o r&oacute;tulo.
Em contraste, <code>fundef</code> retorna a defini&ccedil;&atilde;o de fun&ccedil;&atilde;o.
</p>
<p><code>dispfun</code> n&atilde;o avalia seus argumentos; 
O operador ap&oacute;strofo-ap&oacute;strofo <code>''</code> faz com que ocorra avalia&ccedil;&atilde;o.
<code>dispfun</code> retorna a lista de r&oacute;tulos de express&otilde;es intermedi&aacute;rias correspondendo &agrave;s fun&ccedil;&otilde;es mostradas.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de sistema:</u> <b>functions</b>
<a name="IDX1320"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>[]</code>
</p>
<p><code>functions</code> &eacute; a lista de todas as fun&ccedil;&otilde;es comuns do Maxima
na sess&atilde;o corrente.
Uma fun&ccedil;&atilde;o comum &eacute; uma fun&ccedil;&atilde;o constru&iacute;da atrav&eacute;s de
<code>define</code> ou de <code>:=</code> e chamada com par&ecirc;ntesis <code>()</code>.
Uma fun&ccedil;&atilde;o pode ser definida pela linha de comando do Maxima de forma interativa com o usu&aacute;rio
ou em um arquivo Maxima chamado por <code>load</code> ou <code>batch</code>.
</p>
<p>Fun&ccedil;&otilde;es de array (chamadas com colch&ecirc;tes, e.g., <code>F[x]</code>)
e fun&ccedil;&otilde;es com subscritos (chamadas com colch&ecirc;tes e par&ecirc;ntesis, e.g., <code>F[x](y)</code>)
s&atilde;o lsitados atrav&eacute;s da vari&aacute;vel global <code>arrays</code>, e n&atilde;o por meio de <code>functions</code>.
</p>
<p>Fun&ccedil;&otilde;es Lisp n&atilde;o s&atilde;o mantidas em nenhuma lista.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fundef</b><i> (<var>f</var>)</i>
<a name="IDX1321"></a>
</dt>
<dd><p>Retorna a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o <var>f</var>.
</p>
<p>O argumento pode ser o nome de uma macro (definida com <code>::=</code>),
uma fun&ccedil;&atilde;o comum (definida com <code>:=</code> ou <code>define</code>),
uma fun&ccedil;&atilde;o array (definida com <code>:=</code> ou <code>define</code>,
mas contendo argumentos entre colch&ecirc;tes <code>[ ]</code>),
Uma fun&ccedil;&atilde;o subscrita, (definida com <code>:=</code> ou <code>define</code>,
mas contendo alguns argumentos entre colch&ecirc;tes e par&ecirc;ntesis <code>( )</code>)
uma da fam&iacute;lia de fun&ccedil;&otilde;es subscritas selecionada por um valor particular subscrito,
ou uma fun&ccedil;&atilde;o subscrita definida com uma constante subscrita.
</p>
<p><code>fundef</code> n&atilde;o avalia seu argumento;
o operador ap&oacute;strofo-ap&oacute;strofo <code>''</code> faz com que ocorra avalia&ccedil;&atilde;o.
</p>
<p><code>fundef (<var>f</var>)</code> retorna a defini&ccedil;&atilde;o de <var>f</var>.
Em contraste, <code>dispfun (<var>f</var>)</code> cria um r&oacute;tulo de express&atilde;o intermedi&aacute;ria
e atribui a defini&ccedil;&atilde;o para o r&oacute;tulo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>funmake</b><i> (<var>F</var>, [<var>arg_1</var>, ..., <var>arg_n</var>])</i>
<a name="IDX1322"></a>
</dt>
<dd><p>Retorna uma express&atilde;o <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
O valor de retorno &eacute; simplificado, mas n&atilde;o avaliado,
ent&atilde;o a fun&ccedil;&atilde;o <var>F</var> n&atilde;o &eacute; chamada, mesmo se essa fun&ccedil;&atilde;o <var>F</var> existir.
</p>
<p><code>funmake</code> n&atilde;o tenta distinguir fun&ccedil;&otilde;es de array de fun&ccedil;&otilde;es comuns;
quando <var>F</var> for o nome de uma fun&ccedil;&atilde;o de array,
<code>funmake</code> retorna <code><var>F</var>(...)</code>
(isto &eacute;, uma chamada de fun&ccedil;&atilde;o com par&ecirc;ntesis em lugar de colch&ecirc;tes).
<code>arraymake</code> retorna uma chamada de fun&ccedil;&atilde;o com colch&ecirc;tes nesse caso.
</p>
<p><code>funmake</code> avalia seus argumentos.
</p>
<p>Exemplos:
</p>
<p><code>funmake</code> aplicada a uma fun&ccedil;&atilde;o comum do Maxima.
</p>
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre>
<p><code>funmake</code> aplicada a uma macro.
</p>
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre>
<p><code>funmake</code> aplicada a uma fun&ccedil;&atilde;o subscrita.
</p>
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre>
<p><code>funmake</code> aplicada a um s&iacute;mbolo que n&atilde;o &eacute; uma fun&ccedil;&atilde;o definida de qualquer tipo.
</p>
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre>
<p> <code>funmake</code> avalia seus argumentos, mas n&atilde;o o valor de retorno.
</p>
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre>
<p>Maxima simplifica o valor de retorno de <code>funmake</code>.
</p>
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1323"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lambda</b><i> ([[<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1324"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lambda</b><i> ([<var>x_1</var>, ..., <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1325"></a>
</dt>
<dd><p>Define e retorna uma express&atilde;o lambda (que &eacute;, uma fun&ccedil;&atilde;o an&ocirc;nima)
A fun&ccedil;&atilde;o pode ter argumentos que sejam necess&aacute;rios <var>x_1</var>, ..., <var>x_m</var>
e/ou argumentos opcionais <var>L</var>, os quais aparecem dentro do corpo da fun&ccedil;&atilde;o como uma lista.
O valor de retorno da fun&ccedil;&atilde;o &eacute; <var>expr_n</var>.
Uma express&atilde;o lambda pode ser atribu&iacute;da para uma vari&aacute;vel e avaliada como uma fun&ccedil;&atilde;o comum.
Uma express&atilde;o lambda pode aparecer em alguns contextos nos quais um nome de fun&ccedil;&atilde;o &eacute; esperado.
</p>
<p>Quando a fun&ccedil;&atilde;o &eacute; avaliada,
vari&aacute;veis locais n&atilde;o associadas <var>x_1</var>, ..., <var>x_m</var> s&atilde;o criadas.
<code>lambda</code> pode aparecer dentro de <code>block</code> ou outra fun&ccedil;&atilde;o <code>lambda</code>;
vari&aacute;veis locais s&atilde;o estabelecidas cada vez que outro <code>block</code> ou fun&ccedil;&atilde;o <code>lambda</code> &eacute; avaliada.
Vari&aacute;veis locais parecem ser globais para qualquer coisa contendo <code>block</code> ou <code>lambda</code>.
Se uma vari&aacute;vel &eacute; n&atilde;o local,
seu valor &eacute; o valor mais recentemente atribu&iacute;do em alguma coisa contendo <code>block</code> ou <code>lambda</code>, qualquer que seja,
de outra forma, seu valor &eacute; o valor da vari&aacute;vel no ambiente global.
Essa pol&iacute;tica pode coincidir com o entendimento usual de &quot;escopo din&acirc;mico&quot;.
</p>
<p>Ap&oacute;s vari&aacute;veis locais serem estabelecidas,
<var>expr_1</var> at&eacute; <var>expr_n</var> s&atilde;o avaliadas novamente.
a vari&aacute;vel especial <code>%%</code>, representando o valor da express&atilde;o precedente,
&eacute; reconhecida.
<code>throw</code> e <code>catch</code> pode tamb&eacute;m aparecer na lista de express&otilde;es.
</p>
<p><code>return</code> n&atilde;o pode aparecer em uma express&atilde;o lambda a menos que contendo <code>block</code>,
nesse caso <code>return</code> define o valor de retorno do  bloco e n&atilde;o da
express&atilde;o lambda,
a menos que o bloco seja <var>expr_n</var>.
Da mesma forma, <code>go</code> n&atilde;o pode aparecer em uma express&atilde;o lambda a menos que contendo <code>block</code>.
</p>
<p><code>lambda</code> n&atilde;o avalia seus argumentos; 
o operador ap&oacute;strofo-ap&oacute;strofo <code>''</code> faz com que ocorra avalia&ccedil;&atilde;o.
</p>
<p>Exemplos:
</p>
<ul>
<li>
A express&atilde;o lambda pode ser atribu&iacute;da para uma vari&aacute;vel e avaliada como uma fun&ccedil;&atilde;o comum.
</li></ul>
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre><ul>
<li>
Uma express&atilde;o lambda pode aparecer em contextos nos quais uma avalia&ccedil;&atilde;o de fun&ccedil;&atilde;o &eacute; esperada como resposta.
</li></ul>
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre><ul>
<li>
Vari&aacute;veis argumento s&atilde;o vari&aacute;veis locais.
Outras vari&aacute;veis aparecem para serem vari&aacute;veis globais.
Vari&aacute;veis globais s&atilde;o avaliadas ao mesmo tempo em que a express&atilde;o lambda &eacute; avaliada,
a menos que alguma avalia&ccedil;&atilde;o especial seja for&ccedil;ada por alguns meios, tais como <code>''</code>.
</li></ul>
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre><ul>
<li>
Express&otilde;es lambda podem ser aninhadas.
Vari&aacute;veis locais dentro de outra express&atilde;o lambda parece ser global para a express&atilde;o interna
a menos que mascarada por vari&aacute;veis locais de mesmos nomes.
</li></ul>
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre><ul>
<li>
Uma vez que <code>lambda</code> n&atilde;o avalia seus argumentos, a express&atilde;o lambda <code>i</code> abaixo
n&atilde;o define uma fun&ccedil;&atilde;o &quot;multiplica&ccedil;&atilde;o por <code>a</code>&quot;.
Tanto uma fun&ccedil;&atilde;o pode ser definida via <code>buildq</code>, como na express&atilde;o lambda <code>i2</code> abaixo.
</li></ul>
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre><ul>
<li>
Uma express&atilde;o lambda pode receber um n&uacute;mero vari&aacute;vel de argumentos,
os quais s&atilde;o indicados por meio de <code>[<var>L</var>]</code> como o argumento &uacute;nico ou argumento final.
Os argumentos aparecem dentro do corpo da fun&ccedil;&atilde;o como uma lista.
</li></ul>
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>local</b><i> (<var>v_1</var>, ..., <var>v_n</var>)</i>
<a name="IDX1326"></a>
</dt>
<dd><p>Declara as vari&aacute;veis <var>v_1</var>, ..., <var>v_n</var> para serem locais com
rela&ccedil;&atilde;o a todas as propriedades na declara&ccedil;&atilde;o na qual essa fun&ccedil;&atilde;o
&eacute; usada.
</p>
<p><code>local</code> n&atilde;o avalia seus argumentos.
<code>local</code> retorna <code>done</code>.
</p>
<p><code>local</code> pode somente ser usada em <code>block</code>, no corpo de defini&ccedil;&otilde;es
de fun&ccedil;&atilde;o ou express&otilde;es <code>lambda</code>, ou na fun&ccedil;&atilde;o <code>ev</code>, e somente uma
ocorr&ecirc;cia &eacute; permitida em cada.
</p>
<p><code>local</code> &eacute; independente de <code>context</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>macroexpansion</b>
<a name="IDX1327"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p><code>macroexpansion</code> controla se a expans&atilde;o (isto &eacute;, o valor de retorno) de uma fun&ccedil;&atilde;o de macro
&eacute; substitu&iacute;do pela chamada &agrave; fun&ccedil;&atilde;o de macro.
Uma substitui&ccedil;&atilde;o pode aumentar a velocidade de subseq&uuml;&ecirc;nte avalia&ccedil;&otilde;es da express&atilde;o,
ao custo de armazenar a expans&atilde;o.
</p>
<dl compact="compact">
<dt> <code>false</code></dt>
<dd><p>A expans&atilde;o de uma fun&ccedil;&atilde;o de macro n&atilde;o &eacute; substitu&iacute;da pela chamada de fun&ccedil;&atilde;o de macro.
</p></dd>
<dt> <code>expand</code></dt>
<dd><p>Da primeira vez que a fun&ccedil;&atilde;o de macro &eacute; avaliada,
a expans&atilde;o &eacute; armazenada.
A expans&atilde;o n&atilde;o &eacute; recalculada sobre chamadas subseq&uuml;&ecirc;ntes;
qualquer efeito colateral (tais como <code>print</code> ou atribui&ccedil;&otilde;es a vari&aacute;veis globais) ocorrem
somente quando chamadas &agrave; fun&ccedil;&atilde;o de macro forem avaliadas primeiramente.
Expans&otilde;es em uma express&atilde;o n&atilde;o afetam outras express&otilde;es
que possuem a mesma chamada &agrave; fun&ccedil;&atilde;o de macro.
</p></dd>
<dt> <code>displace</code></dt>
<dd><p>Na primeira vez que uma fun&ccedil;&atilde;o de macro &eacute; avaliada,
a expans&atilde;o &eacute; substitu&iacute;da pela chamada,
dessa forma modificando a express&atilde;o a partir da qual a fun&ccedil;&atilde;o de macro foi chamada.
A expans&atilde;o n&atilde;o &eacute; recalculada nas chamadas subseq&uuml;&ecirc;ntes;
qualquer efeito colateral acontece somente quando a chamada &agrave; fun&ccedil;&atilde;o de macro for avaliada primeiramente.
Expans&otilde;es na express&atilde;o n&atilde;o afetam outras express&otilde;es
que possuem a mesma chamada &agrave; fun&ccedil;&atilde;o de macro.
</p></dd>
</dl>

<p>Exemplos
</p>
<p>Quandon <code>macroexpansion</code> for <code>false</code>,
uma fun&ccedil;&atilde;o de macro &eacute; chamada a cada vez que a express&atilde;o que est&aacute; chamando &eacute; avaliada,
e a express&atilde;o que est&aacute; chamandon&atilde;o &eacute; modificada.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Quando <code>macroexpansion</code> for <code>expand</code>,
uma fun&ccedil;&atilde;o de macro &eacute; chamada uma &uacute;nica vez,
e a express&atilde;o que est&aacute; chamando n&atilde;o &eacute; modificada.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Quando <code>macroexpansion</code> for <code>expand</code>,
uma fun&ccedil;&atilde;o de macro &eacute; chamada uma &uacute;nica vez,
e a express&atilde;o que est&aacute; chamando &eacute; modificada.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>mode_checkp</b>
<a name="IDX1328"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>mode_checkp</code> &eacute; <code>true</code>, <code>mode_declare</code> verifica os modos
de associa&ccedil;&atilde;o de vari&aacute;veis.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>mode_check_errorp</b>
<a name="IDX1329"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>mode_check_errorp</code> &eacute; <code>true</code>, <code>mode_declare</code> chama
a fun&ccedil;&atilde;o &quot;error&quot;.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>mode_check_warnp</b>
<a name="IDX1330"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>mode_check_warnp</code> &eacute; <code>true</code>, modo &quot;errors&quot; s&atilde;o
descritos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>mode_declare</b><i> (<var>y_1</var>, <var>mode_1</var>, ..., <var>y_n</var>, <var>mode_n</var>)</i>
<a name="IDX1331"></a>
</dt>
<dd><p><code>mode_declare</code> &eacute; usado para declarar os modos de vari&aacute;veis e
fun&ccedil;&otilde;es para subseq&uuml;&ecirc;nte tradu&ccedil;&atilde;o ou compila&ccedil;&atilde;o das fun&ccedil;&otilde;es.
<code>mode_declare</code> &eacute; tipicamente colocada no in&iacute;cio de uma defini&ccedil;&atilde;o de
fun&ccedil;&atilde;o, no in&iacute;cio de um script Maxima, ou executado atrav&eacute;s da linha de comando de forma interativa.
</p>
<p>Os argumentos de <code>mode_declare</code> s&atilde;o pares consistindo de  uma vari&aacute;vel e o modo que &eacute;
um de <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code>, ou <code>float</code>.
Cada vari&aacute;vel pode tamb&eacute;m
ser uma lista de vari&aacute;veis todas as quais s&atilde;o declaradas para ter o mesmo modo.
</p>
<p>Se uma vari&aacute;vel &eacute; um array, e se todo elemento do array que &eacute;
referenciado tiver um valor ent&atilde;o <code>array (yi, complete, dim1, dim2, ...)</code>
em lugar de 
</p><pre class="example">array(yi, dim1, dim2, ...)
</pre><p>dever&aacute; ser usado primeiro
declarando as associa&ccedil;&otilde;es do array.
Se todos os elementos do array
est&atilde;o no modo <code>fixnum</code> (<code>float</code>), use <code>fixnum</code> (<code>float</code>) em lugar de <code>complete</code>.
Tamb&eacute;m se todo elemento do array est&aacute; no mesmo modo, digamos <code>m</code>, ent&atilde;o
</p>
<pre class="example">mode_declare (completearray (yi), m))
</pre>
<p>dever&aacute; ser usado para uma tradu&ccedil;&atilde;o
eficiente.
</p>
<p>C&oacute;digo num&eacute;ricos usando arrays podem rodar mais r&aacute;pidamente
se for decladado o tamanho esperado do array, como em:
</p>
<pre class="example">mode_declare (completearray (a [10, 10]), float)
</pre>
<p>para um array num&eacute;rico em ponto flutuante que &eacute; 10 x 10.
</p>
<p>Pode-se declarar o modo do resultado de uma fun&ccedil;&atilde;o
usando <code>function (f_1, f_2, ...)</code> como um argumento;
aqui <code>f_1</code>, <code>f_2</code>, ...  s&atilde;o nomes
de fun&ccedil;&otilde;es.  Por exemplo a express&atilde;o,
</p>
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre>
<p>declara que os valores retornados por <code>f_1</code>, <code>f_2</code>, ...  s&atilde;o inteiros palavra simples.
</p>
<p><code>modedeclare</code> &eacute; um sin&ocirc;nimo para <code>mode_declare</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>mode_identity</b><i> (<var>arg_1</var>, <var>arg_2</var>)</i>
<a name="IDX1332"></a>
</dt>
<dd><p>Uma forma especial usada com <code>mode_declare</code> e
<code>macros</code> para declarar, e.g., uma lista de listas de n&uacute;meros em ponto flutuante ou outros
objetos de dados.  O primeiro argumento para <code>mode_identity</code> &eacute; um valor primitivo
nome de modo como dado para <code>mode_declare</code> (i.e., um de <code>float</code>, <code>fixnum</code>, <code>number</code>,
<code>list</code>, ou <code>any</code>), e o segundo argumento &eacute; uma express&atilde;o que &eacute;
avaliada e retornada com o valor de <code>mode_identity</code>.  Todavia, se o
valor de retorno n&atilde;o &eacute; permitido pelo modo declarado no primeiro
argumento, um erro ou alerta &eacute; sinalizado.  Um ponto importante &eacute;
que o modo da express&atilde;o como determinado pelo Maxima para o tradutor
Lisp, ser&aacute; aquele dado como o primeiro argumento, independente de
qualquer coisa que v&aacute; no segundo argumento.
E.g., <code>x: 3.3; mode_identity (fixnum, x);</code> retorna um erro.  <code>mode_identity (flonum, x)</code>
returns 3.3 .  
Isso tem n&uacute;merosas utilidades, e.g., se voc&ecirc; soube que <code>first (l)</code> retornou um
n&uacute;mero ent&atilde;o voc&ecirc; pode escrever <code>mode_identity (number, first (l))</code>.  Todavia,
um mais eficiente caminho para fazer isso &eacute; definir uma nova primitiva,
</p>
<pre class="example">firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));
</pre>
<p>e usar <code>firstnumb</code>
toda vez que voc&ecirc; pegar o primeiro de uma lista de n&uacute;meros.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>transcompile</b>
<a name="IDX1333"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>transcompile</code> &eacute; <code>true</code>, <code>translate</code> e <code>translate_file</code> geram
declara&ccedil;&otilde;es para fazer o c&oacute;digo traduzido mais adequado para compila&ccedil;&atilde;o.
</p>
<p><code>compfile</code> escolhe <code>transcompile: true</code> para a dura&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>translate</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX1334"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>translate</b><i> (fun&ccedil;&otilde;es)</i>
<a name="IDX1335"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>translate</b><i> (all)</i>
<a name="IDX1336"></a>
</dt>
<dd><p>Traduz fun&ccedil;&otilde;es definidas pelo usu&aacute;rio
<var>f_1</var>, ..., <var>f_n</var> da linguagem de Maxima para Lisp
e avalia a tradu&ccedil;&atilde;o Lisp.
Tipicamente as fun&ccedil;&otilde;es traduzidas executam mais r&aacute;pido que as originais.
</p>
<p><code>translate (all)</code> ou <code>translate (fun&ccedil;&otilde;es)</code> traduz todas as fun&ccedil;&otilde;es definidas pelo usu&aacute;rio.
</p>
<p>Fun&ccedil;&otilde;es a serem traduzidas incluir~ao uma chamada para <code>mode_declare</code> no
in&iacute;cio quando poss&iacute;vel com o objetivo de produzir um c&oacute;digo mais eficiente.  Por
exemplo:
</p>
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
</pre>


<p>quando <var>x_1</var>, <var>x_2</var>, ...  s&atilde;o par&acirc;metros para a fun&ccedil;&atilde;o e
<var>v_1</var>, <var>v_2</var>, ...  s&atilde;o vari&aacute;veis locais.
</p>
<p>Os nomes de fun&ccedil;&otilde;es traduzidas
s&atilde;o removidos da lista <code>functions</code> se <code>savedef</code> &eacute; <code>false</code> (veja abaixo)
e s&atilde;o adicionados nas listas <code>props</code>.
</p>
<p>Fun&ccedil;&otilde;es n&atilde;o poder&atilde;o ser traduzidas
a menos que elas sejam totalmente depuradas.
</p>
<p>Express&otilde;es s&atilde;o assumidas simplificadas; se n&atilde;o forem, um c&oacute;digo correto ser&aacute; gerado mas n&atilde;o ser&aacute; um c&oacute;digo
&oacute;timo.  Dessa forma, o usu&aacute;rio n&atilde;o poder&aacute; escolher o comutador <code>simp</code> para <code>false</code>
o qual inibe simplifica&ccedil;&atilde;o de express&otilde;es a serem traduzidas.
</p>
<p>O comutador <code>translate</code>, se <code>true</code>, causa tradu&ccedil;&atilde;o
automatica de uma fun&ccedil;&atilde;o de usu&aacute;rio para Lisp.
</p>
<p>Note que fun&ccedil;&otilde;es
traduzidas podem n&atilde;o executar identicamente para o caminho que elas faziam antes da
tradu&ccedil;&atilde;o como certas incompatabilidades podem existir entre o Lisp
e vers&otilde;es do Maxima.  Principalmente, a fun&ccedil;&atilde;o  <code>rat</code> com mais de
um argumento e a fun&ccedil;&atilde;o <code>ratvars</code> n&atilde;o poder&aacute; ser usada se quaisquer
vari&aacute;veis s&atilde;o declaradas com <code>mode_declare</code> como sendo express&otilde;es rotacionais can&ocirc;nicas(CRE).
Tamb&eacute;m a escolha <code>prederror: false</code>
n&atilde;o traduzir&aacute;.
</p>
<p><code>savedef</code> - se <code>true</code> far&aacute; com que a vers&atilde;o Maxima de uma fun&ccedil;&atilde;o
 usu&aacute;rio permane&ccedil;a quando a fun&ccedil;&atilde;o &eacute; traduzida com <code>translate</code>.  Isso permite a
que defini&ccedil;&atilde;o seja mostrada por <code>dispfun</code> e autoriza a fun&ccedil;&atilde;o a ser
editada.
</p>
<p><code>transrun</code> - se <code>false</code> far&aacute; com que a vers&atilde;o interpretada de todas as
fun&ccedil;&otilde;es sejam executadas (desde que estejam ainda dispon&iacute;veis) em lugar da
vers&atilde;o traduzida.
</p>
<p>O resultado retornado por <code>translate</code> &eacute; uma lista de nomes de
fun&ccedil;&otilde;es traduzidas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>translate_file</b><i> (<var>maxima_nomearquivo</var>)</i>
<a name="IDX1337"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>translate_file</b><i> (<var>maxima_nomearquivo</var>, <var>lisp_nomearquivo</var>)</i>
<a name="IDX1338"></a>
</dt>
<dd><p>Traduz um arquivo com c&oacute;digo Maxima para um arquivo com c&oacute;digo Lisp.
<code>translate_file</code> retorna uma lista de tr&ecirc;s nomes de arquivo:
O nome do arquivo Maxima, o nome do arquivo Lisp, e o nome do arquivo
contendo informa&ccedil;&otilde;es adicionais sobre a tradu&ccedil;&atilde;o.
<code>translate_file</code> avalia seus argumentos.
</p>
<p><code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code> &eacute; o mesmo que
<code>batch (&quot;foo.mac&quot;)</code> exceto por certas restri&ccedil;&otilde;es,
o uso de <code>''</code> e <code>%</code>, por exemplo.
</p>
<p><code>translate_file (<var>maxima_nomearquivo</var>)</code> traduz um arquivo Maxima <var>maxima_nomearquivo</var>
para um similarmente chamado arquivo Lisp.
Por exemplo, <code>foo.mac</code> &eacute; traduzido em <code>foo.LISP</code>.
O nome de arquivo Maxima pod incluir nome ou nomes de diret&oacute;rio(s),
nesse caso o arquivo de sa&iacute;da Lisp &eacute; escrito
para o mesmo diret&oacute;rio que a entrada Maxima.
</p>
<p><code>translate_file (<var>maxima_nomearquivo</var>, <var>lisp_nomearquivo</var>)</code> traduz
um arquivo Maxima <var>maxima_nomearquivo</var> em um arquivo Lisp <var>lisp_nomearquivo</var>.
<code>translate_file</code> ignora a extens&atilde;o do nome do arquivo, se qualquer, de <code>lisp_nomearquivo</code>;
a extens&atilde;o do arquivo de sa&iacute;da Lisp &eacute; sempre <code>LISP</code>.
O nome de arquivo Lisp pode incluir um nome ou nomes de diret&oacute;rios),
nesse caso o arquivo de sa&iacute;da Lisp &eacute; escrito para o diret&oacute;rio especificado.
</p>
<p><code>translate_file</code> tamb&eacute;m escreve um arquivo de mensagens de alerta
do tradutor em v&aacute;rios graus de severidade.
A extens&atilde;o do nome de arquivo desse arquivo &eacute; <code>UNLISP</code>.
Esse arquivo pode conter informa&ccedil;&atilde;o valiosa, apesar de possivelmente obscura,
para rastrear erros no c&oacute;digo traduzido.
O arquivo <code>UNLISP</code> &eacute; sempre escrito
para o mesmo diret&oacute;rio que a entrada Maxima.
</p>
<p><code>translate_file</code> emite c&oacute;digo Lisp o qual faz com que
algumas defini&ccedil;&otilde;es tenham efeito t&atilde;o logo
o c&oacute;digo Lisp &eacute; compilado.
Veja <code>compile_file</code> para mais sobre esse t&oacute;pico.
</p>
<p>Veja tamb&eacute;m <code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>, 
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>, 
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>, 
<code>tr_semicompile</code>,
<code>tr_state_vars</code>, 
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>, 
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>,
e <code>tr_warn_undefined_variable</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>transrun</b>
<a name="IDX1339"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>transrun</code> &eacute; <code>false</code> far&aacute; com que a vers&atilde;o
interpretada de todas as fun&ccedil;&otilde;es sejam executadas (desde que estejam ainda dispon&iacute;veis)
em lugar de vers&atilde;o traduzidas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_array_as_ref</b>
<a name="IDX1340"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Se <code>translate_fast_arrays</code> for <code>false</code>, refer&ecirc;ncias a arrays no
C&oacute;digo Lisp emitidas por <code>translate_file</code> s&atilde;o afetadas por <code>tr_array_as_ref</code>.
Quando <code>tr_array_as_ref</code> &eacute; <code>true</code>,
nomes de arrays s&atilde;o avaliados,
de outra forma nomes de arrays aparecem como s&iacute;mbolos literais no c&oacute;digo traduzido.
</p>
<p><code>tr_array_as_ref</code> n&atilde;o ter&atilde;o efeito se <code>translate_fast_arrays</code> for <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_bound_function_applyp</b>
<a name="IDX1341"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>tr_bound_function_applyp</code> for <code>true</code>, Maxima emite um alerta se uma associa&ccedil;&atilde;o
de vari&aacute;vel (tal como um argumento de fun&ccedil;&atilde;o) &eacute; achada sendo usada como uma fun&ccedil;&atilde;o.
+<code>tr_bound_function_applyp</code> n&atilde;o afeta o c&oacute;digo gerado em tais casos.
</p>
<p>Por exemplo, uma express&atilde;o tal como <code>g (f, x) := f (x+1)</code> ir&aacute; disparar
a mensagem de alerta.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_file_tty_messagesp</b>
<a name="IDX1342"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>tr_file_tty_messagesp</code> &eacute; <code>true</code>,
messagens geradas por <code>translate_file</code> durante a tradu&ccedil;&atilde;o de um arquivo s&atilde;o mostradas
sobre o console e inseridas dentro do arquivo UNLISP.  
Quando <code>false</code>, messagens sobre tradu&ccedil;&otilde;es de
arquivos s&atilde;o somente inseridas dentro do arquivo UNLISP.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_float_can_branch_complex</b>
<a name="IDX1343"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>Diz ao tradutor Maxima-para-Lisp assumir que as fun&ccedil;&otilde;es 
<code>acos</code>, <code>asin</code>, <code>asec</code>, e <code>acsc</code> podem retornar resultados complexos.
</p>
<p>O efeito ostensivo de <code>tr_float_can_branch_complex</code> &eacute; mostrado adiante.
Todavia, parece que esse sinalizador n&atilde;o tem efeito sobre a sa&iacute;da do tradutor.
</p>
<p>Quando isso for <code>true</code> ent&atilde;o <code>acos(x)</code> ser&aacute; do modo <code>any</code>
sempre que <code>x</code> for do modo <code>float</code> (como escolhido por <code>mode_declare</code>).
Quando <code>false</code> ent&atilde;o <code>acos(x)</code> ser&aacute; do modo
<code>float</code> se e somente se <code>x</code> for do modo <code>float</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_function_call_default</b>
<a name="IDX1344"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>general</code>
</p>
<p><code>false</code> significa abandonando e
chamando <code>meval</code>, <code>expr</code> significa que Lisp assume fun&ccedil;&atilde;o de argumento fixado.  <code>general</code>, o
c&oacute;digo padr&atilde;o dado como sendo bom para <code>mexprs</code> e <code>mlexprs</code> mas n&atilde;o <code>macros</code>.
<code>general</code> garante que associa&ccedil;&otilde;es de vari&aacute;vel s&atilde;o corretas em c&oacute;digos compilados.  No
modo <code>general</code>, quando traduzindo F(X), se F for uma vari&aacute;vel associada, ent&atilde;o isso
assumir&aacute; que <code>apply (f, [x])</code> &eacute; significativo, e traduz como tal, com
o alerta apropriado.  N&atilde;o &eacute; necess&aacute;rio desabilitar isso.  Com as
escolhas padr&atilde;o, sem mensagens de alerta implica compatibilidade total do
c&oacute;digo traduzido e compilado com o interpretador Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_numer</b>
<a name="IDX1345"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>tr_numer</code> for <code>true</code> propriedades <code>numer</code> s&atilde;o usadas para
&aacute;tomos que possuem essa propriedade, e.g. <code>%pi</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_optimize_max_loop</b>
<a name="IDX1346"></a>
</dt>
<dd><p>Valor padr&atilde;o: 100
</p>
<p><code>tr_optimize_max_loop</code> &eacute; n&uacute;mero m&aacute;ximo de vezes do
passo de macro-expans&atilde;o e otimiza&ccedil;&atilde;o que o tradutor ir&aacute; executar
considerando uma forma.  Isso &eacute; para capturar erros de expans&atilde;o de macro, e
propriedades de otimiza&ccedil;&atilde;o n&atilde;o terminadas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_semicompile</b>
<a name="IDX1347"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>tr_semicompile</code> for <code>true</code>, as formas de sa&iacute;da de <code>translate_file</code>
e <code>compfile</code> ser&atilde;o macroexpandidas mas n&atilde;o compiladas em c&oacute;digo
de m&aacute;quina pelo compilador Lisp.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de sistema:</u> <b>tr_state_vars</b>
<a name="IDX1348"></a>
</dt>
<dd><p>Valor padr&atilde;o:
</p><pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre>
<p>A lista de comutadores que afetam a forma de sa&iacute;da da
tradu&ccedil;&atilde;o.
Essa informa&ccedil;&atilde;o &eacute; &uacute;til para sistemas populares quando
tentam depurar o tradutor.  Comparando o produto traduzido
para o qual pode ter sido produzido por um dado estado, isso &eacute; poss&iacute;vel para
rastrear erros.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tr_warnings_get</b><i> ()</i>
<a name="IDX1349"></a>
</dt>
<dd><p>Imprime uma lista de alertas que podem ter sido dadas pelo
tradutor durante a tradu&ccedil;&atilde;o corrente.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_warn_bad_function_calls</b>
<a name="IDX1350"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>true</code>
</p>
<p>- Emite um alerta quando
chamadas de fun&ccedil;&atilde;o est&atilde;o sendo feitas por um caminho que pode n&atilde;o ser correto devido
a declara&ccedil;&otilde;es impr&oacute;prias que foram feitas em tempo de tradu&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_warn_fexpr</b>
<a name="IDX1351"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>compfile</code>
</p>
<p>- Emite um alerta se quaisquer FEXPRs forem
encontradas.  FEXPRs n&atilde;o poder&atilde;o normalmente ser sa&iacute;da em c&oacute;digo traduzido,
todas as formas de programa especial leg&iacute;timo s&atilde;o traduzidas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>tr_warn_meval</b>
<a name="IDX1352"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>compfile</code>
</p>
<p>- Emite um alerta se a fun&ccedil;&atilde;o
<code>meval</code> recebe chamadas.  Se <code>meval</code> &eacute; chamada isso indica problemas na
tradu&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>tr_warn_mode</b>
<a name="IDX1353"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>all</code>
</p>
<p>- Emite um alerta quando a vari&aacute;veis forem
atribu&iacute;dos valores inapropriados para seu modo.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_warn_undeclared</b>
<a name="IDX1354"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>compile</code>
</p>
<p>- Determina quando enviar
alertas sobre vari&aacute;veis n&atilde;o declaradas para o TTY.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>tr_warn_undefined_variable</b>
<a name="IDX1355"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>all</code>
</p>
<p>- Emite um alerta quando
vari&aacute;veis globais indefinidas forem vistas.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile_file</b><i> (<var>nomearquivo</var>)</i>
<a name="IDX1356"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile_file</b><i> (<var>nomearquivo</var>, <var>nomearquivo_compilado</var>)</i>
<a name="IDX1357"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>compile_file</b><i> (<var>nomearquivo</var>, <var>nomearquivo_compilado</var>, <var>lisp_nomearquivo</var>)</i>
<a name="IDX1358"></a>
</dt>
<dd><p>Traduz o arquivo Maxima <var>nomearquivo</var> para Lisp,
executa o compilador Lisp,
e, se a tradu&ccedil;&atilde;o e a compila&ccedil;&atilde;o obtiverem sucesso, chama o c&oacute;digo compilado dentro do Maxima.
</p>
<p><code>compile_file</code> retorna uma lista dos nomes de quatro arquivos:
o arquivo original do Maxima, o nome da tradu&ccedil;&atilde;o Lisp, uma arquivo de notas sobre a tradu&ccedil;&atilde;o, e o nome do arquivo que cont&eacute;m o c&oacute;digo compilado.
Se a compila&ccedil;&atilde;o falhar,
o quarto item &eacute; <code>false</code>.
</p>
<p>Algumas declara&ccedil;&otilde;es e defini&ccedil;&otilde;es passam a ter efeito t&atilde;o logo
o c&oacute;digo Lisp seja compilado (sem que seja necess&aacute;rio chamar o c&oacute;digo compilado).
Isso inclui fun&ccedil;&otilde;es definidas com o operador <code>:=</code>,
macros definidas com o operador <code>::=</code>, <code>alias</code>, <code>declare</code>,
<code>define_variable</code>,  <code>mode_declare</code>,
e 
<code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code>,
e <code>compfile</code>.
</p>
<p>Atribui&ccedil;&otilde;es e chamadas de fun&ccedil;&atilde;o n&atilde;o ser&atilde;o avaliadas at&eacute; que o c&oacute;digo compilado seja carregado.
Em particular, dentro do arquivo Maxima,
atribui&ccedil;&otilde;es para sinalizadores traduzidos (<code>tr_numer</code>, etc.) n&atilde;o t&ecirc;m efeito sobre a tradu&ccedil;&atilde;o.
</p>

<p><var>nomearquivo</var> pode n&atilde;o conter declara&ccedil;&otilde;es <code>:lisp</code>.
</p>
<p><code>compile_file</code> avalia seus argumentos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>declare_translated</b><i> (<var>f_1</var>, <var>f_2</var>, ...)</i>
<a name="IDX1359"></a>
</dt>
<dd><p>Quando traduzindo um arquivo do c&oacute;digo Maxima
para Lisp, &eacute; importante para o programa tradutor saber quais fun&ccedil;&otilde;es
no arquivo s&atilde;o para serem chamadas como fun&ccedil;&otilde;es traduzidas ou compiladas,
e quais outras s&atilde;o apenas fun&ccedil;&otilde;es Maxima ou indefinidas.  Colocando essa
declara&ccedil;&atilde;o no topo do arquivo, faremos conhecido que embora um s&iacute;mbolo
diga que n&atilde;o temos ainda um valor de fun&ccedil;&atilde;o Lisp, teremos uma em
tempo de chamada.  <code>(MFUNCTION-CALL fn arg1 arg2 ...)</code> &eacute; gerado quando
o tradutor n~ao sabe que <code>fn</code> est&aacute; sendo compilada para ser uma fun&ccedil;&atilde;o Lisp.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC158" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_40.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
