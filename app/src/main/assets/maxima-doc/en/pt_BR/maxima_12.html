<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 12. Polin&ocirc;mios</title>

<meta name="description" content="Manual do Maxima: 12. Polin&ocirc;mios">
<meta name="keywords" content="Manual do Maxima: 12. Polin&ocirc;mios">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Polin_00f4mios"></a>
<a name="SEC42"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_11.html#SEC41" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC43" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_11.html#SEC40" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC45" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 12. Polin&ocirc;mios </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC43">12.1 Introdu&ccedil;&atilde;o a Polin&ocirc;mios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC44">12.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Polin&ocirc;mios</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Polin_00f4mios"></a>
<a name="SEC43"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC42" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC44" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC42" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC45" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 12.1 Introdu&ccedil;&atilde;o a Polin&ocirc;mios </h2>

<p>Polin&ocirc;mios s&atilde;o armazenados no Maxima ou na forma geral ou na
forma de Express&otilde;es Racionais Can&ocirc;nicas (CRE).  Essa &uacute;ltima &eacute; uma forma
padr&atilde;o, e &eacute; usada internamente por opera&ccedil;&otilde;es tais como <code>factor</code>, <code>ratsimp</code>, e
assim por diante.
</p>
<p>Express&otilde;es Racionais Can&ocirc;nicas constituem um tipo de representa&ccedil;&atilde;o
que &eacute; especialmente adequado para polin&ocirc;mios expandidos e fun&ccedil;&otilde;es
racionais (tamb&eacute;m para polin&ocirc;mios parcialmente fatorados e fun&ccedil;&otilde;es
racionais quando RATFAC for escolhida para <code>true</code>).  Nessa forma CRE uma
ordena&ccedil;&atilde;o de vari&aacute;veis (da mais para a menos importante) &eacute; assumida para cada
express&atilde;o.  Polin&ocirc;mios s&atilde;o representados recursivamente por uma lista
consistindo da vari&aacute;vel principal seguida por uma s&eacute;rie de pares de
express&otilde;es, uma para cada termo do polin&ocirc;mio.  O primeiro membro de
cada par &eacute; o expoente da vari&aacute;vel principal naquele termo e o
segundo membro &eacute; o coeficiente daquele termo que pode ser um n&uacute;mero ou
um polin&ocirc;mio em outra vari&aacute;vel novamente respresentado nessa forma.  Sendo assim
a parte principal da forma CRE de 3*X^2-1 &eacute; (X 2 3 0 -1) e que a parte principal da
forma CRE de 2*X*Y+X-3 &eacute; (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assumindo Y como sendo a
vari&aacute;vel principal, e &eacute; (X 1 (Y 1 2 0 1) 0 -3) assumindo X como sendo a
vari&aacute;vel principal. A vari&aacute;vel principal &eacute; usualmente determineda pela ordem alfab&eacute;tica
reversa.  As &quot;vari&aacute;veis&quot; de uma express&atilde;o CRE n&atilde;o necessariamente devem ser at&ocirc;micas.  De fato
qualquer subexpress&atilde;o cujo principal operador n&atilde;o for + - * / or ^ com expoente
inteiro ser&aacute; considerado uma &quot;vari&aacute;vel&quot; da express&atilde;o (na forma CRE) na
qual essa ocorrer.  Por exemplo as vari&aacute;veis CRE da express&atilde;o
X+SIN(X+1)+2*SQRT(X)+1 s&atilde;o X, SQRT(X), e SIN(X+1).  Se o usu&aacute;rio
n&atilde;o especifica uma ordem de vari&aacute;veis pelo uso da fun&ccedil;&atilde;o RATVARS
Maxima escolher&aacute; a alfab&eacute;tica por conta pr&oacute;pria.  Em geral, CREs representam
express&otilde;es racionais, isto &eacute;, raz&otilde;es de polin&ocirc;mios, onde o
numerador e o denominador n&atilde;o possuem fatores comuns, e o denominador for
positivo.  A forma interna &eacute; essencialmente um par de polin&ocirc;mios (o
numerador e o denominador) precedidos pela lista de ordena&ccedil;&atilde;o de vari&aacute;vel.  Se
uma express&atilde;o a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpress&otilde;es na forma CRE, o s&iacute;mbolo /R/ seguir&aacute; o r&oacute;tulo da linha.
Veja a fun&ccedil;&atilde;o RAT para saber como converter uma express&atilde;o para a forma CRE.  Uma
forma CRE extendida &eacute; usada para a representa&ccedil;&atilde;o de s&eacute;ries de Taylor.  A
no&ccedil;&atilde;o de uma express&atilde;o racional &eacute; extendida de modo que os expoentes das
vari&aacute;veis podem ser n&uacute;meros racionais positivos ou negativos em lugar de apenas
inteiros positivos e os coeficientes podem eles mesmos serem express&otilde;es
racionais como descrito acima em lugar de apenas polin&ocirc;mios.  Estes s&atilde;o
representados internamente por uma forma polinomial recursiva que &eacute; similar
&agrave; forma CRE e &eacute; a generaliza&ccedil;&atilde;o dessa mesma forma CRE, mas carrega informa&ccedil;&atilde;o
adicional tal com o grau de trunca&ccedil;&atilde;o.  Do mesmo modo que na forma CRE, o
s&iacute;mbolo /T/ segue o r&oacute;tulo de linha que cont&eacute;m as tais express&otilde;es.
</p>
<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Polin_00f4mios"></a>
<a name="SEC44"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC43" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC45" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC42" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC45" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 12.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Polin&ocirc;mios </h2>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>algebraic</b>
<a name="IDX387"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p><code>algebraic</code> deve ser escolhida para <code>true</code> com o objetivo de que a
simplifica&ccedil;&atilde;o de inteiros alg&eacute;bricos tenha efeito.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>berlefact</b>
<a name="IDX388"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>berlefact</code> for <code>false</code> ent&atilde;o o algor&iacute;tmo de fatora&ccedil;&atilde;o de
Kronecker ser&aacute; usado.  De outra forma o algor&iacute;tmo de Berlekamp, que &eacute; o
padr&atilde;o, ser&aacute; usado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>bezout</b><i> (<var>p1</var>, <var>p2</var>, <var>x</var>)</i>
<a name="IDX389"></a>
</dt>
<dd><p>uma alternativa para o comando <code>resultant</code>.  Isso
retorna uma matriz.  <code>determinant</code> dessa matriz &eacute; o resultante desejado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>bothcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX390"></a>
</dt>
<dd><p>Retorna uma lista da qual o primeiro membro &eacute; o
coeficiente de <var>x</var> em <var>expr</var> (como achado por <code>ratcoef</code> se <var>expr</var> est&aacute; na forma CRE
de outro modo por <code>coeff</code>) e cujo segundo membro &eacute; a parte restante de
<var>expr</var>.  Isto &eacute;, <code>[A, B]</code> onde <code><var>expr</var> = A*<var>x</var> + B</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        &eacute; (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>coeff</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX391"></a>
</dt>
<dd><p>Retorna o coeficiente de <code><var>x</var>^<var>n</var></code> em <var>expr</var>.  <var>n</var> pode ser
omitido se for 1.  <var>x</var> pode ser um &aacute;tomo, ou subexpress&atilde;o completa de
<var>expr</var> e.g., <code>sin(x)</code>, <code>a[i+1]</code>, <code>x + y</code>, etc. (No &uacute;ltimo caso a
express&atilde;o <code>(x + y)</code> pode ocorrer em <var>expr</var>).  Algumas vezes isso pode ser necess&aacute;rio
para expandir ou fatorar <var>expr</var> com o objetivo de fazer <code><var>x</var>^<var>n</var></code> explicito.  Isso n&atilde;o &eacute;
realizado por <code>coeff</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>combine</b><i> (<var>expr</var>)</i>
<a name="IDX392"></a>
</dt>
<dd><p>Simplifica a adi&ccedil;&atilde;o <var>expr</var> por termos combinados com o mesmo
denominador dentro de um termo simples.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>content</b><i> (<var>p_1</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX393"></a>
</dt>
<dd><p>Retorna uma lista cujo primeiro elemento &eacute;
o m&aacute;ximo divisor comum dos coeficientes dos termos do
polin&ocirc;mio <var>p_1</var> na vari&aacute;vel <var>x_n</var> (isso &eacute; o conte&uacute;do) e cujo
segundo elemento &eacute; o polin&ocirc;mio <var>p_1</var> dividido pelo conte&uacute;do.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>denom</b><i> (<var>expr</var>)</i>
<a name="IDX394"></a>
</dt>
<dd><p>Retorna o denominador da express&atilde;o racional <var>expr</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>divide</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX395"></a>
</dt>
<dd><p>calcula o quocietne e o resto
do polin&ocirc;mio <var>p_1</var> dividido pelo polin&ocirc;mio <var>p_2</var>, na vari&aacute;vel
principal do polin&ocirc;mio, <var>x_n</var>.
As outras vari&aacute;veis s&atilde;o como na fun&ccedil;&atilde;o <code>ratvars</code>.
O resultado &eacute; uma lista cujo primeiro elemento &eacute; o quociente
e cujo segundo elemento &eacute; o resto.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
</pre>

<p>Note que <code>y</code> &eacute; a vari&aacute;vel principal no segundo exemplo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>eliminate</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_k</var>])</i>
<a name="IDX396"></a>
</dt>
<dd><p>Elimina vari&aacute;veis de
equa&ccedil;&otilde;es (ou express&otilde;es assumidas iguais a zero) pegando resultantes
sucessivos. Isso retorna uma lista de <code><var>n</var> - <var>k</var></code> express&otilde;es com <var>k</var>
vari&aacute;veis <var>x_1</var>, ..., <var>x_k</var> eliminadas.  Primeiro <var>x_1</var> &eacute; eliminado retornando <code><var>n</var> - 1</code>
express&otilde;es, ent&atilde;o <code>x_2</code> &eacute; eliminado, etc.  Se <code><var>k</var> = <var>n</var></code> ent&atilde;o uma express&atilde;o simples em uma
lista &eacute; retornada livre das vari&aacute;veis <var>x_1</var>, ..., <var>x_k</var>.  Nesse caso <code>solve</code>
&eacute; chamado para resolver a &uacute;ltima resultante para a &uacute;ltima vari&aacute;vel.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ezgcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>p_3</var>, ...)</i>
<a name="IDX397"></a>
</dt>
<dd><p>Retorna uma lista cujo primeiro elemento &eacute; o m.d.c. dos
polin&ocirc;mios <var>p_1</var>, <var>p_2</var>, <var>p_3</var>, ...  e cujos restantes elementos s&atilde;o os
polin&ocirc;mios divididos pelo mdc.  Isso sempre usa o algor&iacute;tmo
<code>ezgcd</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>facexpand</b>
<a name="IDX398"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>true</code>
</p>
<p><code>facexpand</code> controla se os fatores irredut&iacute;veis
retornados por <code>factor</code> est&atilde;o na forma expandida (o padr&atilde;o) ou na forma recursiva
(CRE normal).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>factcomb</b><i> (<var>expr</var>)</i>
<a name="IDX399"></a>
</dt>
<dd><p>Tenta combinar os coeficientes de fatoriais em <var>expr</var>
com os pr&oacute;prios fatoriais convertendo, por exemplo, <code>(n + 1)*n!</code>
em <code>(n + 1)!</code>.
</p>
<p><code>sumsplitfact</code> se escolhida para <code>false</code> far&aacute; com que <code>minfactorial</code> seja
aplicado ap&oacute;s um <code>factcomb</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>factor</b><i> (<var>expr</var>)</i>
<a name="IDX400"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>factor</b><i> (<var>expr</var>, <var>p</var>)</i>
<a name="IDX401"></a>
</dt>
<dd><p>Fatora a express&atilde;o <var>expr</var>, contendo qualquer n&uacute;mero de
vari&aacute;veis ou fun&ccedil;&otilde;es, em fatores irredut&iacute;veis sobre os inteiros.
<code>factor (<var>expr</var>, <var>p</var>)</code> fatora <var>expr</var> sobre o campo dos inteiros com um elemento
adjunto cujo menor polin&ocirc;mio &eacute; <var>p</var>.
</p>
<p><code>factor</code> usa a fun&ccedil;&atilde;o <code>ifactors</code> para fatorar inteiros.
</p>
<p><code>factorflag</code> se <code>false</code> suprime a fatora&ccedil;&atilde;o de fatores inteiros
de express&otilde;es racionais.
</p>
<p><code>dontfactor</code> pode ser escolhida para uma lista de vari&aacute;veis com rela&ccedil;&atilde;o &agrave; qual
fatora&ccedil;&atilde;o n&atilde;o &eacute; para ocorrer.  (Essa &eacute; inicialmente vazia).  Fatora&ccedil;&atilde;o tamb&eacute;m
n&atilde;o acontece com rela&ccedil;&atilde;o a quaisquer vari&aacute;veis que s&atilde;o menos
importantes (usando a ordena&ccedil;&atilde;o de vari&aacute;vel assumida pela forma CRE) como
essas na lista <code>dontfactor</code>.
</p>
<p><code>savefactors</code> se <code>true</code> faz com que os fatores de uma express&atilde;o que
&eacute; um produto de fatores seja guardada por certas fun&ccedil;&otilde;es com o objetivo de
aumentar a velocidade de futuras fatora&ccedil;&otilde;es de express&otilde;es contendo alguns dos
mesmos fatores.
</p>
<p><code>berlefact</code> se <code>false</code> ent&atilde;o o algor&iacute;tmo de fatora&ccedil;&atilde;o de Kronecker ser&aacute;
usado de outra forma o algor&iacute;tmo de Berlekamp, que &eacute; o padr&atilde;o, ser&aacute;
usado.
</p>
<p><code>intfaclim</code> se <code>true</code> maxima ir&aacute; interromper a fatora&ccedil;&atilde;o de
inteiros se nenhum fator for encontrado ap&oacute;s tentar divis&otilde;es e o m&eacute;todo rho de
Pollard.  Se escolhida para <code>false</code> (esse &eacute; o caso quando o usu&aacute;rio chama
<code>factor</code> explicitamente), a fatora&ccedil;&atilde;o completa do inteiro ser&aacute;
tentada.  A escolha do usu&aacute;rio para <code>intfaclim</code> &eacute; usada para chamadas
internas a <code>factor</code>. Dessa forma, <code>intfaclim</code> pode ser resetada para evitar que o
Maxima gaste um tempo muito longo fatorando inteiros grandes.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>factorflag</b>
<a name="IDX402"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>factorflag</code> for <code>false</code>, suprime a fatora&ccedil;&atilde;o de
fatores inteiros em express&otilde;es racionais.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>factorout</b><i> (<var>expr</var>, <var>x_1</var>, <var>x_2</var>, ...)</i>
<a name="IDX403"></a>
</dt>
<dd><p>Rearranja a adi&ccedil;&atilde;o <var>expr</var> em uma adi&ccedil;&atilde;o de
parcelas da forma <code>f (<var>x_1</var>, <var>x_2</var>, ...)*g</code> onde <code>g</code> &eacute; um produto de
express&otilde;es que n&atilde;o possuem qualquer <var>x_i</var> e <code>f</code> &eacute; fatorado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>factorsum</b><i> (<var>expr</var>)</i>
<a name="IDX404"></a>
</dt>
<dd><p>Tenta agrupar parcelas em fatores de <var>expr</var> que s&atilde;o adi&ccedil;&otilde;es
em grupos de parcelas tais que sua adi&ccedil;&atilde;o &eacute; fator&aacute;vel.  <code>factorsum</code> pode
recuperar o resultado de <code>expand ((x + y)^2 + (z + w)^2)</code> mas n&atilde;o pode recuperar
<code>expand ((x + 1)^2 + (x + y)^2)</code> porque os termos possuem vari&aacute;veis em comum.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fasttimes</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX405"></a>
</dt>
<dd><p>Retorna o produto dos polin&ocirc;mios <var>p_1</var> e <var>p_2</var> usando um
algor&iacute;tmo especial para a multiplica&ccedil;&atilde;o de polin&ocirc;mios.  <code>p_1</code> e <code>p_2</code> podem ser
de v&aacute;rias vari&aacute;veis, densos, e aproximadamente do mesmo tamanho.  A multiplica&ccedil;&atilde;o
cl&aacute;ssica &eacute; de ordem <code>n_1 n_2</code> onde
<code>n_1</code> &eacute; o grau de <code>p_1</code>
and <code>n_2</code> &eacute; o grau de <code>p_2</code>.
<code>fasttimes</code> &eacute; da ordem <code>max (n_1, n_2)^1.585</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fullratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX406"></a>
</dt>
<dd><p><code>fullratsimp</code> aplica
repetidamente <code>ratsimp</code> seguido por simplifica&ccedil;&atilde;o n&atilde;o racional a uma
express&atilde;o at&eacute; que nenhuma mudan&ccedil;a adicional ocorra,
e retorna o resultado.
</p>
<p>Quando express&otilde;es n&atilde;o racionais est&atilde;o envolvidas, uma chamada
a <code>ratsimp</code> seguida como &eacute; usual por uma simplifica&ccedil;&atilde;o n&atilde;o racional
(&quot;geral&quot;) pode n&atilde;o ser suficiente para retornar um resultado simplificado.
Algumas vezes, mais que uma tal chamada pode ser necess&aacute;ria. 
<code>fullratsimp</code> faz esse processo convenientemente.
</p>
<p><code>fullratsimp (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code> pega um ou mais argumentos similar
a <code>ratsimp</code> e <code>rat</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fullratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX407"></a>
</dt>
<dd><p>&eacute; o mesmo que <code>ratsubst</code> exceto que essa chama
a si mesma recursivamente sobre esse resultado at&eacute; que o resultado para de mudar.
Essa fun&ccedil;&atilde;o &eacute; &uacute;til quando a express&atilde;o de substitui&ccedil;&atilde;o e a
express&atilde;o substitu&iacute;da tenham uma ou mais vari&aacute;veis em comum.
</p>
<p><code>fullratsubst</code> ir&aacute; tamb&eacute;m aceitar seus argumentos no formato de
<code>lratsubst</code>.  Isto &eacute;, o primeiro argumento pode ser uma substitui&ccedil;&atilde;o simples
de equa&ccedil;&atilde;o ou uma lista de tais equa&ccedil;&otilde;es, enquanto o segundo argumento &eacute; a
express&atilde;o sendo processada.
</p>
<p><code>load (&quot;lrats&quot;)</code> chama <code>fullratsubst</code> e <code>lratsubst</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> pode realizar multiplas substitui&ccedil;&otilde;es.
<code>lratsubst</code> &eacute; analogo a <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
Se somente uma substitui&ccedil;&atilde;o &eacute; desejada, ent&atilde;o uma equa&ccedil;&atilde;o
simples pode ser dada como primeiro argumento.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre><ul>
<li>
<code>fullratsubst</code> &eacute; equivalente a <code>ratsubst</code>
exceto que essa executa recursivamente at&eacute; que seu resultado para de mudar.
</li></ul>
<pre class="example">(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> tamb&eacute;m aceita uma lista de equa&ccedil;&otilde;es ou uma equa&ccedil;&atilde;o
simples como primeiro argumento.
</li></ul>
<pre class="example">(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
</pre><ul>
<li>
<code>fullratsubst</code> pode causar uma recurs&atilde;o infinita.
</li></ul>
<pre class="example">(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gcd</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ...)</i>
<a name="IDX408"></a>
</dt>
<dd><p>Retorna o m&aacute;ximo divisor comum entre <var>p_1</var> e <var>p_2</var>.
O sinalizador <code>gcd</code> determina qual algor&iacute;tmo &eacute; empregado.
Escolhendo <code>gcd</code> para <code>ez</code>, <code>subres</code>, <code>red</code>, ou <code>spmod</code> seleciona o algor&iacute;tmo <code>ezgcd</code>,
subresultante <code>prs</code>, reduzido, ou modular,
respectivamente.  Se <code>gcd</code> for <code>false</code> ent&atilde;o <code>gcd (<var>p_1</var>, <var>p_2</var>, <var>x</var>)</code> sempre retorna 1
para todo <var>x</var>.  Muitas fun&ccedil;&otilde;es (e.g.  <code>ratsimp</code>, <code>factor</code>, etc.) fazem com que mdc's
sejam feitos implicitamente.  Para polin&ocirc;mios homog&ecirc;neos &eacute; recomendado
que <code>gcd</code> igual a <code>subres</code> seja usado.  Para pegar o mdc quando uma express&atilde;o alg&eacute;brica est&aacute;
presente, e.g. <code>gcd (<var>x</var>^2 - 2*sqrt(2)*<var>x</var> + 2, <var>x</var> - sqrt(2))</code>, <code>algebraic</code> deve ser
<code>true</code> e <code>gcd</code> n&atilde;o deve ser <code>ez</code>.  <code>subres</code> &eacute; um novo algor&iacute;tmo, e pessoas
que tenham estado usando a op&ccedil;&atilde;o <code>red</code> podem provavelmente alterar isso para
<code>subres</code>.
</p>
<p>O sinalizador <code>gcd</code>, padr&atilde;o: <code>subres</code>, se <code>false</code> ir&aacute; tamb&eacute;m evitar o m&aacute;ximo
divisor comum de ser usado quando express&otilde;es s&atilde;o convertidas para a forma de express&atilde;o racional
can&ocirc;nica (CRE).  Isso ir&aacute; algumas vezes aumentar a velocidade dos c&aacute;lculos se mdc's n&atilde;o s&atilde;o
requeridos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>)</i>
<a name="IDX409"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gcdex</b><i> (<var>f</var>, <var>g</var>, <var>x</var>)</i>
<a name="IDX410"></a>
</dt>
<dd><p>Retornam uma lista <code>[<var>a</var>, <var>b</var>, <var>u</var>]</code>
onde <var>u</var> &eacute; o m&aacute;ximo divisor comum (mdc) entre <var>f</var> e <var>g</var>,
e <var>u</var> &eacute; igual a <code><var>a</var> <var>f</var> + <var>b</var> <var>g</var></code>.
Os argumentos <var>f</var> e <var>g</var> podem ser polin&ocirc;mios de uma vari&aacute;vel,
ou de outra forma polin&ocirc;mios em <var>x</var> uma <b>main</b>(principal) vari&aacute;vel suprida
desde que n&oacute;s precisamos estar em um dom&iacute;nio de ideal principal para isso trabalhar.
O mdc significa o mdc considerando <var>f</var> e <var>g</var> como polin&ocirc;mios de uma &uacute;nica vari&aacute;vel com coeficientes
sendo fun&ccedil;&otilde;es racionais em outras vari&aacute;veis.
</p>
<p><code>gcdex</code> implementa o algor&iacute;tmo Euclideano,
onde temos a seq&uuml;&ecirc;ncia
of <code>L[i]: [a[i], b[i], r[i]]</code> que s&atilde;o todos perpendiculares
a <code>[f, g, -1]</code> e o pr&oacute;ximo se &eacute; constru&iacute;do como
se <code>q = quotient(r[i]/r[i+1])</code> ent&atilde;o <code>L[i+2]: L[i] - q L[i+1]</code>, e isso
encerra em <code>L[i+1]</code> quando o resto <code>r[i+2]</code> for zero.
</p>

<pre class="example">(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
</pre>
<p>Note que o mdc adiante &eacute; <code>1</code>
uma vez que trabalhamos em <code>k(y)[x]</code>, o <code>y+1</code> n&atilde;o pode ser esperado em <code>k[y, x]</code>.
</p>

<pre class="example">(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
</pre>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gcfactor</b><i> (<var>n</var>)</i>
<a name="IDX411"></a>
</dt>
<dd><p>Fatora o inteiro Gaussiano <var>n</var> sobre os inteiros Gaussianos, i.e.,
n&uacute;meros da forma <code><var>a</var> + <var>b</var> <code>%i</code></code> onde <var>a</var> e <var>b</var> s&atilde;o inteiros raconais
(i.e.,  inteiros comuns).  Fatora&ccedil;&otilde;es s&atilde;o normalizadas fazendo <var>a</var> e <var>b</var>
n&atilde;o negativos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gfactor</b><i> (<var>expr</var>)</i>
<a name="IDX412"></a>
</dt>
<dd><p>Fatora o polin&ocirc;mio <var>expr</var> sobre os inteiros de Gauss
(isto &eacute;, os inteiros com a unidade imagin&aacute;ria <code>%i</code> adjunta).
Isso &eacute; como <code>factor (<var>expr</var>, <var>a</var>^2+1)</code> trocando <var>a</var> por <code>%i</code>.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>gfactorsum</b><i> (<var>expr</var>)</i>
<a name="IDX413"></a>
</dt>
<dd><p>&eacute; similar a <code>factorsum</code> mas aplica <code>gfactor</code> em lugar
de <code>factor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>hipow</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX414"></a>
</dt>
<dd><p>Retorna o maior expoente expl&iacute;cito de <var>x</var> em <var>expr</var>.
<var>x</var> pode ser uma vari&aacute;vel ou uma express&atilde;o geral.
Se <var>x</var> n&atilde;o aparece em <var>expr</var>,
<code>hipow</code> retorna <code>0</code>.
</p>
<p><code>hipow</code> n&atilde;o considera express&otilde;es equivalentes a <code>expr</code>.
Em particular, <code>hipow</code> n&atilde;o expande <code>expr</code>,
ent&atilde;o <code>hipow (<var>expr</var>, <var>x</var>)</code> e <code>hipow (expand (<var>expr</var>, <var>x</var>))</code>
podem retornar diferentes resultados.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>intfaclim</b>
<a name="IDX415"></a>
</dt>
<dd><p>Valor padr&atilde;o: true
</p>
<p>Se <code>true</code>, maxima ir&aacute; interromper a fatora&ccedil;&atilde;o de
inteiros se nenhum fator for encontrado ap&oacute;s tentar divis&otilde;es e o m&eacute;todo rho de
Pollard e a fatora&ccedil;&atilde;o n&atilde;o ser&aacute; completada.
</p>
<p>Quando <code>intfaclim</code> for <code>false</code> (esse &eacute; o caso quando o usu&aacute;rio
chama <code>factor</code> explicitamente), a fatora&ccedil;&atilde;o completa ser&aacute;
tentada.  <code>intfaclim</code> &eacute; escolhida para <code>false</code> quando fatores s&atilde;o
calculados em <code>divisors</code>, <code>divsum</code> e <code>totient</code>.
</p>
<p>Chamadas internas a <code>factor</code> respeitam o valor especificado pelo usu&aacute;rio para
<code>intfaclim</code>. Setting <code>intfaclim</code> to <code>true</code> may reduce
<code>intfaclim</code>. Escolhendo <code>intfaclim</code> para <code>true</code> podemos reduzir
o tempo gasto fatorando grandes inteiros.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>keepfloat</b>
<a name="IDX416"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>keepfloat</code> for <code>true</code>, evitamos que n&uacute;meros
em ponto flutuante sejam racionalizados quando express&otilde;es que os possuem
s&atilde;o ent&atilde;o convertidas para a forma de express&atilde;o racional can&ocirc;nica (CRE).
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lratsubst</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX417"></a>
</dt>
<dd><p>&eacute; an&aacute;logo a <code>subst (<var>L</var>, <var>expr</var>)</code>
exceto que esse usa <code>ratsubst</code> em lugar de <code>subst</code>.
</p>
<p>O primeiro argumento de
<code>lratsubst</code> &eacute; uma equa&ccedil;&atilde;o ou uma lista de equa&ccedil;&otilde;es id&ecirc;nticas em
formato para que sejam aceitas por <code>subst</code>.  As
substitui&ccedil;&otilde;es s&atilde;o feitas na ordem dada pela lista de equa&ccedil;&otilde;es,
isto &eacute;, da esquerda para a direita.
</p>
<p><code>load (&quot;lrats&quot;)</code> chama <code>fullratsubst</code> e <code>lratsubst</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) load (&quot;lrats&quot;)$
</pre><ul>
<li>
<code>subst</code> pode realizar multiplas substitui&ccedil;&otilde;es.
<code>lratsubst</code> &eacute; analoga a <code>subst</code>.
</li></ul>
<pre class="example">(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
</pre><ul>
<li>
Se somente uma substitui&ccedil;&atilde;o for desejada, ent&atilde;o uma equa&ccedil;&atilde;o
simples pode ser dada como primeiro argumento.
</li></ul>
<pre class="example">(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>modulus</b>
<a name="IDX418"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>modulus</code> for um n&uacute;mero positivo <var>p</var>,
opera&ccedil;&otilde;es sobre os n&uacute;meros racionais (como retornado por <code>rat</code> e fun&ccedil;&otilde;es relacionadas)
s&atilde;o realizadas m&oacute;dulo <var>p</var>,
usando o ent&atilde;o chamado sistema de m&oacute;dulo &quot;balanceado&quot;
no qual <code><var>n</var> m&oacute;dulo <var>p</var></code> &eacute; definido como 
um inteiro <var>k</var> em <code>[-(<var>p</var>-1)/2, ..., 0, ..., (<var>p</var>-1)/2]</code>
quando <var>p</var> for &iacute;mpar, ou <code>[-(<var>p</var>/2 - 1), ..., 0, ...., <var>p</var>/2]</code> quando <var>p</var> for par,
tal que <code><var>a</var> <var>p</var> + <var>k</var></code> seja igual a <var>n</var> para algum inteiro <var>a</var>.
</p>
<p>Se <var>expr</var> j&aacute; estiver na forma de express&atilde;o racional can&ocirc;nica (CRE) quando <code>modulus</code> for colocado em seu valor original,
ent&atilde;o voc&ecirc; pode precisar repetir o rat <var>expr</var>, e.g., <code>expr: rat (ratdisrep (expr))</code>,
com o objetivo de pegar resultados corretos.
</p>
<p>Tipicamente <code>modulus</code> &eacute; escolhido para um n&uacute;mero primo.
Se <code>modulus</code> for escolhido para um inteiro n&atilde;o primo positivo,
essa escolha &eacute; aceita, mas uma mensagem de alerta &eacute; mostrada.
Maxima permitir&aacute; que zero ou um inteiro negativo seja atribu&iacute;do a <code>modulus</code>,
embora isso n&atilde;o seja limpo se aquele tiver quaisquer conseq&uuml;&ecirc;ncias &uacute;teis.
</p>
</dd></dl>


<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>num</b><i> (<var>expr</var>)</i>
<a name="IDX419"></a>
</dt>
<dd><p>Retorna o numerador de <var>expr</var> se isso for uma raz&atilde;o.
Se <var>expr</var> n&atilde;o for uma raz&atilde;o, <var>expr</var> &eacute; retornado.
</p>
<p><code>num</code> avalia seu argumento.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>polydecomp</b><i> (<var>p</var>, <var>x</var>)</i>
<a name="IDX420"></a>
</dt>
<dd><p>Decomp&otilde;es o polin&ocirc;mio <var>p</var> na vari&aacute;vel  <var>x</var>
em uma composi&ccedil;&atilde;o funcional de polin&ocirc;mios em <var>x</var>.
<code>polydecomp</code> retorna uma lista <code>[<var>p_1</var>, ..., <var>p_n</var>]</code> tal que
</p>
<pre class="example">lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))
</pre>
<p>seja igual a <var>p</var>.
O grau de <var>p_i</var> &eacute; maior que 1 para <var>i</var> menor que <var>n</var>.
</p>
<p>Tal decomposi&ccedil;&atilde;o n&atilde;o &eacute; &uacute;nica.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>As seguintes fun&ccedil;&otilde;es comp&otilde;em <code>L = [e_1, ..., e_n]</code> como fun&ccedil;&otilde;es em <code>x</code>;
essa fun&ccedil;&agrave;o &eacute; a inversa de <code>polydecomp</code>:
</p>
<pre class="example">compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
</pre>
<p>Re-exprimindo o exemplo acima usando <code>compose</code>:
</p>
<pre class="example">(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
</pre>
<p>Note que apesar de <code>compose (polydecomp (<var>p</var>, <var>x</var>), <var>x</var>)</code>
sempre retornar <var>p</var> (n&atilde;o expandido),
<code>polydecomp (compose ([<var>p_1</var>, ..., <var>p_n</var>], <var>x</var>), <var>x</var>)</code> <i>n&atilde;o</i>
necess&aacute;riamente retorna <code>[<var>p_1</var>, ..., <var>p_n</var>]</code>:
</p>
<pre class="example">(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX421"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>quotient</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX422"></a>
</dt>
<dd><p>Retorna o polin&ocirc;mio <var>p_1</var> dividido pelo polin&ocirc;mio <var>p_2</var>.
Os argumentos <var>x_1</var>, ..., <var>x_n</var> s&atilde;o interpretados como em <code>ratvars</code>.
</p>
<p><code>quotient</code> retorna o primeiro elemento de uma lista de dois elementos retornada por <code>divide</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rat</b><i> (<var>expr</var>)</i>
<a name="IDX423"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>rat</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX424"></a>
</dt>
<dd><p>Converte <var>expr</var> para a forma de express&atilde;o racional can&ocirc;nica (CRE) expandindo e
combinando todos os termos sobre um denominador comum e cancelando para fora o
m&aacute;ximo divisor comum entre o numerador e o denominador, tamb&eacute;m
convertendo n&uacute;meros em ponto flutuante para n&uacute;meros racionais dentro da
toler&acirc;ncia de <code>ratepsilon</code>.
As vari&aacute;veis s&atilde;o ordenadas de acordo com
<var>x_1</var>, ..., <var>x_n</var>, se especificado, como em <code>ratvars</code>.
</p>
<p><code>rat</code> geralmente n&atilde;o simplifica fun&ccedil;&otilde;es outras que n&atilde;o sejam
adi&ccedil;&atilde;o <code>+</code>, subtra&ccedil;&atilde;o <code>-</code>, multiplica&ccedil;&atilde;o <code>*</code>, divis&atilde;o <code>/</code>, e
exponencia&ccedil;&atilde;o com expoente inteiro,
uma vez que <code>ratsimp</code> n&atilde;o manuseia esses casos.
Note que &aacute;tomos (n&uacute;meros e vari&aacute;veis) na forma CRE n&atilde;o s&atilde;o os
mesmos que eles s&atilde;o na forma geral.
Por exemplo, <code>rat(x)- x</code> retorna 
<code>rat(0)</code> que tem uma representa&ccedil;&atilde;o interna diferente de 0.
</p>
<p>Quando <code>ratfac</code> for <code>true</code>, <code>rat</code> retorna uma forma parcialmente fatorada para CRE.
Durante opera&ccedil;&otilde;es racionais a express&atilde;o &eacute;
mantida como totalmente fatorada como poss&iacute;vel sem uma chamada ao
pacote de fatora&ccedil;&atilde;o (<code>factor</code>).  Isso pode sempre economizar espa&ccedil;o de mem&oacute;ria e algum tempo
em algumas computa&ccedil;&otilde;es.  O numerador e o denominador s&atilde;o ainda tidos como
relativamente primos
(e.g.  <code>rat ((x^2 - 1)^4/(x + 1)^2)</code> retorna <code>(x - 1)^4 (x + 1)^2)</code>,
mas os fatores dentro de cada parte podem n&atilde;o ser relativamente primos.
</p>
<p><code>ratprint</code> se <code>false</code> suprime a impress&atilde;o de mensagens
informando o usu&aacute;rio de convers&otilde;es de n&uacute;meros em ponto flutuante para
n&uacute;meros racionais.
</p>
<p><code>keepfloat</code> se <code>true</code> evita que n&uacute;meros em ponto flutuante sejam
convertidos para n&uacute;meros racionais.
</p>
<p>Veja tamb&eacute;m <code>ratexpand</code> e  <code>ratsimp</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratalgdenom</b>
<a name="IDX425"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>ratalgdenom</code> for <code>true</code>, permite racionaliza&ccedil;&atilde;o de
denominadores com respeito a radicais tenham efeito.
<code>ratalgdenom</code> tem efeito somente quando express&otilde;es racionais can&ocirc;nicas (CRE) forem usadas no modo alg&eacute;brico.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>, <var>n</var>)</i>
<a name="IDX426"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratcoef</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX427"></a>
</dt>
<dd><p>Retorna o coeficiente da express&atilde;o <code><var>x</var>^<var>n</var></code>
dentro da express&atilde;o <var>expr</var>.
Se omitido, <var>n</var> &eacute; assumido ser 1.
</p>
<p>O valor de retorno est&aacute; livre
(exceto possivelmente em um senso n&atilde;o racional) das vari&aacute;veis em <var>x</var>.
Se nenhum coeficiente desse tipo existe, 0 &eacute; retornado.
</p>
<p><code>ratcoef</code>
expande e simplifica racionalmente seu primeiro argumento e dessa forma pode
produzir respostas diferentes das de <code>coeff</code> que &eacute; puramente
sint&aacute;tica.
Dessa forma <code>ratcoef ((x + 1)/y + x, x)</code> retorna <code>(y + 1)/y</code> ao passo que <code>coeff</code> retorna 1.
</p>
<p><code>ratcoef (<var>expr</var>, <var>x</var>, 0)</code>, visualiza <var>expr</var> como uma adi&ccedil;&atilde;o,
retornando uma soma desses termos que n&atilde;o possuem <var>x</var>.
portanto se <var>x</var> ocorre para quaisquer expoentes negativos, <code>ratcoef</code> pode n&atilde;o ser usado.
</p>
<p>Uma vez que <var>expr</var> &eacute; racionalmente
simplificada antes de ser examinada, coeficientes podem n&atilde;o aparecer inteiramente
no caminho que eles foram pensados.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratdenom</b><i> (<var>expr</var>)</i>
<a name="IDX428"></a>
</dt>
<dd><p>Retorna o denominador de <var>expr</var>,
ap&oacute;s for&ccedil;ar a convers&atilde;o de <var>expr</var> para express&atilde;o racional can&ocirc;nica (CRE).
O valor de retorno &eacute; a CRE.
</p>
<p><var>expr</var> &eacute; for&ccedil;ada para uma CRE por <code>rat</code>
se n&atilde;o for j&aacute; uma CRE.
Essa convers&atilde;o pode mudar a forma de <var>expr</var> colocando todos os termos
sobre um denominador comum.
</p>
<p><code>denom</code> &eacute; similar, mas retorna uma express&atilde;o comum em lugar de uma CRE.
Tamb&eacute;m, <code>denom</code> n&atilde;o tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express&otilde;es que s&atilde;o consideradas raz&otilde;es por <code>ratdenom</code>
n&atilde;o s&atilde;o consideradas raz&otilde;es por <code>denom</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratdenomdivide</b>
<a name="IDX429"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>ratdenomdivide</code> for <code>true</code>,
<code>ratexpand</code> expande uma raz&atilde;o cujo o numerador for uma adi&ccedil;&atilde;o 
dentro de uma soma de raz&otilde;es,
tendo todos um denominador comum.
De outra forma, <code>ratexpand</code> colapsa uma adi&ccedil;&atilde;o de raz&otilde;es dentro de uma raz&atilde;o simples,
cujo numerador seja a adi&ccedil;&atilde;o dos numeradores de cada raz&atilde;o.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratdiff</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX430"></a>
</dt>
<dd><p>Realiza a deriva&ccedil;&atilde;o da express&atilde;o racional <var>expr</var> com rela&ccedil;&atilde;o a <var>x</var>.
<var>expr</var> deve ser uma raz&atilde;o de polin&ocirc;mios ou um polin&ocirc;mio em <var>x</var>.
O argumento <var>x</var> pode ser uma vari&aacute;vel ou uma subexpress&atilde;o de <var>expr</var>.
</p>
<p>O resultado &eacute; equivalente a <code>diff</code>, embora talvez em uma forma diferente.
<code>ratdiff</code> pode ser mais r&aacute;pida que <code>diff</code>, para express&otilde;es racionais.
</p>
<p><code>ratdiff</code> retorna uma express&atilde;o racional can&ocirc;nica (CRE) se <code>expr</code> for uma CRE.
De outra forma, <code>ratdiff</code> retorna uma express&atilde;o geral.
</p>
<p><code>ratdiff</code> considera somente as depend&ecirc;ncias de <var>expr</var> sobre <var>x</var>,
e ignora quaisquer depend&ecirc;ncias estabelecidas por <code>depends</code>.
</p>

<p>Exemplo:
</p>
<pre class="example">(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratdisrep</b><i> (<var>expr</var>)</i>
<a name="IDX431"></a>
</dt>
<dd><p>Retorna seu argumento como uma express&atilde;o geral.
Se <var>expr</var> for uma express&atilde;o geral, &eacute; retornada inalterada.
</p>
<p>Tipicamente <code>ratdisrep</code> &eacute; chamada para converter uma express&atilde;o racional can&ocirc;nica (CRE)
em uma express&atilde;o geral.
Isso &eacute; algumas vezes conveniente se deseja-se parar o &quot;cont&aacute;gio&quot;, ou
caso se esteja usando fun&ccedil;&otilde;es racionais em contextos n&atilde;o racionais.
</p>
<p>Veja tamb&eacute;m <code>totaldisrep</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratepsilon</b>
<a name="IDX432"></a>
</dt>
<dd><p>Valor Padr&atilde;o: 2.0e-8
</p>
<p><code>ratepsilon</code> &eacute; a toler&acirc;ncia usada em convers&otilde;es
de n&uacute;meros em ponto flutuante para n&uacute;meros racionais.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratexpand</b><i> (<var>expr</var>)</i>
<a name="IDX433"></a>
</dt>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratexpand</b>
<a name="IDX434"></a>
</dt>
<dd><p>Expande <var>expr</var> multiplicando para fora produtos de somas e
somas exponenciadas, combinando fra&ccedil;&otilde;es sobre um denominador comum,
cancelando o m&aacute;ximo divisor comum entre entre o numerador e o
denominador, ent&atilde;o quebrando o numerador (se for uma soma) dentro de suas
respectivas parcelas divididas pelo denominador.
</p>
<p>O valor de retorno de <code>ratexpand</code> &eacute; uma express&atilde;o geral,
mesmo se <var>expr</var> for uma express&atilde;o racional can&ocirc;nica (CRE).
</p>
<p>O comutador <code>ratexpand</code> se <code>true</code> far&aacute; com que express&otilde;es
CRE sejam completamente expandidas quando forem convertidas de volta para
a forma geral ou mostradas, enquanto se for <code>false</code> ent&atilde;o elas ser&atilde;o colocadas
na forma recursiva.
Veja tamb&eacute;m <code>ratsimp</code>.
</p>
<p>Quando <code>ratdenomdivide</code> for <code>true</code>,
<code>ratexpand</code> expande uma raz&atilde;o na qual o numerador &eacute; uma adi&ccedil;&atilde;o
dentro de uma adi&ccedil;&atilde;o de raz&otilde;es,
todas tendo um denominador comum.
De outra forma, <code>ratexpand</code> contrai uma soma de raz&otilde;es em uma raz&atilde;o simples,
cujo numerador &eacute; a soma dos numeradores de cada raz&atilde;o.
</p>
<p>Quando <code>keepfloat</code> for <code>true</code>, evita que n&uacute;meros
em ponto flutuante sejam racionalizados quando express&otilde;es que contenham
n&uacute;meros em ponto flutuante forem convertidas para a forma de express&atilde;o racional can&ocirc;nica (CRE).
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratfac</b>
<a name="IDX435"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>ratfac</code> for <code>true</code>,
express&otilde;es racionais can&ocirc;nicas (CRE) s&atilde;o manipuladas na forma parcialmente fatorada.
</p>
<p>Durante opera&ccedil;&otilde;es racionais a
express&atilde;o &eacute; mantida como completamente fatorada como foi poss&iacute;vel sem chamadas a <code>factor</code>.
Isso pode sempre economizar espa&ccedil;o e pode economizar tempo em algumas computa&ccedil;&otilde;es.
O numerador e o denominador s&atilde;o feitos relativamente primos, por exemplo
<code>rat ((x^2 - 1)^4/(x + 1)^2)</code> retorna <code>(x - 1)^4 (x + 1)^2)</code>,
mas o fator dentro de cada parte pode n&atilde;o ser relativamente primo.
</p>
<p>No pacote <code>ctensor</code> (Manipula&ccedil;&atilde;o de componentes de tensores),
tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura escalar 
s&atilde;o fatorados automaticamente quando <code>ratfac</code> for <code>true</code>.
<i><code>ratfac</code> pode somente ser
escolhido para casos onde as componentes tensoriais sejam sabidametne consistidas de
poucos termos.</i>
</p>
<p>Os esquemas de <code>ratfac</code> e de <code>ratweight</code> s&atilde;o incompat&iacute;veis e n&atilde;o podem
ambos serem usados ao mesmo tempo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratnumer</b><i> (<var>expr</var>)</i>
<a name="IDX436"></a>
</dt>
<dd><p>Retorna o numerador de <var>expr</var>,
ap&oacute;s for&ccedil;ar <var>expr</var> para uma express&atilde;o racional can&ocirc;nica (CRE).
O valor de retorno &eacute; uma CRE.
</p>
<p><var>expr</var> &eacute; for&ccedil;ada para uma CRE por <code>rat</code>
se isso n&atilde;o for j&aacute; uma CRE.
Essa convers&atilde;o pode alterar a forma de <var>expr</var> pela coloca&ccedil;&atilde;o de todos os termos
sobre um denominador comum.
</p>
<p><code>num</code> &eacute; similar, mas retorna uma express&atilde;o comum em lugar de uma CRE.
Tamb&eacute;m, <code>num</code> n&atilde;o tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express&otilde;es que s&atilde;o consideradas raz&otilde;es por <code>ratnumer</code>
n&atilde;o s&atilde;o consideradas raz&otilde;es por <code>num</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratnump</b><i> (<var>expr</var>)</i>
<a name="IDX437"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> for um inteiro literal ou raz&atilde;o de inteiros literais,
de outra forma retorna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratp</b><i> (<var>expr</var>)</i>
<a name="IDX438"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>expr</var> for uma express&atilde;o racional can&ocirc;nica (CRE) ou CRE extendida,
de outra forma retorna <code>false</code>.
</p>
<p>CRE s&atilde;o criadas por <code>rat</code> e fun&ccedil;&otilde;es relacionadas.
CRE extendidas s&atilde;o criadas por <code>taylor</code> e fun&ccedil;&otilde;es relacionadas.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratprint</b>
<a name="IDX439"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>true</code>
</p>
<p>Quando <code>ratprint</code> for <code>true</code>,
uma mensagem informando ao usu&aacute;rio da convers&atilde;o de n&uacute;meros em ponto flutuante
para n&uacute;meros racionais &eacute; mostrada.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratsimp</b><i> (<var>expr</var>)</i>
<a name="IDX440"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratsimp</b><i> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX441"></a>
</dt>
<dd><p>Simplifica a express&atilde;o <var>expr</var> e todas as suas subexpress&otilde;es,
incluindo os argumentos para fun&ccedil;&otilde;es n&atilde;o racionais.
O resultado &eacute; retornado como o quociente de dois polin&ocirc;mios na forma recursiva,
isto &eacute;, os coeficientes de vari&aacute;vel principal s&atilde;o polin&ocirc;mios em outras vari&aacute;veis.
Vari&aacute;veis podem incluir fun&ccedil;&otilde;es n&atilde;o racionais (e.g., <code>sin (x^2 + 1)</code>)
e os argumentos para quaisquer tais fun&ccedil;&otilde;es s&atilde;o tamb&eacute;m simplificados racionalmente.
</p>
<p><code>ratsimp (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>
habilita simplifica&ccedil;&atilde;o racional com a
especiica&ccedil;&atilde;o de vari&aacute;vel ordenando como em <code>ratvars</code>.
</p>
<p>Quando <code>ratsimpexpons</code> for <code>true</code>,
<code>ratsimp</code> &eacute; aplicado para os expoentes de express&otilde;es durante a simplifica&ccedil;&atilde;o.
</p>
<p>Veja tamb&eacute;m <code>ratexpand</code>.
Note que <code>ratsimp</code> &eacute; afetado por algum dos
sinalizadores que afetam <code>ratexpand</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratsimpexpons</b>
<a name="IDX442"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>ratsimpexpons</code> for <code>true</code>,
<code>ratsimp</code> &eacute; aplicado para os expoentes de express&otilde;es durante uma simplifica&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratsubst</b><i> (<var>a</var>, <var>b</var>, <var>c</var>)</i>
<a name="IDX443"></a>
</dt>
<dd><p>Substitue <var>a</var> por <var>b</var> em <var>c</var> e retorna a express&atilde;o resultante. 
<var>b</var> pode tamb&eacute;m ser uma adi&ccedil;&atilde;o, produto, expoente, etc.
</p>
<p><code>ratsubst</code> sabe alguma coisa do significado de express&otilde;es
uma vez que <code>subst</code> n&atilde;o &eacute; uma substitui&ccedil;&atilde;o puramente sint&aacute;tica.
Dessa forma <code>subst (a, x + y, x + y + z)</code> retorna <code>x + y + z</code>
ao passo que <code>ratsubst</code> retorna <code>z + a</code>.
</p>
<p>Quando <code>radsubstflag</code> for <code>true</code>,
<code>ratsubst</code> faz substitui&ccedil;&atilde;o de radicais em express&otilde;es
que explicitamente n&atilde;o possuem esses radicais.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratvars</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX444"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratvars</b><i> ()</i>
<a name="IDX445"></a>
</dt>
<dt><u>Vari&aacute;vel de sistema:</u> <b>ratvars</b>
<a name="IDX446"></a>
</dt>
<dd><p>Declara vari&aacute;veis principais <var>x_1</var>, ..., <var>x_n</var> para express&otilde;es racionais.
<var>x_n</var>, se presente em uma express&atilde;o racional, &eacute; considerada a vari&aacute;vel principal.
De outra forma, <var>x_[n-1]</var> &eacute; considerada a vari&aacute;vel principal se presente,
e assim por diante at&eacute; as vari&aacute;veis precedentes para <var>x_1</var>,
que &eacute; considerada a vari&aacute;vel principal somente se nenhuma das vari&aacute;veis que a sucedem estiver presente.
</p>
<p>Se uma vari&aacute;vel em uma express&atilde;o racional n&atilde;o est&aacute; presente na lista <code>ratvars</code>,
a ela &eacute; dada uma prioridade menor que <var>x_1</var>.
</p>
<p>Os argumentos para <code>ratvars</code> podem ser ou vari&aacute;veis ou fun&ccedil;&otilde;es n&atilde;o racionais
tais como <code>sin(x)</code>.
</p>
<p>A vari&aacute;vel <code>ratvars</code> &eacute; uma lista de argumentos da
fun&ccedil;&atilde;o <code>ratvars</code> quando ela foi chamada mais recentemente.
Cada chamada para a fun&ccedil;&atilde;o <code>ratvars</code> sobre-grava a lista apagando seu conte&uacute;do anterior.
<code>ratvars ()</code> limpa a lista.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratweight</b><i> (<var>x_1</var>, <var>w_1</var>, ..., <var>x_n</var>, <var>w_n</var>)</i>
<a name="IDX447"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ratweight</b><i> ()</i>
<a name="IDX448"></a>
</dt>
<dd><p>Atribui um peso <var>w_i</var> para a vari&aacute;vel <var>x_i</var>.
Isso faz com que um termo seja substitu&iacute;do por 0 se seu peso exceder o
valor da vari&aacute;vel <code>ratwtlvl</code> (o padr&atilde;o retorna sem trunca&ccedil;&atilde;o).
O peso de um termo &eacute; a soma dos produtos dos
pesos de uma vari&aacute;vel no termo vezes seu expoente.
Por exemplo, o peso de <code>3 x_1^2 x_2</code> &eacute; <code>2 w_1 + w_2</code>.
A trunca&ccedil;&atilde;o de acordo com <code>ratwtlvl</code> &eacute; realizada somente quando multiplicando
ou exponencializando express&otilde;es racionais can&ocirc;nicas (CRE).
</p>
<p><code>ratweight ()</code> retorna a lista cumulativa de atribui&ccedil;&otilde;es de pesos.
</p>
<p>Nota: Os esquemas de <code>ratfac</code> e <code>ratweight</code> s&atilde;o incompat&iacute;veis e n&atilde;o podem
ambo serem usados ao mesmo tempo.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de sistema:</u> <b>ratweights</b>
<a name="IDX449"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>[]</code>
</p>
<p><code>ratweights</code> &eacute; a lista de pesos atribu&iacute;dos por <code>ratweight</code>.
A lista &eacute; cumulativa:
cada chamada a <code>ratweight</code> coloca &iacute;tens adicionais na lista.
</p>
<p><code>kill (ratweights)</code> e <code>save (ratweights)</code> ambos trabalham como esperado.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>ratwtlvl</b>
<a name="IDX450"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p><code>ratwtlvl</code> &eacute; usada em combina&ccedil;&atilde;o com a fun&ccedil;&atilde;o 
<code>ratweight</code> para controlar a trunca&ccedil;&atilde;o de express&atilde;o racionais can&ocirc;nicas (CRE).
Para o valor padr&atilde;o <code>false</code>, nenhuma trunca&ccedil;&atilde;o ocorre.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>)</i>
<a name="IDX451"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remainder</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX452"></a>
</dt>
<dd><p>Retorna o resto do polin&ocirc;mio <var>p_1</var> dividido pelo polin&ocirc;mio <var>p_2</var>.
Os argumentos <var>x_1</var>, ..., <var>x_n</var> s&atilde;o interpretados como em <code>ratvars</code>.
</p>
<p><code>remainder</code> retorna o segundo elemento
de uma lista de dois elementos retornada por <code>divide</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>resultant</b><i> (<var>p_1</var>, <var>p_2</var>, <var>x</var>)</i>
<a name="IDX453"></a>
</dt>
<dt><u>Vari&aacute;vel:</u> <b>resultant</b>
<a name="IDX454"></a>
</dt>
<dd><p>Calcula o resultante de dois polin&ocirc;mios <var>p_1</var> e <var>p_2</var>,
eliminando a vari&aacute;vel <var>x</var>.
O resultante &eacute; um determinante dos coeficientes de <var>x</var>
em <var>p_1</var> e <var>p_2</var>,
que &eacute; igual a zero
se e somente se <var>p_1</var> e <var>p_2</var> tiverem um fator em comum n&atilde;o constante.
</p>
<p>Se <var>p_1</var> ou <var>p_2</var> puderem ser fatorados,
pode ser desej&aacute;vel chamar <code>factor</code> antes de chamar <code>resultant</code>.
</p>
<p>A vari&aacute;vel <code>resultant</code> controla que algor&iacute;tmo ser&aacute; usado para calcular
o resultante.
<code>subres</code> para o prs subresultante,
<code>mod</code> para o algor&iacute;tmo resultante modular,
e <code>red</code> para prs reduzido.
Para muitos problemas <code>subres</code> pode ser melhor.
Para alguns problemas com valores grandes de grau de uma &uacute;nica vari&aacute;vel ou de duas vari&aacute;veis <code>mod</code> pode ser melhor.
</p>
<p>A fun&ccedil;&atilde;o <code>bezout</code> pega os mesmos argumentos que <code>resultant</code> e retorna
uma matriz.  O determinante do valor de retorno &eacute; o resultante desejado.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>savefactors</b>
<a name="IDX455"></a>
</dt>
<dd><p>Valor Padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>savefactors</code> for <code>true</code>, faz com que os fatores de uma
express&atilde;o que &eacute; um produto de fatores sejam gravados por certas
fun&ccedil;&otilde;es com o objetivo de aumentar a velocidade em posteriores fatora&ccedil;&otilde;es de express&otilde;es
contendo algum desses mesmos fatores.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sqfr</b><i> (<var>expr</var>)</i>
<a name="IDX456"></a>
</dt>
<dd><p>&eacute; similar a <code>factor</code> exceto que os fatores do polin&ocirc;mio s&atilde;o &quot;livres de ra&iacute;zes&quot;.
Isto &eacute;, eles possuem fatores somente de grau um.
Esse algor&iacute;tmo, que &eacute; tamb&eacute;m usado no primeiro est&aacute;gio de <code>factor</code>, utiliza
o fato que um polin&ocirc;mio tem em comum com sua n'&eacute;sima derivada todos
os seus fatores de grau maior que n.  Dessa forma pegando o maior divisor comum
com o polin&ocirc;mio das
derivadas com rela&ccedil;&atilde;o a cada vari&aacute;vel no polin&ocirc;mio, todos
os fatores de grau maior que 1 podem ser achados.
</p>
<p>Exemplo:
</p>
<pre class="example">(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tellrat</b><i> (<var>p_1</var>, ..., <var>p_n</var>)</i>
<a name="IDX457"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tellrat</b><i> ()</i>
<a name="IDX458"></a>
</dt>
<dd><p>Adiciona ao anel dos inteiros alg&eacute;bricos conhecidos do Maxima
os elementos que s&atilde;o as solu&ccedil;&otilde;es dos polin&ocirc;mios <var>p_1</var>, ..., <var>p_n</var>.
Cada argumento <var>p_i</var> &eacute; um polin&ocirc;mio concoeficientes inteiros.
</p>
<p><code>tellrat (<var>x</var>)</code> efetivamente significa substituir 0 por <var>x</var> em fun&ccedil;&otilde;es
racionais.
</p>
<p><code>tellrat ()</code> retorna uma lista das substitui&ccedil;&otilde;es correntes.
</p>
<p><code>algebraic</code> deve ser escolhida para <code>true</code> com o objetivo de que a simplifica&ccedil;&atilde;o de
inteiros alg&eacute;bricos tenha efeito.
</p>
<p>Maxima inicialmente sabe sobre a unidade imagin&aacute;ria <code>%i</code>
e todas as ra&iacute;zes de inteiros.
</p>
<p>Existe um comando <code>untellrat</code> que pega kernels (n&uacute;cleos) e
remove propriedades <code>tellrat</code>.
</p>
<p>Quando fazemos <code>tellrat</code> em um polin&ocirc;mio
de v&aacute;rias vari&aacute;veis, e.g., <code>tellrat (x^2 - y^2)</code>, pode existir uma ambig&uuml;idade como para
ou substituir <code><var>y</var>^2</code> por <code><var>x</var>^2</code>
ou vice-versa.  
Maxima seleciona uma ordena&ccedil;&atilde;o particular, mas se o usu&aacute;rio desejar especificar qual e.g.
<code>tellrat (y^2 = x^2)</code> forne&ccedil;e uma sintaxe que diga para substituir
<code><var>y</var>^2</code> por <code><var>x</var>^2</code>.
</p>

<p>Exemplos:
</p>
<pre class="example">(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>totaldisrep</b><i> (<var>expr</var>)</i>
<a name="IDX459"></a>
</dt>
<dd><p>Converte toda subexpress&atilde;o de <var>expr</var> da forma de express&atilde;o racionais can&ocirc;nicas (CRE) para
a forma geral e retorna o resultado.
Se <var>expr</var> &eacute; em s&iacute; mesma na forma CRE ent&atilde;o <code>totaldisrep</code> &eacute; identica a
<code>ratdisrep</code>.
</p>
<p><code>totaldisrep</code> pode ser usada para
fazer um <code>ratdisrep</code> em express&otilde;es tais como equa&ccedil;&otilde;es, listas, matrizes, etc., que
tiverem algumas subexpress&otilde;es na forma CRE.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>untellrat</b><i> (<var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX460"></a>
</dt>
<dd><p>Remove propriedades <code>tellrat</code> de <var>x_1</var>, ..., <var>x_n</var>.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC42" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_13.html#SEC45" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
