<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Outubro, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 36. Regras e Modelos</title>

<meta name="description" content="Manual do Maxima: 36. Regras e Modelos">
<meta name="keywords" content="Manual do Maxima: 36. Regras e Modelos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Regras-e-Modelos"></a>
<a name="SEC145"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_35.html#SEC144" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC146" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC141" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 36. Regras e Modelos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC146">36.1 Introdu&ccedil;&atilde;o a Regras e Modelos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC147">36.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Regras e Modelos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Regras-e-Modelos"></a>
<a name="SEC146"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC147" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC145" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.1 Introdu&ccedil;&atilde;o a Regras e Modelos </h2>

<p>Essa se&ccedil;&atilde;o descreve coincid&ecirc;ncias de modelos definidos pelo usu&aacute;rio e
regras de simplifica&ccedil;&atilde;o.
Existem dois grupos de fun&ccedil;&otilde;es que implementam at&eacute; certo ponto diferentes esquemas de coincid&ecirc;ncia de modelo.
Em um grupo est&atilde;o <code>tellsimp</code>, <code>tellsimpafter</code>, <code>defmatch</code>, <code>defrule</code>,
<code>apply1</code>, <code>applyb1</code>, e <code>apply2</code>.
Em outro grupo est&atilde;o <code>let</code> e <code>letsimp</code>.
Ambos os esquemas definem modelos em termos de vari&aacute;veis de modelo declaradas por <code>matchdeclare</code>.
</p>
<p>Regras de coincid&ecirc;ncia de modelos definidas por <code>tellsimp</code> e <code>tellsimpafter</code> s&atilde;o aplicadas automaticamente
atrav&eacute;s do simplificador do Maxima.
Regras definidas atrav&eacute;s de <code>defmatch</code>, <code>defrule</code>, e <code>let</code> s&atilde;o aplicadas
atrav&eacute;s de uma chamada expl&iacute;cita de fun&ccedil;&atilde;o.
</p>
<p>Existe mecanismos adicionais para regras aplicadas a polin&ocirc;mios atrav&eacute;s de <code>tellrat</code>,
e para &aacute;lgebra comutativa e n&atilde;o comutativa no pacote <code>affine</code>. 
</p>
<hr size="6">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Regras-e-Modelos"></a>
<a name="SEC147"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC146" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC145" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.2 Fun&ccedil;&otilde;es e Vari&aacute;veis Definidas para Regras e Modelos </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>apply1</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1173"></a>
</dt>
<dd><p>Repetidamente aplica <var>rule_1</var> a
<var>expr</var> at&eacute; que isso falhe, ent&atilde;o repetidamente aplica a mesma regra a todas
as subexpress&otilde;es de <var>expr</var>, da esquerda para a direita, at&eacute; que <var>rule_1</var> tenha falhado
sobre todas as subexpress&otilde;es.  Chama o resultado da transforma&ccedil;&atilde;o de <var>expr</var> dessa
maneira de <var>expr_2</var>.  Ent&atilde;o <var>rule_2</var> &eacute; aplicada no mesmo estilo
iniciando no topo de <var>expr_2</var>.  Quando <var>rule_n</var> falhar na subexpress&atilde;o
final, o resultado &eacute; retornado.
</p>
<p><code>maxapplydepth</code> &eacute; a intensidade de n&iacute;vel mais distante de subexpress&otilde;es processadas por
<code>apply1</code> e <code>apply2</code>.
</p>
<p>Veja tamb&eacute;m <code>applyb1</code>, <code>apply2</code>, e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>apply2</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1174"></a>
</dt>
<dd><p>Se <var>rule_1</var> falhar sobre uma dada subexpress&atilde;o, ent&atilde;o <var>rule_2</var> &eacute;
repetidamente aplicada, etc.  Somente se todas as regras falharem sobre uma dada
subexpress&atilde;o &eacute; que o conjunto completo de regras &eacute; repetidamente aplicada &agrave; pr&oacute;xima
subexpress&atilde;o.  Se uma das regras obt&eacute;m sucesso, ent&atilde;o a mesma
subexpress&atilde;o &eacute; reprocessada, iniciando com a primeira regra.
</p>
<p><code>maxapplydepth</code> &eacute; a intensidade do n&iacute;vel mais distante de subexpress&otilde;es processadas atrav&eacute;s de
<code>apply1</code> e <code>apply2</code>.
</p>
<p>Veja tamb&eacute;m <code>apply1</code> e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>applyb1</b><i> (<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</i>
<a name="IDX1175"></a>
</dt>
<dd><p>Repetidamente aplica <var>rule_1</var> para a subexpress&atilde;o mais distante de <var>expr</var> at&eacute; falhar,
ent&atilde;o repetidamente aplica a mesma regra um n&iacute;vel mais acima (i.e., subexpress&atilde;os mais larga),
at&eacute; que <var>rule_1</var> tenha falhado sobre a express&atilde;o de n&iacute;vel mais alto.
Ent&atilde;o <var>rule_2</var> &eacute; aplicada com o mesmo estilo para o resultado de <var>rule_1</var>.
ap&oacute;s <var>rule_n</var> ter sido aplicada &agrave; express&atilde;o de n&iacute;vel mais elevado,
o resultado &eacute; retornado.
</p>
<p><code>applyb1</code> &eacute; similar a <code>apply1</code> mas trabalha da
base para cima em lugar de do topo para baixo.
</p>
<p><code>maxapplyheight</code> &eacute; o &aacute;pice que <code>applyb1</code> encontra
antes de interromper.
</p>
<p>Veja tamb&eacute;m <code>apply1</code>, <code>apply2</code>, e <code>let</code>.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>current_let_rule_package</b>
<a name="IDX1176"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>default_let_rule_package</code>
</p>
<p><code>current_let_rule_package</code> &eacute; o nome do pacote de regras que est&aacute; sendo usado por
fun&ccedil;&otilde;es no pacote <code>let</code> (<code>letsimp</code>, etc.) se nenhum outro pacote de regras for especificado.
A essa vari&aacute;vel pode ser atribu&iacute;do o nome de qualquer pacote de regras definido
via comando <code>let</code>.
</p>
<p>Se uma chamada tal como <code>letsimp (expr, nome_pct_regras)</code> for feita,
o pacote de regras <code>nome_pct_regras</code> &eacute; usado para aquela chamada de fun&ccedil;&atilde;o somente,
e o valor de <code>current_let_rule_package</code> n&atilde;o &eacute; alterado.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>default_let_rule_package</b>
<a name="IDX1177"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>default_let_rule_package</code>
</p>
<p><code>default_let_rule_package</code> &eacute; o nome do pacote de regras usado quando um
n&atilde;o for explicitamente escolhido pelo usu&aacute;rio com <code>let</code> ou atrav&eacute;s de altera&ccedil;&atilde;o do valor de
<code>current_let_rule_package</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>defmatch</b><i> (<var>prognome</var>, <var>modelo</var>, <var>x_1</var>, ..., <var>x_n</var>)</i>
<a name="IDX1178"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>defmatch</b><i> (<var>prognome</var>, <var>modelo</var>)</i>
<a name="IDX1179"></a>
</dt>
<dd><p>Define uma fun&ccedil;&atilde;o <code><var>prognome</var>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>
que testa <var>expr</var> para ver se essa express&atilde;o coincide com <var>modelo</var>.
</p>
<p><var>modelo</var> &eacute; uma express&atilde;o contendo os argumentos modelo <var>x_1</var>, ..., <var>x_n</var> (se existir algum)
e alguns modelos de vari&aacute;veis (se existir algum).
os argumentos modelo s&atilde;o fornecidos explicitamente como argumentos para <code>defmatch</code> enquanto os modelos de vari&aacute;veis
s&atilde;o declarados atrav&eacute;s da fun&ccedil;&atilde;o <code>matchdeclare</code>.
Qualquer vari&aacute;vel n&atilde;o declarada como modelo em <code>matchdeclare</code>
ou como um argumento modelo em <code>defmatch</code> coincide somente com si mesma.
</p>
<p>O primeiro argumento para a fun&ccedil;&atilde;o criada <var>prognome</var> &eacute; uma express&atilde;o
a serem comparadas contra o modelo  e os outros argumentos s&atilde;o os atuais argumetnos
que correspondem &agrave;s vari&aacute;veis respectivas <var>x_1</var>, ..., <var>x_n</var> no modelo.
</p>
<p>Se a tentativa de coincid&ecirc;ncia obtiver sucesso, <var>prognome</var> retorna
uma lista de equa&ccedil;&otilde;es cujos lados esquerdos s&atilde;o os
argumetnos de modelo e vari&aacute;veis de modelo, e cujo lado direito forem as subexpress&otilde;es
cujos argumentos de modelo e as vari&aacute;veis coincidem.
Os modelos de vari&aacute;veis, mas n&atilde;o tos argumentos de modelo, s&atilde;o atribu&iacute;dos &agrave;s subexpress&otilde;es que coincidirem.
Se a coincid&ecirc;ncia falhar, <var>prognome</var> retorna <code>false</code>.  
</p>
<p>Um modelo literal
(isto &eacute;, um modelo que n&atilde;o contiver nem argumentos de modelo nem vari&aacute;veis de modelo)
retorna <code>true</code> se a coincid&ecirc;ncia ocorrer.
</p>
<p>Veja tamb&eacute;m <code>matchdeclare</code>, <code>defrule</code>, <code>tellsimp</code>, e <code>tellsimpafter</code>.
</p>
<p>Exemplos:
</p>
<p>Define uma fun&ccedil;&atilde;o <code>linearp(expr, x)</code> que
testa <code>expr</code> para ver se essa express&atilde;o da forma <code>a*x + b</code>
tal que <code>a</code> e <code>b</code> n&atilde;o contenham <code>x</code> e <code>a</code> seja n&atilde;o nulo.
Essa fun&ccedil;&atilde;o de coincid&ecirc;ncia coincide com express&otilde;es que sejam lineares em qualquer vari&aacute;vel,
por que o argumento de modelo <code>x</code> &eacute; fornecido para <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre>
<p>Define uma fun&ccedil;&atilde;o <code>linearp(expr)</code> que testa <code>expr</code>
para ver se essa express&atilde;o &eacute; da forma <code>a*x + b</code>
tal que <code>a</code> e <code>b</code> n&atilde;o contenham <code>x</code> e <code>a</code> seja n&atilde;o nulo.
Essa fun&ccedil;&atilde;o de coincid&ecirc;ncia somente coincide com express&otilde;es lineares em <code>x</code>,
n&atilde;o em qualquer outra vari&aacute;vel, porque nenhum argumento de modelo &eacute; fornecido a <code>defmatch</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre>
<p>Define uma fun&ccedil;&atilde;o <code>checklimits(expr)</code> que testa <code>expr</code>
para ver se essa express&atilde;o &eacute; uma integral definida.
</p> 
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>defrule</b><i> (<var>nomeregra</var>, <var>modelo</var>, <var>substitui&ccedil;&atilde;o</var>)</i>
<a name="IDX1180"></a>
</dt>
<dd><p>Define e nomeia uma
regra de substitui&ccedil;&atilde;o para o modelo dado.  Se a regra nomeada <var>nomeregra</var> for
aplicada a uma express&atilde;o (atrav&eacute;s de <code>apply1</code>, <code>applyb1</code>, ou <code>apply2</code>), toda
subexpress&atilde;o coincidindo com o modelo ser&aacute; substitu&iacute;da por
<code>substitui&ccedil;&atilde;o</code>. Todas as vari&aacute;veis em <code>substitui&ccedil;&atilde;o</code> que tiverem sido
atribuidos valores pela coincid&ecirc;ncia com o modelo s&atilde;o atribuidas esses valores na
<code>substitui&ccedil;&atilde;o</code> que &eacute; ent&atilde;o simplificado.
</p>
<p>As regras por si mesmas podem ser
tratadas como fun&ccedil;&otilde;es que transforma uma express&atilde;o atrav&eacute;s de uma
opera&ccedil;&atilde;o de coincid&ecirc;ncia de modelo e substitui&ccedil;&atilde;o.
Se a coincid&ecirc;ncia falhar, a fun&ccedil;&atilde;o da regra retorna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>disprule</b><i> (<var>nomeregra_1</var>, ..., <var>nomeregra_2</var>)</i>
<a name="IDX1181"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>disprule</b><i> (all)</i>
<a name="IDX1182"></a>
</dt>
<dd><p>Mostra regras com os nomes <var>nomeregra_1</var>, ..., <var>nomeregra_n</var>,
como retornado por <code>defrule</code>, <code>tellsimp</code>, ou <code>tellsimpafter</code>,
ou um modelo definido por meio de <code>defmatch</code>.
Cada regra &eacute; mostrada com um r&oacute;tulo de express&atilde;o intermedi&aacute;ria (<code>%t</code>).
</p>
<p><code>disprule (all)</code> mostra todas as regras.
</p>
<p><code>disprule</code> n&atilde;o avalia seus argumentos.
<code>disprule</code> retorna a lista de r&oacute;tulos de express&otilde;es intermed&aacute;irias correspondendo &agrave;s regras mostradas.
</p>
<p>Veja tamb&eacute;m <code>letrules</code>, que mostra regras definidas atrav&eacute;s de <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x),
+rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ..., <var>arg_n</var>)</i>
<a name="IDX1183"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>let</b><i> ([<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>nome_pacote</var>)</i>
<a name="IDX1184"></a>
</dt>
<dd><p>Define uma regra de substitui&ccedil;&atilde;o para <code>letsimp</code> tal que <var>prod</var> &eacute; substitu&iacute;do por <var>repl</var>.
<var>prod</var> &eacute; um produto de expoentes positivos ou negativos dos seguintes termos:
</p>
<ul>
<li>
Atomos que <code>letsimp</code> ir&aacute; procurar literalmente a menos que previamente
chamando <code>letsimp</code> a fun&ccedil;&atilde;o <code>matchdeclare</code> &eacute; usada para associar um
predicado com o &aacute;tomo.  Nesse caso <code>letsimp</code> ir&aacute; coincidir com o &aacute;tomo para
qualquer termo de um produto satisfazendo o predicado.
</li><li>
N&uacute;cleos tais como <code>sin(x)</code>, <code>n!</code>, <code>f(x,y)</code>, etc.  Como com &aacute;tomos acima
<code>letsimp</code> ir&aacute; olhar um literal coincidente a menos que <code>matchdeclare</code> seja usada para
associar um predicado com o argumento do n&uacute;cleo.
</li></ul>

<p>Um termo para um expoente positivo ir&aacute; somente coincidir com um termo tendo ao menos aquele
expoente.  Um termo para um expoente negativo
por outro lado ir&aacute; somente coincidir com um termo com um expoente ao menos j&aacute;
negativo.  o caso de expentes negativos em <var>prod</var> o comutador
<code>letrat</code> deve ser escolhido para <code>true</code>.
Veja tamb&eacute;m <code>letrat</code>.
</p>
<p>Se um predicado for inclu&iacute;do na fun&ccedil;&atilde;o <code>let</code> seguido por uma lista de
argumentos, uma tentativa de coincid&ecirc;ncia (i.e. uma que pode ser aceita se o
predicado fosse omitido) &eacute; aceita somente se
<code>prednome (arg_1', ..., arg_n')</code> avaliar para <code>true</code> onde <var>arg_i'</var> &eacute; o valor
coincidente com <var>arg_i</var>.  O <var>arg_i</var> pode ser o nome de qualquer &aacute;tomo ou o argumento
de qualquer n&uacute;cleo aparecendo em <var>prod</var>.
<var>repl</var> pode ser qualquer express&atilde;o racional. Se quaisquer dos &aacute;tomos ou argumentos de <var>prod</var> aparecer em <var>repl</var> a
substitui&ccedil;&atilde;o &eacute; feita. </p>
<p>O sinalizador global <code>letrat</code> controla a simplifica&ccedil;&atilde;o dos quocientes atrav&eacute;s de <code>letsimp</code>.
Quando <code>letrat</code> for <code>false</code>,
<code>letsimp</code> simplifica o numerador e o
denominador de <var>expr</var> separadamente, e n&atilde;o simplifica o quociente.
Substitui&ccedil;&otilde;es tais como <code>n!/n</code> v&atilde;o para <code>(n-1)!</code> ent&atilde;o falham quando <code>letrat</code> for <code>false</code>.
Quando <code>letrat</code> for <code>true</code>, ent&atilde;o o numerador,
o denominador, e o quociente s&atilde;o simplificados nessa ordem.
</p>
<p>Essas fun&ccedil;&otilde;es de substitui&ccedil;&atilde;o permitem a voc&ecirc; trabalhar com muitos pacotes de regras.
Cada pacote de regras pode conter qualquer n&uacute;mero de regras
<code>let</code> e &eacute; referenciado atrav&eacute;s de um nome definido pelo usu&aacute;rio.
<code>let ([<var>prod</var>, <var>repl</var>, <var>prednome</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>nome_pacote</var>)</code>
adiciona a regra <var>prednome</var> ao pacote de regras <var>nome_pacote</var>.
<code>letsimp (<var>expr</var>, <var>nome_pacote</var>)</code> 
aplica as regras em <var>nome_pacote</var>.
<code>letsimp (<var>expr</var>, <var>nome_pacote1</var>, <var>nome_pacote2</var>, ...)</code>
&eacute; equivalente a <code>letsimp (<var>expr</var>, <var>nome_pacote1</var>)</code>
seguido por <code>letsimp (%, <var>nome_pacote2</var>)</code>, ....
</p>
<p><code>current_let_rule_package</code> &eacute; o nome do pacote de regras que est&aacute;
atualmente sendo usando.
Essa vari&aacute;vel pode receber o nome de
qualquer pacote de regras definidos via o comando <code>let</code>.
Quando qualquer das fun&ccedil;&otilde;es compreendidas no pacote <code>let</code> s&atilde;o chamadas sem o nome do pacote,
o pacote nomeado por <code>current_let_rule_package</code> &eacute; usado.
Se uma chamada tal como <code>letsimp (<var>expr</var>, <var>nome_pct_regras</var>)</code> &eacute; feita,
o pacote de regras <var>nome_pct_regras</var> &eacute; usado somente para aquele comando <code>letsimp</code>,
e <code>current_let_rule_package</code> n&atilde;o &eacute; alterada.
Se n&atilde;o especificado de outra forma,
<code>current_let_rule_package</code> avalia de forma padronizada para <code>default_let_rule_package</code>.
</p>
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>letrat</b>
<a name="IDX1185"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>false</code>
</p>
<p>Quando <code>letrat</code> for <code>false</code>, <code>letsimp</code> simplifica o
numerador e o denominador de uma raz&atilde;o separadamente,
e n&atilde;o simplifica o quociente.
</p>
<p>Quando <code>letrat</code> for <code>true</code>,
o numerador, o denominador, e seu quocienten s&atilde;o simplificados nessa ordem.
</p>
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>letrules</b><i> ()</i>
<a name="IDX1186"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>letrules</b><i> (<var>nome_pacote</var>)</i>
<a name="IDX1187"></a>
</dt>
<dd><p>Mostra as regras em um pacote de regras.
<code>letrules ()</code> mostra as regras no pacote de regras corrente.
<code>letrules (<var>nome_pacote</var>)</code> mostra as regras em <code>nome_pacote</code>.
</p>
<p>O pacote de regras corrente &eacute; nomeado por <code>current_let_rule_package</code>.
Se n&atilde;o especificado de outra forma, <code>current_let_rule_package</code>
avalia de forma padr&atilde;o para <code>default_let_rule_package</code>.
</p>
<p>Veja tamb&eacute;m <code>disprule</code>, que mostra regras defindas por <code>tellsimp</code> e <code>tellsimpafter</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>letsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1188"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>letsimp</b><i> (<var>expr</var>, <var>nome_pacote</var>)</i>
<a name="IDX1189"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>letsimp</b><i> (<var>expr</var>, <var>nome_pacote_1</var>, ..., <var>nome_pacote_n</var>)</i>
<a name="IDX1190"></a>
</dt>
<dd><p>Repetidamente aplica a substitui&ccedil;&atilde;o definida por <code>let</code>
at&eacute; que nenhuma mudan&ccedil;a adicional seja feita para <var>expr</var>.
</p>
<p><code>letsimp (<var>expr</var>)</code> usa as regras de <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>nome_pacote</var>)</code> usa as regras de <var>nome_pacote</var>
sem alterar <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>nome_pacote_1</var>, ..., <var>nome_pacote_n</var>)</code>
&eacute; equivalente a <code>letsimp (<var>expr</var>, <var>nome_pacote_1</var></code>,
seguido por <code>letsimp (%, <var>nome_pacote_2</var>)</code>, e assim sucessivamente.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel de op&ccedil;&atilde;o:</u> <b>let_rule_packages</b>
<a name="IDX1191"></a>
</dt>
<dd><p>Valor padr&atilde;o: <code>[default_let_rule_package]</code>
</p>
<p><code>let_rule_packages</code> &eacute; uma lista de todos os pacotes de regras <code>let</code> definidos pelo usu&aacute;rio
mais o pacote padr&atilde;o <code>default_let_rule_package</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matchdeclare</b><i> (<var>a_1</var>, <var>pred_1</var>, ..., <var>a_n</var>, <var>pred_n</var>)</i>
<a name="IDX1192"></a>
</dt>
<dd><p>Associa um predicado <var>pred_k</var> 
com uma vari&aacute;vel ou lista de vari&aacute;veis <var>a_k</var>
de forma que <var>a_k</var> coincida com express&otilde;es
para as quais o predicado retorne qualquer coisa que n&atilde;o <code>false</code>.
</p>
<p>Umpredicado &eacute; o nome de uma fun&ccedil;&atilde;o,
ou de uma express&atilde;o lambda,
ou uma chamada de fun&ccedil;&atilde;o ou chamada de fun&ccedil;&atilde;o lambda iomitindo o &uacute;lltimo argumento,
ou <code>true</code> ou <code>all</code>.
Qualquer express&atilde;o coincide com <code>true</code> ou <code>all</code>.
Se o predicado for especificado como uma chamada de fun&ccedil;&atilde;o ou chamada de fun&ccedil;&atilde;o lambda,
a express&atilde;o a ser testada &eacute; anexada ao final da lista de argumentos;
os argumentos s&atilde;o avaliados ao mesmo tempo que a coincid&ecirc;ncia &eacute; avaliada.
De outra forma, o predicado &eacute; especificado como um nome de fun&ccedil;&atilde;o ou express&atilde;o lambda,
e a express&atilde;o a ser testada &eacute; o argumento sozinho.
Uma fun&ccedil;&atilde;o predicado n&atilde;o precisa ser definida quando <code>matchdeclare</code> for chamada;
o predicado n&atilde;o &eacute; avaliado at&eacute; que uma coincid&ecirc;ncia seja tentada.
</p>
<p>Um predicado pode retornar uma express&atilde;o Booleana al&eacute;m de <code>true</code> ou <code>false</code>.
Express&otilde;es Booleanas s&atilde;o avaliadas por <code>is</code> dentro da fun&ccedil;&atilde;o da regra constru&iacute;da,
de forma que n&atilde;o &eacute; necess&aacute;rio chamar <code>is</code> dentro do predicado.
</p>
<p>Se uma express&atilde;o satisfaz uma coincid&ecirc;ncia de predicado,
a vari&aacute;vel de coincid&ecirc;ncia &eacute; atribu&iacute;da &agrave; express&atilde;o,
exceto para vari&aacute;veis de coincid&ecirc;ncia que s&atilde;o operandos de adi&ccedil;&atilde;o <code>+</code> ou multiplica&ccedil;&atilde;o <code>*</code>.
Somente adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o s&atilde;o manuseadas de forma especial;
outros operadores en&aacute;rios (ambos os definidos internamente e os definidos pelo usu&aacute;rio) s&atilde;o tratados como fun&ccedil;&otilde;es comuns.
</p>
<p>No caso de adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o,
a vari&aacute;vel de coincid&ecirc;ncia pode ser atribuida a uma express&atilde;o simples que satisfaz o predicado de coincid&ecirc;ncia,
ou uma adi&ccedil;&atilde;o ou um produto (respectivamente) de tais express&otilde;es.
Tal coincid&ecirc;ncia de termo multiplo &eacute; gulosa:
predicados s&atilde;o avaliados na ordem em que suas vari&aacute;veis associadas
aparecem no modelo de coincid&ecirc;ncia,
e o termo que satisfizer mais que um predicado &eacute; tomado pelo primeiro
predicado que satisfizer.
Cada predicado &eacute; testado contra todos os operandos de adi&ccedil;&atilde;o ou produto antes que o pr&oacute;ximo predicado seja avaliado.
Adicionalmente,
se 0 ou 1 (respectivamente) satisfazem um predicado de coincid&ecirc;ncia,
e n&atilde;o existe outros termos que satisfa&ccedil;am o predicado,
0 ou 1 &eacute; atribu&iacute;do para a vari&aacute;vel de coincid&ecirc;ncia associada com o predicado.
</p>
<p>O algor&iacute;tmo para processar modelos contendo adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o faz alguns resultados de coincid&ecirc;ncia
(por exemplo, um modelo no qual uma vari&aacute;vel &quot;coincida com qualquer coisa&quot; aparecer)
dependerem da ordem dos termos no modelo de coincid&ecirc;ncia e na express&atilde;o a ser testada a coincid&ecirc;ncia.
Todavia,
se todos os predicados de coincid&ecirc;ncia s&atilde;o mutuamente exclusivos,
o resultado de coincid&ecirc;ncia &eacute; insens&iacute;vel a ordena&ccedil;&atilde;o,
como um predicado de coincid&ecirc;ncia n&atilde;o pode aceitar termos de coincid&ecirc;ncia de outro.
</p>
<p>Chamado <code>matchdeclare</code> com uma vari&aacute;vel <var>a</var> como um argumento
muda a propriedade <code>matchdeclare</code> para <var>a</var>, se a vari&aacute;vel <var>a</var> tiver sido declarada anteriormente;
somente o <code>matchdeclare</code> mais recente est&aacute; em efeito quando uma regra &eacute; definida,
mudan&ccedil;as posteriores para a propriedade <code>matchdeclare</code>
(via <code>matchdeclare</code> ou <code>remove</code>)
n&atilde;o afetam regras existentes.
</p>
<p><code>propvars (matchdeclare)</code> retorna a lista de todas as vari&aacute;veis
para as quais exista uma propriedade <code>matchdeclare</code>.
<code>printprops (<var>a</var>, matchdeclare)</code> retorna o predicado para a vari&aacute;vel <code>a</code>.
<code>printprops (all, matchdeclare)</code> retorna a lista de predicados para todas as vari&aacute;veis <code>matchdeclare</code>.
<code>remove (<var>a</var>, matchdeclare)</code> remove a propriedade <code>matchdeclare</code> da vari&aacute;vel <var>a</var>.
</p>
<p>As fun&ccedil;&otilde;es
<code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>tellsimpafter</code>, e <code>let</code>
constroem regras que testam express&otilde;es contra modelos.
</p>
<p><code>matchdeclare</code> coloca ap&oacute;strofo em seus argumentos.
<code>matchdeclare</code> sempre retorna <code>done</code>.
</p>
<p>Exemplos:
</p>
<p>Um predicado &eacute; o nome de uma fun&ccedil;&atilde;o,
ou uma express&atilde;o lambda,
ou uma chamada de fun&ccedil;&atilde;o ou chamada a fun&ccedil;&atilde;o lambda omitindo o &uacute;ltimo argumento,
or <code>true</code> or <code>all</code>.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre>
<p>Se uma express&atilde;o satisfaz um predicado de coincid&ecirc;ncia,
a vari&aacute;vel de coincid&ecirc;ncia &eacute; atribu&iacute;da &agrave; express&atilde;o.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre>
<p>No caso de adi&ccedil;&atilde;o e multiplica&ccedil;&atilde;o,
&agrave; vari&aacute;vel de coincid&ecirc;ncia pode ser atribu&iacute;da uma express&atilde;o simples que satisfaz o predicado de coincid&ecirc;ncia,
ou um somat&oacute;rio ou produt&oacute;rio (respectivamente) de tais express&otilde;es.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre>
<p>Quando coincidindo argumentos de <code>+</code> e <code>*</code>,
se todos os predicados de coincid&ecirc;ncia forem mutuamente exclusivos,
o resultado da coincid&ecirc;ncia &eacute; insens&iacute;ve &agrave; ordena&ccedil;&atilde;o,
como um predicado de coincid&ecirc;ncia n&atilde;o pode aceitar termos que coincidiram com outro.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; = bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre>
<p>As fun&ccedil;&otilde;es <code>propvars</code> e <code>printprops</code> retornam informa&ccedil;&otilde;es sobre vari&aacute;vels de coincid&ecirc;ncia.
</p>
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matchfix</b><i> (<var>delimitador_e</var>, <var>delimitador_d</var>)</i>
<a name="IDX1193"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>matchfix</b><i> (<var>delimitador_e</var>, <var>delimitador_d</var>, <var>arg_pos</var>, <var>pos</var>)</i>
<a name="IDX1194"></a>
</dt>
<dd><p>Declara um operador <code>matchfix</code> com delimitadores esquerdo e direito <var>delimitador_e</var> e <var>delimitador_d</var>.
Os delimitadores s&atilde;o especificados como seq&uuml;&ecirc;cias de caracteres.
</p>
<p>Um operador &quot;matchfix&quot; &eacute; uma fun&ccedil;&atilde;o que aceita qualquer n&uacute;mero de argumentos,
tal que os argumentos ocorram entre os delimitadores correspondentes esquerdo e direito.
Os delimitadores podem ser quaisquer seq&uuml;&ecirc;cias de caracteres, contanto que o analisador de express&otilde;es do Maxima possa
disting&uuml;ir os delimitadores dos operandos 
e de outras express&otilde;es e operadores.
Na pr&aacute;tica essas regras excluem delimitadores n&atilde;o analis&aacute;veis tais como
<code>%</code>, <code>,</code>, <code>$</code> e <code>;</code>, 
e pode ser necess&aacute;rio isolar os delimitadores com espa&ccedil;os em branco.
O delimitador da direita pode ser o mesmo ou diferente do delimitador da esquerda.
</p>
<p>Um delimitador esquerdo pode ser associado com somente um delimitador direito;
dois diferentes operadores <code>matchfix</code> n&atilde;o podem ter o mesmo delimitador esquerdo.
</p>
<p>Um operador existente pode ser redeclarado com um operador <code>matchfix</code>
sem alterar suas outras propriedades.
Particularmente, operadores internos tais como adi&ccedil;&atilde;o <code>+</code> podem
ser declarados <code>matchfix</code>,
mas fun&ccedil;&otilde;es operadores n&atilde;o podem ser definidas para operadores internos.
</p>
<p><code>matchfix (<var>delimitador_e</var>, <var>delimitador_d</var>, <var>arg_pos</var>, <var>pos</var>)</code> 
declara o argumento <var>arg_pos</var> como sendo um entre: express&atilde;o l&oacute;gica,
express&atilde;o comum do Maxima mas que n&atilde;o seja do tipo anterior, e qualquer outro
tipo de express&atilde;o que n&atilde;o esteja inclu&iacute;da nos dois primeiros tipos.
Essa declara&ccedil;&atilde;o resulta em <var>pos</var> sendo um entre: express&atilde;o l&oacute;gica,
express&atilde;o comum do Maxima mas que n&atilde;o seja do tipo anterior, e qualquer outro
tipo de express&atilde;o que n&atilde;o esteja inclu&iacute;da nos dois primeiros tipos 
e os delimitadores <var>delimitador_e</var> e <var>delimitador_d</var>.
</p>

<p>A fun&ccedil;&atilde;o para realizar uma opera&ccedil;&atilde;o <code>matchfix</code> &eacute; uma fun&ccedil;&atilde;o
comum definida pelo usu&aacute;rio.
A fun&ccedil;&atilde;o operador &eacute; definida
da forma usual
com o operador de defini&ccedil;&atilde;o de fun&ccedil;&atilde;o <code>:=</code> ou <code>define</code>.
Os argumentos podem ser escritos entre os delimitadores,
ou com o delimitador esquerdo com uma seq&uuml;&ecirc;ncia de caracteres com ap&oacute;strofo e os argumentos
seguindo entre par&ecirc;ntesis.
<code>dispfun (<var>delimitador_e</var>)</code> mostra a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o operador.
</p>
<p>O &uacute;nico operador interno <code>matchfix</code> &eacute; o construtor de listas <code>[ ]</code>.
Par&ecirc;ntesis <code>( )</code> e aspas duplas <code>&quot; &quot;</code> 
atuam como operadores <code>matchfix</code>,
mas n&atilde;o s&atilde;o tratados como tal pelo analisador do Maxima.
</p>
<p><code>matchfix</code> avalia seus argumentos.
<code>matchfix</code> retorna seu primeiro argumento, <var>delimitador_e</var>.
</p>
<p>Exemplos:
</p>
<ul>
<li>
Delimitadores podem ser quase quaisquer seq&uuml;&ecirc;ncia de caracteres.
</li></ul>
<pre class="example">(%i1) matchfix (&quot;@@&quot;, &quot;~&quot;);
(%o1)                          @@
(%i2) @@ a, b, c ~;
(%o2)                      @@a, b, c~
(%i3) matchfix (&quot;&gt;&gt;&quot;, &quot;&lt;&lt;&quot;);
(%o3)                          &gt;&gt;
(%i4) &gt;&gt; a, b, c &lt;&lt;;
(%o4)                      &gt;&gt;a, b, c&lt;&lt;
(%i5) matchfix (&quot;foo&quot;, &quot;oof&quot;);
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) &gt;&gt; w + foo x, y oof + z &lt;&lt; / @@ p, q ~;
                     &gt;&gt;z + foox, yoof + w&lt;&lt;
(%o7)                ----------------------
                            @@p, q~
</pre>
<ul>
<li>
Operadores <code>matchfix</code> s&atilde;o fun&ccedil;&otilde;es comuns definidas pelo usu&aacute;rio.
</li></ul>
<pre class="example">(%i1) matchfix (&quot;!-&quot;, &quot;-!&quot;);
(%o1)                         &quot;!-&quot;
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define (&quot;!-&quot; (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun (&quot;!-&quot;);
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) &quot;!-&quot; (3, 5);
                                16
(%o7)                         - --
                                15
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remlet</b><i> (<var>prod</var>, <var>nome</var>)</i>
<a name="IDX1195"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remlet</b><i> ()</i>
<a name="IDX1196"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remlet</b><i> (all)</i>
<a name="IDX1197"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remlet</b><i> (all, <var>nome</var>)</i>
<a name="IDX1198"></a>
</dt>
<dd><p>Apaga a regra de substitui&ccedil;ao, prod -&gt; repl, mais
recentemente definida atrav&eacute;s dea fun&ccedil;&atilde;o <code>let</code>.  Se <code>nome</code> for fornecido a regra &eacute;
apagada do pacote de regras chamado <code>nome</code>.
</p>
<p><code>remlet()</code> e <code>remlet(all)</code> apagam todas as regras de substitui&ccedil;&atilde;o do pacote de regras corrente.
Se o nome de um pacote de regras for fornecido,
e.g. <code>remlet (all, <var>nome</var>)</code>, o pacote de regras <var>nome</var> &eacute; tamb&eacute;m apagado.
</p>
<p>Se uma substitui&ccedil;&atilde;o &eacute; para ser mudada usando o mesmo
produto, <code>remlet</code> n&atilde;o precisa ser chamada, apenas redefina a substitui&ccedil;&atilde;o
usando o mesmo produto (literalmente) com a fun&ccedil;&atilde;o <code>let</code> e a nova
substitui&ccedil;&atilde;o e/ou nome de predicado.  Pode agora <code>remlet (<var>prod</var>)</code> ser
chamada e a regra de substitui&ccedil;&atilde;o original &eacute; ressuscitada.
</p>
<p>Veja tamb&eacute;m <code>remrule</code>, que remove uma regra definida atrav&eacute;s de <code>tellsimp</code> ou de <code>tellsimpafter</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remrule</b><i> (<var>op</var>, <var>nomeregra</var>)</i>
<a name="IDX1199"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>remrule</b><i> (<var>op</var>, all)</i>
<a name="IDX1200"></a>
</dt>
<dd><p>Remove regras definidas por <code>tellsimp</code>, ou <code>tellsimpafter</code>.
</p>
<p><code>remrule (<var>op</var>, <var>nomeregra</var>)</code>
remove a regra com o nome <code>nomeregra</code> do operador <var>op</var>.
Quando <var>op</var> for um operador interno ou um operador definido pelo usu&aacute;rio
(como definido por <code>infix</code>, <code>prefix</code>, etc.),
<var>op</var> e <var>rulename</var> devem ser colocados entre aspas duplas.
</p>
<p><code>remrule (<var>op</var>, all)</code> remove todas as regras para o operador <var>op</var>.
</p>
<p>Veja tamb&eacute;m <code>remlet</code>, que remove uma regra definida atrav&eacute;s de <code>let</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, &quot;+rule1&quot;);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, &quot;@@rule1&quot;);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tellsimp</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1201"></a>
</dt>
<dd><p>&eacute; similar a <code>tellsimpafter</code> mas coloca
nova informa&ccedil;&atilde;o antes da antiga de forma que essa nova regra seja aplicada antes das regras
de simplifica&ccedil;&atilde;o internas.
</p>
<p><code>tellsimp</code> &eacute; usada quando for importante modificar
a express&atilde;o antes que o simplificador trabalhe sobre ela, por exemplo se o
simplificador &quot;sabe&quot; alguma coisa sobre a express&atilde;o, mas o que ele retorna
n&atilde;o &eacute; para sua aprecia&ccedil;&atilde;o.
Se o simplificador &quot;sabe&quot; alguma coisa sobre o
principal operador da express&atilde;o, mas est&aacute; simplesmente escondendo de
voc&ecirc;, voc&ecirc; provavelmente quer usar <code>tellsimpafter</code>.
</p>
<p>O modelo pode n&atilde;o ser uma
adi&ccedil;&atilde;o, um produto, vari&aacute;vel simples, ou n&uacute;mero.
</p>
<p><code>rules</code> &eacute; a lista de regras definidas por
<code>defrule</code>, <code>defmatch</code>, <code>tellsimp</code>, e <code>tellsimpafter</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tellsimpafter</b><i> (<var>modelo</var>, <var>substitui&ccedil;&atilde;o</var>)</i>
<a name="IDX1202"></a>
</dt>
<dd><p>Define a uma regra de simplifica&ccedil;&atilde;o que o simplificador do Maxima
aplica ap&oacute;s as regras de simplifica&ccedil;&atilde;o internas.
<var>modelo</var> &eacute; uma express&atilde;o, compreendendo vari&aacute;veis de modelo (declaradas atrav&eacute;s de <code>matchdeclare</code>)
e outros &aacute;tomos e opera&ccedil;&otilde;es, considerados literais para o prop&oacute;sito de coincid&ecirc;ncia de modelos.
<var>substitui&ccedil;&atilde;o</var> &eacute; substitu&iacute;da para uma express&atilde;o atual que coincide com <var>modelo</var>;
vari&aacute;veis de modelo em <var>substitui&ccedil;&atilde;o</var> s&atilde;o atribuidas a valores coincidentes na express&atilde;o atual.
</p>
<p><var>modelo</var> pode ser qualquer express&atilde;o n&atilde;o at&ocirc;mica
na qual o principal operador n&atilde;o &eacute; uma vari&aacute;vel de modelo;
a regra de simplifica&ccedil;&atilde;o est&aacute; associada com o operador principal.
Os nomes de fun&ccedil;&otilde;es (com uma excess&atilde;o, descrita abaixo), listas, e arrays
podem aparecer em <var>modelo</var> como o principal operador somente como literais (n&atilde;o vari&aacute;veis de modelo);
essas regras fornecem express&otilde;es tais como <code>aa(x)</code> e <code>bb[y]</code> como modelos,
se <code>aa</code> e <code>bb</code> forem vari&aacute;veis de modelo.
Nomes de fun&ccedil;&otilde;es, listas, e arrays que s&atilde;o vari&aacute;veis de modelo podem aparecer como operadores
outros que n&atilde;o o operador principal em <var>modelo</var>.
</p>
<p>Existe uma excess&atilde;o para o que foi dito acima com rela&ccedil;&atilde;o a regras e nomes de fun&ccedil;&otilde;es.
O nome de uma fun&ccedil;&atilde;o subscrita em uma express&atilde;o tal como <code>aa[x](y)</code>
pode ser uma vari&aacute;vel de modelo,
porque o operador principal n&atilde;o &eacute; <code>aa</code> mas ao contr&aacute;rio o &aacute;tomo Lisp <code>mqapply</code>.
Isso &eacute; uma conseq&uuml;&ecirc;ncia da representa&ccedil;&atilde;o de express&otilde;es envolvendo fun&ccedil;&otilde;es subscritas.
</p>

<p>Regras de simplifica&ccedil;&atilde;o s&atilde;o aplicadas ap&oacute;s avalia&ccedil;&atilde;o 
(se n&atilde;o suprimida atrav&eacute;s de coloca&ccedil;&atilde;o de ap&oacute;strofo ou do sinalizador <code>noeval</code>).
Regras estabelecidas por <code>tellsimpafter</code> s&atilde;o aplicadas na ordem em que forem definidas,
e ap&oacute;s quaisquer regras internas.
Regras s&atilde;o aplicadas de baixo para cima, isto &eacute;,
aplicadas primeiro a subexpress&otilde;es antes de ser aplicada &agrave; express&atilde;o completa.
Isso pode ser necess&aacute;rio para repetidamente simplificar um resultado
(por exemplo, via o operador ap&oacute;strofo-ap&oacute;strofo <code>''</code> ou o sinalizador <code>infeval</code>)
para garantir que todas as regras s&atilde;o aplicadas.
</p>
<p>Vari&aacute;veis de modelo s&atilde;o tratadas como vari&aacute;veis locais em regras de simplifica&ccedil;&atilde;o.
Assim que uma regra &eacute; definida, o valor de uma vari&aacute;vel de modelo
n&atilde;o afeta a regra, e n&atilde;o &eacute; afetado pela regra.
Uma atribui&ccedil;&atilde;o para uma vari&aacute;vel de modelo que resulta em uma coincid&ecirc;ncia de regra com sucesso
n&atilde;o afeta a atribui&ccedil;&atilde;o corrente (ou necessita disso) da vari&aacute;vel de modelo.
Todavia,
como com todos os &aacute;tomos no Maxima,
as propriedades de vari&aacute;veis de modelo (como declarado por <code>put</code> e fun&ccedil;&otilde;es relacionadas) s&atilde;o globais.
</p>
<p>A regra constru&iacute;da por <code>tellsimpafter</code> &eacute; nomeada ap&oacute;s o operador principal de <code>modelo</code>.
Regras para operadores internos, 
e operadores definidos pelo usu&aacute;rio 
definidos por meio de <code>infix</code>, <code>prefix</code>, <code>postfix</code>, <code>matchfix</code>, e <code>nofix</code>,
possuem nomes que s&atilde;o seq&uuml;&ecirc;ncias de caracteres do Maxima.
Regras para outras fun&ccedil;&otilde;es possuem nomes que s&atilde;o identificadores comuns do Maxima.
</p>
<p>O tratamento de substantivos e formas verbais &eacute; desprez&iacute;velmente confuso. Se uma regra &eacute; definida para uma forma substantiva (ou verbal)
e uma regra para o verbo correspondente (ou substantivo) j&aacute; existe, 
ent&atilde;o a nova regra definida aplica-se a ambas as formas (substantiva e verbal).
Se uma regra para a correspondente forma verbal (ou substantiva) n&atilde;o existe,
a nova regra definida aplicar-se-&aacute; somente para a forma substantiva (ou verbal).
</p>
<p>A regra constru&iacute;da atrav&eacute;s de <code>tellsimpafter</code> &eacute; uma fun&ccedil;&atilde;o Lisp comum.
Se o nome da regra for <code>$foorule1</code>,
a constru&ccedil;&atilde;o <code>:lisp (trace $foorule1)</code> rastreia a fun&ccedil;&atilde;o,
e <code>:lisp (symbol-function '$foorule1</code> mostra sua defini&ccedil;&atilde;o.
</p>
<p><code>tellsimpafter</code> n&atilde;o avalia seus argumentos.
<code>tellsimpafter</code> retorna a lista de regras para o operador principal de <var>modelo</var>,
incluindo a mais recente regra estabelecia.
</p>
<p>Veja tamb&eacute;m <code>matchdeclare</code>, <code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>let</code>,
<code>kill</code>, <code>remrule</code>, e <code>clear_rules</code>.
</p>
<p>Exemplos:
</p>
<p><var>modelo</var> pode ser qualquer express&atilde;o n&atilde;o at&ocirc;mica na qual o 
principal operador n&atilde;o &eacute; uma vari&aacute;vel de modelo.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre>
<p>Regras s&atilde;o aplicadas na ordem em que forem definidas.
Se duas regras podem coincidir com uma express&atilde;o,
a regra que foi primeiro definida &eacute; a que ser&aacute; aplicada.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre>
<p>vari&aacute;veis de modelo s&atilde;o tratadas como vari&aacute;veis locais em regras de simplifica&ccedil;&atilde;o.
(Compare a <code>defmatch</code>, que trata vari&aacute;veis de modelo como vari&aacute;veis globais.)
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre>
<p>Como com todos os &aacute;tomos, propriedades de vari&aacute;veis de modelo s&atilde;o globais embora valores sejam locais.
Nesse exemplo, uma propriedade de atribui&ccedil;&atilde;o &eacute; declarada via <code>define_variable</code>.
Essa &eacute; a propriedade do &aacute;tomo <code>bb</code> atrav&eacute;s de todo o Maxima.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
<p>Regras s&atilde;o nomeadas ap&oacute;s operadores principais.
Nomes de regras para operadores internos e operadores definidos pelo usu&aacute;rio s&atilde;o seq&uuml;&ecirc;ncias de caracteres,
enquanto nomes para outras fun&ccedil;&otilde;es s&atilde;o identificadores comuns.
</p>
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4, 
htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1, 
foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
(%o10)                    [false, true]
(%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
(%o11)                    [true, true]
(%i12) remrule (foo, foorule1);
(%o12)                         foo
(%i13) remrule (&quot;^&quot;, &quot;^rule1&quot;);
(%o13)                          ^
</pre>
<p>Um exemplo trabalhado: multiplica&ccedil;&atilde;o anticomutativa.
</p>
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>clear_rules</b><i> ()</i>
<a name="IDX1203"></a>
</dt>
<dd><p>Executa <code>kill (rules)</code> e ent&atilde;o re-escolhe o pr&oacute;ximo n&uacute;mero de regra para 1
para adi&ccedil;&atilde;o <code>+</code>, multiplica&ccedil;&atilde;o <code>*</code>, e exponencia&ccedil;&atilde;o <code>^</code>.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC148" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC295" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Outubro, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
