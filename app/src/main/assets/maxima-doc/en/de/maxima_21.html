<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 21. Zahlentheorie</title>

<meta name="description" content="Maxima Manual: 21. Zahlentheorie">
<meta name="keywords" content="Maxima Manual: 21. Zahlentheorie">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Zahlentheorie"></a>
<a name="SEC160"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_20.html#SEC159" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC161" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 21. Zahlentheorie </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC161">21.1 Funktionen und Variablen der Zahlentheorie</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funktionen-und-Variablen-der-Zahlentheorie"></a>
<a name="SEC161"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC160" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC160" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC160" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.1 Funktionen und Variablen der Zahlentheorie </h2>

<p><a name="bern"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bern</b><i> (<var>n</var>)</i>
<a name="IDX1183"></a>
</dt>
<dd>
<p>Gibt die <var>n</var>-te Bernoulli-Zahl der ganzen Zahl <var>n</var> zur&uuml;ck. Hat die
Optionsvariable <code>zerobern</code> den Wert <code>false</code>, werden Bernoulli-Zahlen
unterdr&uuml;ckt, die Null sind.
</p>
<p>Siehe auch <code><a href="#burn">burn</a></code>.
</p>
<pre class="example">(%i1) zerobern: true$
(%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                  1  1       1      1        1
(%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                  2  6       30     42       30
(%i3) zerobern: false$
(%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
            1  1    1   5     691   7    3617  43867
(%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
            2  6    30  66    2730  6    510    798
</pre></dd></dl>

<p><a name="bernpoly"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bernpoly</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1184"></a>
</dt>
<dd>
<p>Gibt das <var>n</var>-te Bernoulli-Polynom in der Variablen <var>x</var> zur&uuml;ck.
</p></dd></dl>


<p><a name="bfzeta"></a>
</p><dl>
<dt><u>Function:</u> <b>bfzeta</b><i> (<var>s</var>, <var>n</var>)</i>
<a name="IDX1185"></a>
</dt>
<dd>
<p>Die Riemannsche Zeta-Funktion f&uuml;r das Argument <var>s</var>, die wie folgt 
definiert ist:
</p>
<pre class="example">                 inf
                 ====
                 \     1
     zeta(s) =    &gt;    --
                 /      s
                 ====  k
                 k = 1
</pre>
<p><code>bfzeta</code> gibt einen Wert als gro&szlig;e Gleitkommazahl zur&uuml;ck.  Die Anzahl 
der Stellen wird durch das Argument <var>n</var> angegeben.
</p>
<p>Anstatt der Funktion <code>bfzeta</code> ist die Funktion <code><a href="#zeta">zeta</a></code> zu bevorzugen,
die sowohl f&uuml;r reelle und komplexe Gleitkommazahlen und Gleitkommazahlen mit
eine beliebigen Genauigkeit die Riemannsche Zeta-Funktion berechnen kann.
</p></dd></dl>

<p><a name="bfhzeta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bfhzeta</b><i> (<var>s</var>, <var>h</var>, <var>n</var>)</i>
<a name="IDX1186"></a>
</dt>
<dd>

<p>Die Hurwitzsche Zeta-Funktion f&uuml;r die Argumente <var>s</var> und <var>h</var>, die wie
folgt definiert ist:
</p>
<pre class="example">                        inf
                        ====
                        \        1
         zeta (s,h)  =   &gt;    --------
                        /            s
                        ====  (k + h)
                        k = 0
</pre>
<p><code>bfhzeta</code> gibt einen Wert als gro&szlig;e Gleitkommazahl zur&uuml;ck.  Die 
Anzahl der Stellen wird durch das Argument <var>n</var> angegeben.
</p>
</dd></dl>

<p><a name="burn"></a>
</p><dl>
<dt><u>Funktion:</u> <b>burn</b><i> (<var>n</var>)</i>
<a name="IDX1187"></a>
</dt>
<dd>
<p>Gibt eine rational Zahl zur&uuml;ck, die eine N&auml;herung f&uuml;r die <var>n</var>-te 
Bernoulli Zahl f&uuml;r die ganze Zahl <var>n</var> ist.  <code>burn</code> berechnet eine 
N&auml;herung als gro&szlig;e Gleitkommatzahl mit der folgenden Beziehung:
</p>
<pre class="example">                   n - 1  1 - 2 n
              (- 1)      2        zeta(2 n) (2 n)!
     B(2 n) = ------------------------------------
                                2 n
                             %pi
</pre>

<p><code>burn</code> kann effizienter als die Funktion <code>bern</code> f&uuml;r gro&szlig;e, 
einzelne ganze Zahlen <var>n</var> sein, da <code>bern</code> zun&auml;chst alle Bernoulli 
Zahlen bis <var>n</var> berechnet.  <code>burn</code> ruft f&uuml;r ungerade ganze Zahlen und 
Zahlen die kleiner oder gleich 255 die Funktion <code>bern</code> auf.
</p>

<p>Das Kommando <code>load(bffac)</code> l&auml;dt die Funktion.  Siehe auch <code><a href="#bern">bern</a></code>.
</p></dd></dl>

<p><a name="chinese"></a>
</p><dl>
<dt><u>Funktion:</u> <b>chinese</b><i> ([<var>r_1</var>, &hellip;, <var>r_n</var>], [<var>m_1</var>, &hellip;, <var>m_n</var>])</i>
<a name="IDX1188"></a>
</dt>
<dd><p>L&ouml;st die simultanen Kongruenzen <code>x = r_1 mod m_1</code>, &hellip;, <code>x = r_n mod m_n</code>.
Die Reste <var>r_n</var> und die Moduli <var>m_n</var> m&uuml;ssen ganze Zahlen sein, 
die Moduli zus&auml;tzlich positiv und paarweise teilerfremd.
</p>
<pre class="example">(%i1) mods : [1000, 1001, 1003, 1007];
(%o1)                   [1000, 1001, 1003, 1007]
(%i2) lreduce('gcd, mods);
(%o2)                               1
(%i3) x : random(apply(&quot;*&quot;, mods));
(%o3)                         685124877004
(%i4) rems : map(lambda([z], mod(x, z)), mods);
(%o4)                       [4, 568, 54, 624]
(%i5) chinese(rems, mods);
(%o5)                         685124877004
(%i6) chinese([1, 2], [3, n]);
(%o6)                    chinese([1, 2], [3, n])
(%i7) %, n = 4;
(%o7)                              10
</pre></dd></dl>

<p><a name="divsum"></a>
</p><dl>
<dt><u>Funktion:</u> <b>divsum</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1189"></a>
</dt>
<dt><u>Funktion:</u> <b>divsum</b><i> (<var>n</var>)</i>
<a name="IDX1190"></a>
</dt>
<dd>
<p><code>divsum(<var>n</var>, <var>k</var>)</code> potenziert die Teiler des Argumentes <var>n</var> 
mit dem Argument <var>k</var> und gibt die Summe als Ergebnis zur&uuml;ck.
</p>

<p><code>divsum(<var>n</var>)</code> gibt die Summe der Teiler der Zahl <var>n</var> zur&uuml;ck.
</p>
<pre class="example">(%i1) divsum (12);
(%o1)                          28
(%i2) 1 + 2 + 3 + 4 + 6 + 12;
(%o2)                          28
(%i3) divsum (12, 2);
(%o3)                          210
(%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
(%o4)                          210
</pre></dd></dl>

<p><a name="euler"></a>
</p><dl>
<dt><u>Funktion:</u> <b>euler</b><i> (<var>n</var>)</i>
<a name="IDX1191"></a>
</dt>
<dd>
<p>Gibt die <var>n</var>-te Eulersche Zahl f&uuml;r eine nichtnegative ganze Zahl <var>n</var>
zur&uuml;ck.
</p>

<p>F&uuml;r die Euler-Mascheroni Konstante siehe <code><a href="maxima_5.html#g_t_0025gamma">%gamma</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]
</pre></dd></dl>

<p><a name="factors_005fonly"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>factors_only</b>
<a name="IDX1192"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>Hat <code>factors_only</code> den Standardwert <code>false</code>, werden von der 
Funktion <code><a href="#ifactors">ifactors</a></code> zusammen mit den berechneten Primfaktoren auch deren 
Multiplizit&auml;ten angegeben. Hat <code>factors_only</code> den Wert <code>true</code>, 
werden nur die Primfaktoren zur&uuml;ck gegeben.
</p>
<p>Beispiel: Siehe <code><a href="#ifactors">ifactors</a></code>.
</p></dd></dl>

<p><a name="fib"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fib</b><i> (<var>n</var>)</i>
<a name="IDX1193"></a>
</dt>
<dd><p>Gibt die <var>n</var>-te Fibonacci-Zahl zur&uuml;ck.  Die Fibonacci-Folge ist rekursiv 
definiert:
</p>
<pre class="example">   fib(0) = 0
   fib(1) = 1
   fib(n) = fib(n-1) + fib(n-2)
</pre>
<p>F&uuml;r negative ganze Zahlen kann die Fibonacci-Folge wie folgt erweitert werden:
</p>
<pre class="example">                   n + 1
   fib(- n) = (- 1)      fib(n)
</pre>



<p>Nach einem Aufruf der Funktion <code>fib(n)</code>, enth&auml;lt die Systemvariable 
<code>prevfib</code> die zur Zahl <code>n</code> vorhergehende Fibonacci-Zahl.
</p>
<pre class="example">(%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</pre></dd></dl>

<p><a name="fibtophi"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fibtophi</b><i> (<var>expr</var>)</i>
<a name="IDX1194"></a>
</dt>
<dd>
<p>Fibonacci-Zahlen im Ausdruck <var>expr</var> werden durch die Goldene Zahl 
<code>%phi</code> ausgedr&uuml;ckt.  Siehe <code><a href="maxima_5.html#g_t_0025phi">%phi</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) fibtophi (fib (n));
                           n             n
                       %phi  - (1 - %phi)
(%o1)                  -------------------
                           2 %phi - 1
(%i2) fib (n-1) + fib (n) - fib (n+1);
(%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
(%i3) fibtophi (%);
            n + 1             n + 1       n             n
        %phi      - (1 - %phi)        %phi  - (1 - %phi)
(%o3) - --------------------------- + -------------------
                2 %phi - 1                2 %phi - 1
                                          n - 1             n - 1
                                      %phi      - (1 - %phi)
                                    + ---------------------------
                                              2 %phi - 1
(%i4) ratsimp (%);
(%o4)                           0
</pre></dd></dl>

<p><a name="ifactors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ifactors</b><i> (<var>n</var>)</i>
<a name="IDX1195"></a>
</dt>
<dd><p>Faktorisiert eine positive ganze Zahl <var>n</var>.  Sind <code>n = p1^e1 * ... * pk^nk</code> die
Faktoren der ganzen Zahl <var>n</var>, dann gibt <code>ifactor</code> das Ergebnis
<code>[[p1, e1], ..., [pk, ek]]</code> zur&uuml;ck.
</p>
<p>F&uuml;r die Faktorisierung kommen Probedivisionen mit Primzahlen bis 9973, 
Pollards Rho- und p-1-Methode oder Elliptischen Kurven zum Einsatz.
</p>
<p>Die R&uuml;ckgabe von ifactors wird von der Optionsvariablen <code><a href="#factors_005fonly">factors_only</a></code>  
beeinflusst. 
Werden lediglich die Primfaktoren ohne ihre Multiplizit&auml;t ben&ouml;tigt, 
gen&uuml;gt es hierf&uuml;r, <code>factors_only : true</code> zu setzen.
</p>
<pre class="example">(%i1) ifactors(51575319651600);
(%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
(%i2) apply(&quot;*&quot;, map(lambda([u], u[1]^u[2]), %));
(%o2)                        51575319651600
(%i3) ifactors(51575319651600), factors_only : true;
(%o3)                   [2, 3, 5, 1583, 9050207]
</pre></dd></dl>

<p><a name="igcdex"></a>
</p><dl>
<dt><u>Funktion:</u> <b>igcdex</b><i> (<var>n</var>, <var>k</var>)</i>
<a name="IDX1196"></a>
</dt>
<dd><p>Gibt die Liste <code>[a, b, u]</code> zur&uuml;ck, in der <code>u</code> der 
gr&ouml;&szlig;te gemeinsame Teiler von <var>n</var> und <var>k</var> ist und in der zus&auml;tzlich 
gilt, dass <code>u = a * <var>n</var> + b * <var>k</var></code>. 
</p>
<p><code>igcdex</code> verwendet den Euklidischen Algorithmus.  Siehe auch <code><a href="maxima_17.html#gcdex">gcdex</a></code>.
</p>
<p>Die Eingabe <code>load(gcdex)</code> l&auml;dt diese Funktion.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(gcdex)$

(%i2) igcdex(30, 18);
(%o2)                      [- 1, 2, 6]
(%i3) igcdex(1526757668, 7835626735736);
(%o3)            [845922341123, - 164826435, 4]
(%i4) igcdex(fib(20), fib(21));
(%o4)                   [4181, - 2584, 1]
</pre></dd></dl>

<p><a name="inrt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>inrt</b><i> (<var>x</var>, <var>n</var>)</i>
<a name="IDX1197"></a>
</dt>
<dd>
<p>Gibt die ganzzahlige <var>n</var>-te Wurzel des Betrags von <var>x</var> zur&uuml;ck.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], inrt (10^a, 3)), l);
(%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]
</pre></dd></dl>

<p><a name="inv_005fmod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>inv_mod</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1198"></a>
</dt>
<dd><p>Berechnet das modulare Inverse von <var>n</var> zum Modul <var>m</var>.  Das Argument
<var>n</var> muss eine ganze Zahl und der Modul <var>p</var> eine positive ganze Zahl 
sein.  <code>inv_mod(n, m)</code> gibt <code>false</code> zur&uuml;ck, wenn das modulare Inverse
nicht existiert.  Das modulare Inverse existiert, wenn <var>n</var> teilerfremd zum 
Modul <var>m</var> ist.
</p>
<p>Siehe auch die Funktionen <code><a href="#power_005fmod">power_mod</a></code> und <code><a href="#mod">mod</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) inv_mod(3, 41);
(%o1)                           14
(%i2) ratsimp(3^-1), modulus = 41;
(%o2)                           14
(%i3) inv_mod(3, 42);
(%o3)                          false
</pre></dd></dl>

<p><a name="isqrt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>isqrt</b><i> (<var>x</var>)</i>
<a name="IDX1199"></a>
</dt>
<dd>
<p>Gibt die ganzzahlige Wurzel des Betrages von <var>x</var> zur&uuml;ck, wenn <var>x</var> eine
ganze Zahl ist.  Andernfalls wird eine Substantivform zur&uuml;ckgegeben.
</p></dd></dl>

<p><a name="jacobi"></a>
</p><dl>
<dt><u>Funktion:</u> <b>jacobi</b><i> (<var>p</var>, <var>q</var>)</i>
<a name="IDX1200"></a>
</dt>
<dd>
<p>Berechnet das Jacobi-Symbol f&uuml;r die Argumente <var>p</var> und <var>q</var>.
</p>
<pre class="example">(%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
(%i2) map (lambda ([a], jacobi (a, 9)), l);
(%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]
</pre></dd></dl>

<p><a name="lcm"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lcm</b><i> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1201"></a>
</dt>
<dd>
<p>Gibt das kleinste gemeinsame Vielfache der Argumente zur&uuml;ck.  Die Argumente 
k&ouml;nnen ganze Zahlen und allgemeine Ausdr&uuml;cke sein.
</p>

<p>Mit dem Kommando <code>load(functs)</code> wird die Funktion geladen.
</p></dd></dl>

<p><a name="lucas"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lucas</b><i> (<var>n</var>)</i>
<a name="IDX1202"></a>
</dt>
<dd><p>Gibt die <var>n</var>-te Lucas-Zahl zur&uuml;ck.  Die Lucas-Folge ist rekursiv 
definiert:
</p>
<pre class="example">   lucas(0) = 0
   lucas(1) = 1
   lucas(n) = lucas(n-1) + lucas(n-2)
</pre>
<p>F&uuml;r negative ganze Zahlen kann die Lucas-Folge wie folgt erweitert werden:
</p>
<pre class="example">                     -n
   lucas(- n) = (- 1)   lucas(n)
</pre>

<pre class="example">(%i1) map (lucas, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
(%o1)             [7, - 4, 3, - 1, 2, 1, 3, 4, 7, 11, 18, 29, 47]
</pre>
<p>Nach einem Aufruf von <code>lucas</code> enth&auml;lt die globale Variable 
<code>next_lucas</code> den Nachfolger der zuletzt zurc"k gegebenen Lucas-Zahl.
Das Beispiel zeigt, wie Fibonacci-Zahlen mit Hilfe von <code>lucas</code> 
und <code>next_lucas</code> berechnet werden k&ouml;nnen.
</p>
<pre class="example">(%i1) fib_via_lucas(n) := 
         block([lucas : lucas(n)],
         signum(n) * (2*next_lucas - lucas)/5 )$
(%i2) map (fib_via_lucas, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
(%o2)             [- 3, 2, - 1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21]
</pre></dd></dl>

<p><a name="mod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>mod</b><i> (<var>x</var>, <var>p</var>)</i>
<a name="IDX1203"></a>
</dt>
<dd>
<p>Berechnet den Divisionsrest <code>x mod y</code> des Arguments <var>x</var> zum Modul <var>y</var>. 
<var>x</var> und <var>y</var> k&ouml;nnen ganze Zahlen, rationale Zahlen, Gleitkommazahlen 
oder allgemeine Ausdr&uuml;cke sein.
</p>
<p>Sind <var>x</var> und <var>y</var> reelle Zahlen und ist <var>y</var> ungleich Null, gibt 
<code>mod(<var>x</var>, <var>y</var>)</code> das Ergebnis von <code><var>x</var> - <var>y</var> * 
floor(<var>x</var> / <var>y</var>)</code> zur&uuml;ck.  Weiterhin gilt f&uuml;r alle reellen Zahlen
<code>mod(<var>x</var>, 0) = <var>x</var></code>.  F&uuml;r eine Diskussion dieser Definition siehe
Kapitel 3.4, &quot;Concrete Mathematics&quot; von Graham, Knuth, and Patashnik.  Die 
Funktion <code>mod(<var>x</var>, 1)</code> ist eine S&auml;gezahnfunktion mit der Periode 1 
mit <code>mod(1, 1) = 0</code> und <code>mod(0, 1) = 0</code>.
</p>

<p>Der Hauptwert einer komplexen Zahl, die im Intervall <code>(-%pi, %pi)</code> liegt,
kann mit <code>%pi - mod(%pi - <var>x</var>, 2*%pi)</code> bestimmt werden, wobei <var>x</var>
die komplexe Zahl ist.
</p>

<p>Sind <var>x</var> und <var>y</var> konstante Ausdr&uuml;cke, wie zum Beispiel <code>10 * %pi</code>,
verwendet <code>mod</code> dasselbe <code><a href="maxima_5.html#bfloat">bfloat</a></code>-Auswertungsschema wie <code>floor</code> 
und <code>ceiling</code>. Diese Umwandlung kann, wenn auch unwahrscheinlich, 
zu Fehlern f&uuml;hren.
</p>

<p>F&uuml;r nicht numerische Argumente <var>x</var> oder <var>y</var> kennt <code>mod</code>
verschiedene Vereinfachungen.
</p>
<p>Siehe auch die Funktionen <code><a href="#power_005fmod">power_mod</a></code> und <code><a href="#inv_005fmod">inv_mod</a></code>.
</p>
<p>Beispiele:
</p>
<p>Zeige f&uuml;r zwei gro&szlig;e ganze Zahlen, dass f&uuml;r das modulare Rechnen die 
Regel <code>mod(a+b, m) = mod(mod(a, m) + mod(b, m), m)</code> gilt.
</p>
<pre class="example">(%i1) a : random(10^20) + 10^19;
(%o1)                 72588919020045581148
(%i2) b : random(10^20) + 10^19;
(%o2)                 35463666253140008825
(%i3) m : random(10^20) + 10^19;
(%o3)                 39127433614020247557
(%i4) mod(a+b, m);
(%o4)                 29797718045145094859
(%i5) mod(mod(a, m) + mod(b, m), m);
(%o5)                 29797718045145094859
</pre>
<p>Vereinfachung f&uuml;r nicht numerische Argumente.
</p>
<pre class="example">(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
</pre></dd></dl>

<p><a name="next_005fprime"></a>
</p><dl>
<dt><u>Funktion:</u> <b>next_prime</b><i> (<var>n</var>)</i>
<a name="IDX1204"></a>
</dt>
<dd>
<p>Gibt die kleinste Primzahl zur&uuml;ck, die der Zahl <var>n</var> folgt.
</p>
<pre class="example">(%i1) next_prime(27);
(%o1)                       29
</pre></dd></dl>

<p><a name="power_005fmod"></a>
</p><dl>
<dt><u>Funktion:</u> <b>power_mod</b><i> (<var>a</var>, <var>n</var>, <var>m</var>)</i>
<a name="IDX1205"></a>
</dt>
<dd><p>Verwendet einen modularen Algorithmus, um <code>a^n mod m</code> zu berechnen. 
Die Argumente <var>a</var> und <var>n</var> m&uuml;ssen ganze Zahlen und der Modul <var>m</var> 
eine positive ganze Zahl sein.  Ist <var>n</var> negativ, wird <code><a href="#inv_005fmod">inv_mod</a></code> zur 
Berechnung des modularen Inversen aufgerufen.
</p>
<p><code>power_mod (<var>a</var>, <var>n</var>, <var>m</var>)</code> ist &auml;quivalent zu 
<code>mod(a^n, m)</code>.  Der Algorithmus von <code>power_mod</code> ist jedoch 
insbesondere f&uuml;r gro&szlig;e ganze Zahlen wesentlich effizienter.
</p>
<p>Siehe auch die Funktionen <code><a href="#inv_005fmod">inv_mod</a></code> und <code><a href="#mod">mod</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>power_mod(a, n, m)</code> ist &auml;quivalent zu <code>mod(a^n, m</code>.  Das modulare
Inverse wird mit der Funktion <code>inv_mod</code> berechnet.
</p>
<pre class="example">(%i1) power_mod(3, 15, 5);
(%o1)                          2
(%i2) mod(3^15, 5);
(%o2)                          2
(%i3) power_mod(2, -1, 5);
(%o3)                          3
(%i4) inv_mod(2, 5);
(%o4)                          3
</pre>
<p>F&uuml;r gro&szlig;e ganze Zahlen ist <code>power_mod</code> effizienter.  Der folgende 
Wert kann in keiner vern&uuml;nftigen Zeit mit <code>mod(a^n, m)</code> berechnet
werden.
</p>
<pre class="example">(%i1) power_mod(123456789, 123456789, 987654321);
(%o1)                       598987215
</pre></dd></dl>

<p><a name="primep"></a>
</p><dl>
<dt><u>Funktion:</u> <b>primep</b><i> (<var>n</var>)</i>
<a name="IDX1206"></a>
</dt>
<dd><p>F&uuml;hrt einen Primzahltest f&uuml;r das Argument <var>n</var> durch.  Liefert
<code>primep</code> das Ergebnis <code>false</code>, ist <var>n</var> keine Primzahl.  Ist das
Ergebnis <code>true</code>, ist <var>n</var> mit sehr gro&szlig;er Wahrscheinlichkeit eine 
Primzahl.
</p>
<p>F&uuml;r ganze Zahlen <var>n</var> kleiner als 341550071728321 wird eine deterministische
Variante des Miller-Rabin-Tests angewandt.  Hat in diesem Fall <code>primep</code> den Wert
<code>true</code>, dann ist <var>n</var> mit Sicherheit eine Primzahl.
</p>
<p>F&uuml;r ganze Zahlen <var>n</var> gr&ouml;&szlig;er 341550071728321 f&uuml;hrt <code>primep</code>
<code><a href="#primep_005fnumber_005fof_005ftests">primep_number_of_tests</a></code> Pseudo-Primzahl-Tests nach Miller-Rabin und 
einen Pseudo-Primzahl-Test nach Lucas durch.  Die Wahrscheinlichkeit, dass 
eine zusammen gesetzte Zahl <var>n</var> einen Miller-Rabin-Test besteht, ist kleiner
als 1/4.  Mit dem Standardwert 25 <code>primpe_number_of_tests</code> sinkt diese 
Wahrscheinlichkeit damit unter einen Wert von 10^-15.
</p></dd></dl>

<p><a name="primep_005fnumber_005fof_005ftests"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>primep_number_of_tests</b>
<a name="IDX1207"></a>
</dt>
<dd><p>Standardwert: 25
</p>

<p>Die Anzahl der Pseudo-Primzahl-Tests nach Miller-Rabin in der Funktion 
<code><a href="#primep">primep</a></code>.
</p></dd></dl>

<p><a name="primes"></a>
</p><dl>
<dt><u>Funktion:</u> <b>primes</b><i> (<var>start</var>, <var>end</var>)</i>
<a name="IDX1208"></a>
</dt>
<dd><p>Gibt eine Liste mit allen Primzahlen von <var>start</var> bis <var>end</var> zur&uuml;ck.
</p>
<pre class="example">(%i1) primes(3, 7);
(%o1)                     [3, 5, 7]
</pre></dd></dl>

<p><a name="prev_005fprime"></a>
</p><dl>
<dt><u>Funktion:</u> <b>prev_prime</b><i> (<var>n</var>)</i>
<a name="IDX1209"></a>
</dt>
<dd>
<p>Gibt die gr&ouml;&szlig;te Primzahl zur&uuml;ck, die kleiner als die Zahl <var>n</var> ist.
</p>
<pre class="example">(%i1) prev_prime(27);
(%o1)                       23
</pre></dd></dl>

<p><a name="qunit"></a>
</p><dl>
<dt><u>Funktion:</u> <b>qunit</b><i> (<var>n</var>)</i>
<a name="IDX1210"></a>
</dt>
<dd>
<p>Findet f&uuml;r das Argument <var>n</var> L&ouml;sungen der Pellschen Gleichung 
<code>a^2 - <var>n</var> b^2 = 1</code>.
</p>
<pre class="example">(%i1) qunit (17);
(%o1)                     sqrt(17) + 4
(%i2) expand (% * (sqrt(17) - 4));
(%o2)                           1
</pre></dd></dl>

<p><a name="totient"></a>
</p><dl>
<dt><u>Funktion:</u> <b>totient</b><i> (<var>n</var>)</i>
<a name="IDX1211"></a>
</dt>
<dd><p>Gibt die Anzahl der ganzen Zahlen zur&uuml;ck, die kleiner oder gleich <var>n</var>
und teilerfremd zu <var>n</var> sind.
</p></dd></dl>

<p><a name="zerobern"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zerobern</b>
<a name="IDX1212"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>zerobern</code> den Wert <code>false</code>, werden von den Funktionen <code>bern</code>
diejenigen Bernoulli-Zahlen und von <code>euler</code> diejenigen Euler-Zahlen 
ausgeschlossen, die gleich Null sind.  Siehe <code><a href="#bern">bern</a></code> und <code><a href="#euler">euler</a></code>.
</p></dd></dl>

<p><a name="zeta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zeta</b><i> (<var>n</var>)</i>
<a name="IDX1213"></a>
</dt>
<dd>
<p>Die Riemannsche Zeta-Funktion f&uuml;r <var>s</var>, die wie folgt definiert ist:
</p>
<pre class="example">                 inf
                 ====
                 \     1
     zeta(s) =    &gt;    --
                 /      s
                 ====  k
                 k = 1
</pre>
<p>F&uuml;r negative ganze Zahlen <var>n</var>, Null und positive gerade ganze Zahlen 
wird <code>zeta</code> zu einem exakten Ergebnis vereinfacht.  
Damit diese Vereinfachung f&uuml;r positive ganze Zahlen ausgef&uuml;hrt wird, 
muss die Optionsvariable <code>zeta%pi</code> den Wert <code>true</code> haben.  
Siehe <code><a href="#zeta_0025pi">zeta%pi</a></code>. F&uuml;r einfache und beliebig genaue Gleitkommazahlen 
(Typ <code>bfloat</code>) hat <code>zeta</code> ein numerisches Ergebnis.  
F&uuml;r alle anderen Argumente einschlie&szlig;lich der komplexen und 
rationalen Zahlen gibt <code>zeta</code> eine Substantivform zur&uuml;ck.  Hat die 
Optionsvariable <code>zeta%pi</code> den Wert <code>false</code>, gibt <code>zeta</code> auch 
f&uuml;r gerade ganze Zahlen eine Substantivform zur&uuml;ck.
</p>

<p><code>zeta(1)</code> ist nicht definiert.  Maxima kennt jedoch die einseitigen
Grenzwerte <code>limit(zeta(x), x, 1, plus</code> und 
<code>limit(zeta(x), x, 1, minus</code>.
</p>

<p>Die Riemannsche Zeta-Funktion wird auf die Argumente von Listen, Matrizen und 
Gleichungen angewendet, wenn die Optionsvariable <code>distribute_over</code>
den Wert <code>true</code> hat.
</p>

<p>Siehe auch <code><a href="#bfzeta">bfzeta</a></code> und <code><a href="#zeta_0025pi">zeta%pi</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) zeta([-2,-1,0,0.5,2,3,1+%i]);
                                             2
            1     1                       %pi
(%o1) [0, - --, - -, - 1.460354508809586, ----, zeta(3), 
            12    2                        6
                                                    zeta(%i + 1)]
(%i2) limit(zeta(x),x,1,plus);
(%o2)                          inf
(%i3) limit(zeta(x),x,1,minus);
(%o3)                         minf
</pre></dd></dl>

<p><a name="zeta_0025pi"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zeta%pi</b>
<a name="IDX1214"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>zeta%pi</code> den Wert <code>true</code>, vereinfacht die Funktion <code>zeta(n)</code>
f&uuml;r gerade ganzen Zahlen <var>n</var> zu einem Ergebnis, das proportional zu 
<code>%pi^n</code> ist.  Ansonsten ist das Ergebnis von <code>zeta</code> eine 
Substantivform f&uuml;r gerade ganze Zahlen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) zeta%pi: true$
(%i2) zeta (4);
                                 4
                              %pi
(%o2)                         ----
                               90
(%i3) zeta%pi: false$
(%i4) zeta (4);
(%o4)                        zeta(4)
</pre></dd></dl>

<p><a name="zn_005fadd_005ftable"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_add_table</b><i> (<var>n</var>) </i>
<a name="IDX1215"></a>
</dt>
<dd><p>zeigt eine Additionstabelle von allen Elementen in (Z/<var>n</var>Z).
</p>
<p>Siehe auch <code><a href="#zn_005fmult_005ftable">zn_mult_table</a></code>, <code><a href="#zn_005fpower_005ftable">zn_power_table</a></code>.
</p></dd></dl>

<p><a name="zn_005fcharacteristic_005ffactors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_characteristic_factors</b><i> (<var>n</var>) </i>
<a name="IDX1216"></a>
</dt>
<dd><p>Gibt eine Liste mit den charakteristischen Faktoren des Totienten von <var>n</var> zur&uuml;ck.
</p>
<p>Mit Hilfe der charakteristischen Faktoren kann eine modulo <var>n</var> multiplikative Gruppe 
als direktes Produkt zyklischer Untergruppen dargestellt werden. 
</p>
<p>Ist die Gruppe selbst zyklisch, dann enth&auml;lt die Liste nur den Totienten 
und mit <code>zn_primroot</code> kann ein Generator berechnet werden. 
Zerf&auml;llt der Totient in mehrere charakteristische Faktoren, 
k&ouml;nnen Generatoren der entsprechenden Untergruppen mit <code>zn_factor_generators</code> 
ermittelt werden.
</p>
<p>Jeder der <code>r</code> Faktoren in der Liste teilt die weiter rechts stehenden Faktoren. 
Fuer den letzten Faktor <code>f_r</code> gilt daher <code>a^f_r = 1 (mod n)</code> 
f&uuml;r alle <code>a</code> teilerfremd zu <var>n</var>. 
Dieser Faktor ist auch als Carmichael Funktion bzw. Carmichael Lambda bekannt.
</p>
<p>F&uuml;r <code>n &gt; 2</code> ist <code>totient(n)/2^r</code> die Anzahl der quadratischen Reste 
in der Gruppe und jeder dieser Reste hat <code>2^r</code> Wurzeln.
</p>
<p>Siehe auch <code><a href="#totient">totient</a></code>, <code><a href="#zn_005fprimroot">zn_primroot</a></code>, <code><a href="#zn_005ffactor_005fgenerators">zn_factor_generators</a></code>.
</p>
<p>Beispiele:
</p>
<p>Die multiplikative Gruppe modulo <code>14</code> ist zyklisch und ihre <code>6</code> Elemente 
lassen sich durch eine Primitivwurzel erzeugen.
</p>
<pre class="example">(%i1) [zn_characteristic_factors(14), phi: totient(14)];
(%o1)                              [[6], 6]
(%i2) [zn_factor_generators(14), g: zn_primroot(14)];
(%o2)                              [[3], 3]
(%i3) M14: makelist(power_mod(g,i,14), i,0,phi-1);
(%o3)                         [1, 3, 9, 13, 11, 5]
</pre>
<p>Die multiplikative Gruppe modulo <code>15</code> ist nicht zyklisch und ihre <code>8</code> Elemente 
lassen sich mit Hilfe zweier Faktorgeneratoren erzeugen.
</p>
<pre class="example">(%i1) [[f1,f2]: zn_characteristic_factors(15), totient(15)];
(%o1)                             [[2, 4], 8]
(%i2) [[g1,g2]: zn_factor_generators(15), zn_primroot(15)];
(%o2)                           [[11, 7], false]
(%i3) UG1: makelist(power_mod(g1,i,15), i,0,f1-1);
(%o3)                               [1, 11]
(%i4) UG2: makelist(power_mod(g2,i,15), i,0,f2-1);
(%o4)                            [1, 7, 4, 13]
(%i5) M15: create_list(mod(i*j,15), i,UG1, j,UG2);
(%o5)                      [1, 7, 4, 13, 11, 2, 14, 8]
</pre>
<p>F&uuml;r den letzten charakteristischen Faktor <code>4</code> gilt 
<code>a^4 = 1 (mod 15)</code> fuer alle <code>a</code> in <code>M15</code>. 
</p>
<p><code>M15</code> hat <code>2</code> charakteristische Faktoren und daher die <code>8/2^2</code> 
quadratischen Reste <code>1</code> und <code>4</code>, und diese haben jeweils <code>2^2</code> Wurzeln.
</p>
<pre class="example">(%i6) zn_power_table(15);
                               [ 1   1  1   1 ]
                               [              ]
                               [ 2   4  8   1 ]
                               [              ]
                               [ 4   1  4   1 ]
                               [              ]
                               [ 7   4  13  1 ]
(%o6)                          [              ]
                               [ 8   4  2   1 ]
                               [              ]
                               [ 11  1  11  1 ]
                               [              ]
                               [ 13  4  7   1 ]
                               [              ]
                               [ 14  1  14  1 ]
(%i7) map(lambda([i], zn_nth_root(i,2,15)), [1,4]);
(%o7)                   [[1, 4, 11, 14], [2, 7, 8, 13]]
</pre></dd></dl>

<p><a name="zn_005fcarmichael_005flambda"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_carmichael_lambda</b><i> (<var>n</var>) </i>
<a name="IDX1217"></a>
</dt>
<dd><p>Gibt <code>1</code> zur&uuml;ck, wenn <var>n</var> gleich <code>1</code> ist und andernfalls 
den gr&ouml;&szlig;ten charakteristischen Faktor des Totienten von <var>n</var>. 
</p>
<p>F&uuml;r Erl&auml;uterungen und Beispiele siehe <code><a href="#zn_005fcharacteristic_005ffactors">zn_characteristic_factors</a></code>.
</p>
</dd></dl>

<p><a name="zn_005fdeterminant"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_determinant</b><i> (<var>matrix</var>, <var>p</var>) </i>
<a name="IDX1218"></a>
</dt>
<dd><p>verwendet die Technik der LR-Dekomposition, um die Determinante der 
Matrix <var>matrix</var> &uuml;ber (Z/<var>p</var>Z) zu berechnen, wobei <var>p</var> 
eine Primzahl sein muss. 
</p>
<p>Ist die Determinante nicht von Null verschieden, kann es sein, dass die 
LR-Dekomposition nicht m&ouml;glich ist. <code>zn_determinant</code> berechnet 
diesem Fall die Determinante nicht-modular und reduziert im Nachhinein.
</p>
<p>Siehe auch <code><a href="#zn_005finvert_005fby_005flu">zn_invert_by_lu</a></code>.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) m : matrix([1,3],[2,4]);
                                [ 1  3 ]
(%o1)                           [      ]
                                [ 2  4 ]
(%i2) zn_determinant(m, 5);
(%o2)                               3
(%i3) m : matrix([2,4,1],[3,1,4],[4,3,2]);
                               [ 2  4  1 ]
                               [         ]
(%o3)                          [ 3  1  4 ]
                               [         ]
                               [ 4  3  2 ]
(%i4) zn_determinant(m, 5);
(%o4)                               0
</pre></dd></dl>

<p><a name="zn_005ffactor_005fgenerators"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_factor_generators</b><i> (<var>n</var>) </i>
<a name="IDX1219"></a>
</dt>
<dd><p>Gibt eine Liste mit Faktorgeneratoren zur&uuml;ck, die zu den charakteristischen 
Faktoren des Totienten von <var>n</var> passen. 
</p>
<p>F&uuml;r Erl&auml;uterungen und Beispiele siehe <code><a href="#zn_005fcharacteristic_005ffactors">zn_characteristic_factors</a></code>.
</p>
</dd></dl>

<p><a name="zn_005finvert_005fby_005flu"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_invert_by_lu</b><i> (<var>matrix</var>, <var>p</var>) </i>
<a name="IDX1220"></a>
</dt>
<dd><p>verwendet die Technik der LR-Dekomposition, um ein modulares Inverses der 
Matrix <var>matrix</var> &uuml;ber (Z/<var>p</var>Z) zu berechnen. Voraussetzung ist, 
dass <var>matrix</var> invertierbar und <var>p</var> eine Primzahl ist. 
Sollte <var>matrix</var> nicht invertierbar sein, gibt <code>zn_invert_by_lu</code> 
<code>false</code> zurc"k.
</p>
<p>Siehe auch <code><a href="#zn_005fdeterminant">zn_determinant</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) m : matrix([1,3],[2,4]);
                                [ 1  3 ]
(%o1)                           [      ]
                                [ 2  4 ]
(%i2) zn_determinant(m, 5);
(%o2)                               3
(%i3) mi : zn_invert_by_lu(m, 5);
                                [ 3  4 ]
(%o3)                           [      ]
                                [ 1  2 ]
(%i4) matrixmap(lambda([a], mod(a, 5)), m . mi);
                                [ 1  0 ]
(%o4)                           [      ]
                                [ 0  1 ]
</pre></dd></dl>

<p><a name="zn_005flog"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>) </i>
<a name="IDX1221"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_log</b><i> (<var>a</var>, <var>g</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1222"></a>
</dt>
<dd><p>Berechnet den diskreten Logarithmus.  Sei (Z/<var>n</var>Z)* eine zyklische Gruppe, 
<var>g</var> eine Primitivwurzel modulo <var>n</var> und <var>a</var> ein Element dieser Gruppe.
Dann berechnet <code>zn_log (a, g, n)</code> eine L&ouml;sung der Kongruenz 
<code>g^x = a mod n</code>.
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Da diese Berechnung ebenfalls zeitaufw&auml;ndig ist, kann es eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_log</code> als 
viertes Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe von 
<code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Als Algorithmus wird die Pohlig-Hellman-Reduktion und das Rho-Verfahren von 
Pollard f&uuml;r den diskreten Logarithmus verwendet. Die Laufzeit von <code>zn_log</code> 
h&auml;ngt im Wesentlichen von der Bitl&auml;nge des gr&ouml;&szlig;ten Primfaktors des 
Totienten von <var>n</var> ab. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>, <code><a href="#zn_005forder">zn_order</a></code>, <code><a href="#ifactors">ifactors</a></code>, <code><a href="#totient">totient</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>zn_log (a, g, n)</code> findet eine L&ouml;sung der Kongruenz <code>g^x = a mod n</code>.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) ord_7 : zn_order(7, n);
(%o3)                              10
(%i4) powers_7 : makelist(power_mod(g, x, n), x, 0, ord_7 - 1);
(%o4)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i5) zn_log(21, g, n);
(%o5)                               5
(%i6) map(lambda([x], zn_log(x, g, n)), powers_7);
(%o6)                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
<p>Das optionale vierte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
Die Laufzeit h&auml;ngt im Wesentlichen von der Bitl&auml;nge des gr&ouml;&szlig;ten
Primfaktors des Totienten ab.
</p>
<pre class="example">(%i1) (p : 2^127-1, primep(p));
(%o1)                             true
(%i2) ifs : ifactors(p - 1)$
(%i3) g : zn_primroot(p, ifs);
(%o3)                              43
(%i4) a : power_mod(g, 1234567890, p)$
(%i5) zn_log(a, g, p, ifs);
(%o5)                          1234567890
(%i6) time(%o5);  
(%o6)                            [1.204]
(%i7) f_max : last(ifs);
(%o7)                       [77158673929, 1]
(%i8) slength( printf(false, &quot;~b&quot;, f_max[1]) );
(%o8)                              37
</pre></dd></dl>

<p><a name="zn_005fmult_005ftable"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_mult_table</b><i> (<var>n</var>) </i>
<a name="IDX1223"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_mult_table</b><i> (<var>n</var>, <var>gcd</var>)</i>
<a name="IDX1224"></a>
</dt>
<dd><p>Ohne das optionale Argument <var>gcd</var> zeigt <code>zn_mult_table(n)</code> 
eine Multiplikationstabelle von allen Elementen in (Z/<var>n</var>Z)*, 
d.h. von allen zu <var>n</var> teilerfremden Elementen.
</p>
<p>Das optionale zweite Argument <var>gcd</var> erlaubt es, eine bestimmte Untermenge 
von (Z/<var>n</var>Z) auszuw&auml;hlen. 
Ist <var>gcd</var> eine nat&uuml;rliche Zahl, enth&auml;lt die Multiplikationstabelle 
alle Restklassen <code>x</code> mit <code>gcd(x,n) = </code><var>gcd</var>. 
Zur besseren Lesbarkeit werden Zeilen- und Spaltenk&ouml;pfe hinzugef&uuml;gt. 
Falls notwendig, lassen sich diese mit <code>submatrix(1, tabelle, 1)</code> 
wieder einfach entfernen. 
</p>
<p>Wird <var>gcd</var> auf <code>all</code> gesetzt, wird die Tabelle f&uuml;r s&auml;mtliche 
von Null verschiedene Elemente in (Z/<var>n</var>Z) ausgegeben.
</p>
<p>Das zweite Beispiel unten zeigt einen alternativen Weg, f&uuml;r Untergruppen 
eine Multiplikationstabelle zu erzeugen.
</p>
<p>Siehe auch <code><a href="#zn_005fadd_005ftable">zn_add_table</a></code>, <code><a href="#zn_005fpower_005ftable">zn_power_table</a></code>.
</p>
<p>Beispiele:
</p>
<p>Die Standardtabelle zeigt alle Elemente aus (Z/<var>n</var>Z)* und erlaubt, 
grundlegende Eigenschaften von modularen Multiplikationsgruppen zu zeigen und 
zu studieren. Z.B. stehen in der Hauptdiagonale s&auml;mtliche quadratische Reste, 
jede Zeile und Spalte enth&auml;lt alle Elemente, die Tabelle ist symmetrisch, etc..
</p>
<p>Wird <var>gcd</var> auf <code>all</code> gesetzt, wird die Tabelle f&uuml;r s&auml;mtliche 
von Null verschiedene Elemente in (Z/<var>n</var>Z) ausgegeben.
</p>
<pre class="example">(%i1) zn_mult_table(8);
                                [ 1  3  5  7 ]
                                [            ]
                                [ 3  1  7  5 ]
(%o1)                           [            ]
                                [ 5  7  1  3 ]
                                [            ]
                                [ 7  5  3  1 ]
(%i2) zn_mult_table(8, all);
                            [ 1  2  3  4  5  6  7 ]
                            [                     ]
                            [ 2  4  6  0  2  4  6 ]
                            [                     ]
                            [ 3  6  1  4  7  2  5 ]
                            [                     ]
(%o2)                       [ 4  0  4  0  4  0  4 ]
                            [                     ]
                            [ 5  2  7  4  1  6  3 ]
                            [                     ]
                            [ 6  4  2  0  6  4  2 ]
                            [                     ]
                            [ 7  6  5  4  3  2  1 ]
</pre>
<p>Ist <var>gcd</var> eine Zahl, wird zur besseren Lesbarkeit ein Zeilen- und Spaltenkopf 
hinzugef&uuml;gt.
</p>
<p>Ist die mit <var>gcd</var> ausgew&auml;hlte Teilmenge eine Gruppe, gibt es einen 
alternativen Weg, die Multiplikationstabelle zu erzeugen.
Die Isomorphie zu einer Gruppe mit <code>1</code> als Identit&auml;t l&auml;sst sich nutzen, 
um eine leicht lesbare Tabelle zu erhalten. Die Abbildung gelingt mit dem CRT.
</p>
<p>In der so erzeugten zweiten Version der Tabelle <code>T36_4</code> steht genau wie 
bei <code>T9</code> die Identit&auml;t, hier <code>28</code>, in der linken oberen Ecke. 
</p>

<pre class="example">(%i1) T36_4: zn_mult_table(36,4);
                        [ *   4   8   16  20  28  32 ]
                        [                            ]
                        [ 4   16  32  28  8   4   20 ]
                        [                            ]
                        [ 8   32  28  20  16  8   4  ]
                        [                            ]
(%o1)                   [ 16  28  20  4   32  16  8  ]
                        [                            ]
                        [ 20  8   16  32  4   20  28 ]
                        [                            ]
                        [ 28  4   8   16  20  28  32 ]
                        [                            ]
                        [ 32  20  4   8   28  32  16 ]
(%i2) T9: zn_mult_table(36/4);
                             [ 1  2  4  5  7  8 ]
                             [                  ]
                             [ 2  4  8  1  5  7 ]
                             [                  ]
                             [ 4  8  7  2  1  5 ]
(%o2)                        [                  ]
                             [ 5  1  2  7  8  4 ]
                             [                  ]
                             [ 7  5  1  8  4  2 ]
                             [                  ]
                             [ 8  7  5  4  2  1 ]
(%i3) T36_4: matrixmap(lambda([x], chinese([0,x],[4,9])), T9);
                          [ 28  20  4   32  16  8  ]
                          [                        ]
                          [ 20  4   8   28  32  16 ]
                          [                        ]
                          [ 4   8   16  20  28  32 ]
(%o3)                     [                        ]
                          [ 32  28  20  16  8   4  ]
                          [                        ]
                          [ 16  32  28  8   4   20 ]
                          [                        ]
                          [ 8   16  32  4   20  28 ]
</pre></dd></dl>

<p><a name="zn_005fnth_005froot"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_nth_root</b><i> (<var>x</var>, <var>n</var>, <var>m</var>) </i>
<a name="IDX1225"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_nth_root</b><i> (<var>x</var>, <var>n</var>, <var>m</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1226"></a>
</dt>
<dd><p>Gibt eine Liste mit allen <var>n</var>-ten Wurzeln von <var>x</var> aus der multiplikativen 
Untergruppe von (Z/<var>m</var>Z) zur&uuml;ck, in der sich <var>x</var> befindet, 
oder <code>false</code>, falls <var>x</var> keine <var>n</var>-te Potenz modulo <var>m</var> oder 
kein Element einer multiplikativen Untergruppe von (Z/<var>m</var>Z) ist.
</p>
<p><var>x</var> ist Element einer multiplikativen Untergruppe modulo <var>m</var>, wenn der 
gr&ouml;&szlig;te gemeinsame Teiler <code>g = gcd(x,m)</code> zu <code>m/g</code> teilerfremd ist.
</p>
<p><code>zn_nth_root</code> basiert auf einem Algorithmus von Adleman, Manders und Miller 
und S&auml;tzen &uuml;ber modulare Multiplikationsgruppen von Daniel Shanks.
</p>
<p>Der Algorithmus ben&ouml;tigt eine Primfaktorzerlegung des Modulus <var>m</var>. 
Es kann eventuell sinnvoll sein, diese Zerlegung vorab zu berechnen und 
als viertes Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe von 
<code>ifactors(m)</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Beispiele:
</p>
<p>Eine Potenztabelle der multiplikativen Gruppe modulo <code>14</code> 
gefolgt von einer Liste mit Listen von <var>n</var>-ten Wurzeln der <code>1</code>, 
wobei <var>n</var> von <code>1</code> bis <code>6</code> variiert.
</p>
<pre class="example">(%i1) zn_power_table(14);
                         [ 1   1   1   1   1   1 ]
                         [                       ]
                         [ 3   9   13  11  5   1 ]
                         [                       ]
                         [ 5   11  13  9   3   1 ]
(%o1)                    [                       ]
                         [ 9   11  1   9   11  1 ]
                         [                       ]
                         [ 11  9   1   11  9   1 ]
                         [                       ]
                         [ 13  1   13  1   13  1 ]
(%i2) makelist(zn_nth_root(1,n,14), n,1,6);
(%o2)  [[1], [1, 13], [1, 9, 11], [1, 13], [1], [1, 3, 5, 9, 11, 13]]
</pre>
<p>Im folgenden Beispiel ist <var>x</var> nicht zu <var>m</var> teilerfremd, 
aber es ist Element einer multiplikativen Untergruppe von (Z/<var>m</var>Z) 
und jede <var>n</var>-te Wurzel ist aus der selben Untergruppe. 
</p>
<p>Die Restklasse <code>3</code> ist kein Element in irgend einer multiplikativen 
Untergruppe von (Z/63Z) und wird daher nicht als dritte Wurzel von <code>27</code> 
zur&uuml;ck gegeben.
</p>
<p>Hier zeigt <code>zn_power_table</code> alle Reste <code>x</code> in (Z/63Z) 
mit <code>gcd(x,63) = 9</code>. Diese Untergruppe ist isomorph zu (Z/7Z)* 
und seine Identit&auml;t <code>36</code> wird mit Hilfe des CRT berechnet.
</p>
<pre class="example">(%i1) m: 7*9$

(%i2) zn_power_table(m,9);
                         [ 9   18  36  9   18  36 ]
                         [                        ]
                         [ 18  9   36  18  9   36 ]
                         [                        ]
                         [ 27  36  27  36  27  36 ]
(%o2)                    [                        ]
                         [ 36  36  36  36  36  36 ]
                         [                        ]
                         [ 45  9   27  18  54  36 ]
                         [                        ]
                         [ 54  18  27  9   45  36 ]
(%i3) zn_nth_root(27,3,m);
(%o3)                           [27, 45, 54]
(%i4) id7:1$  id63_9: chinese([id7,0],[7,9]);
(%o5)                                36
</pre>
<p>Im folgenden RSA-&auml;hnlichen Beispiel, in dem der Modulus <code>N</code> quadratfrei ist, 
d.h. in paarweise verschiedene Primfaktoren zerf&auml;llt, 
ist jedes <code>x</code> von <code>0</code> bis <code>N-1</code>
in einer multiplikativen Untergruppe enthalten.
</p>
<p>Zur Entschl&uuml;sselung wird die <code>e</code>-te Wurzel berechnet. 
<code>e</code> ist teilerfremd zu <code>N</code> und die <code>e</code>-te Wurzel ist deshalb 
eindeutig. <code>zn_nth_root</code> wendet hier effektiv den als CRT-RSA 
bekannten Algorithmus an.
(Man beachte, dass <code>flatten</code> Klammern entfernt und keine L&ouml;sungen.)
</p>
<pre class="example">(%i1) [p,q,e]: [5,7,17]$  N: p*q$

(%i3) xs: makelist(x,x,0,N-1)$

(%i4) ys: map(lambda([x],power_mod(x,e,N)),xs)$

(%i5) zs: flatten(map(lambda([y], zn_nth_root(y,e,N)), ys))$

(%i6) is(zs = xs);
(%o6)                             true
</pre>
<p>Im folgenden Beispiel ist die Faktorisierung des Modulus bekannt und wird 
als viertes Argument &uuml;bergeben.
</p>
<pre class="example">(%i1) p: 2^107-1$  q: 2^127-1$  N: p*q$

(%i4) ibase: obase: 16$

(%i5) msg: 11223344556677889900aabbccddeeff$

(%i6) enc: power_mod(msg, 10001, N);
(%o6)    1a8db7892ae588bdc2be25dd5107a425001fe9c82161abc673241c8b383
(%i7) zn_nth_root(enc, 10001, N, [[p,1],[q,1]]);
(%o7)               [11223344556677889900aabbccddeeff]
</pre></dd></dl>

<p><a name="zn_005forder"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1227"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_order</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1228"></a>
</dt>
<dd><p>Ist <var>x</var> eine Einheit in der endlichen Gruppe (Z/<var>n</var>Z)*, so berechnet 
<code>zn_order</code> die Ordnung dieses Elements.  Andernfalls gibt <code>zn_order</code> 
<code>false</code> zur&uuml;ck.  <var>x</var> ist eine Einheit modulo <var>n</var>, falls <var>x</var> 
teilerfremd zu <var>n</var> ist.
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Da diese Berechnung manchmal recht zeitaufw&auml;ndig ist, kann es eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_order</code> als 
drittes Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe von 
<code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>, <code><a href="#ifactors">ifactors</a></code>, <code><a href="#totient">totient</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>zn_order</code> berechnet die Ordnung einer Einheit <var>x</var> aus (Z/<var>n</var>Z)*.
</p>
<pre class="example">(%i1) n : 22$
(%i2) g : zn_primroot(n);
(%o2)                               7
(%i3) units_22 : sublist(makelist(i,i,1,21), lambda([x], gcd(x, n) = 1));
(%o3)              [1, 3, 5, 7, 9, 13, 15, 17, 19, 21]
(%i4) (ord_7 : zn_order(7, n)) = totient(n);
(%o4)                            10 = 10
(%i5) powers_7 : makelist(power_mod(g,i,n), i,0,ord_7 - 1);
(%o5)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
(%i6) map(lambda([x], zn_order(x, n)), powers_7);
(%o6)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i7) map(lambda([x], ord_7/gcd(x, ord_7)), makelist(i, i,0,ord_7 - 1));
(%o7)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
(%i8) totient(totient(n));
(%o8)                               4
</pre>
<p>Das optionale dritte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) is( (ord_3 : zn_order(g, p, ifs)) = totient(p) );
(%o4)                             true
(%i5) map(lambda([x], ord_3/zn_order(x, p, ifs)), makelist(i,i,2,15));
(%o5)        [22, 1, 44, 10, 5, 2, 22, 2, 8, 2, 1, 1, 20, 1]
</pre></dd></dl>

<p><a name="zn_005fpower_005ftable"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_power_table</b><i> (<var>n</var>) </i>
<a name="IDX1229"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_power_table</b><i> (<var>n</var>, <var>gcd</var>)</i>
<a name="IDX1230"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_power_table</b><i> (<var>n</var>, <var>gcd</var>, <var>max_exp</var>)</i>
<a name="IDX1231"></a>
</dt>
<dd><p>Ohne ein optionales Argument zeigt <code>zn_power_table(n)</code> 
eine Potenzierungstabelle von allen Elementen in (Z/<var>n</var>Z)*, 
d.h. von allen zu <var>n</var> teilerfremden Elementen. 
Der Exponent variiert dabei jeweils zwischen <code>1</code> und 
dem gr&ouml;&szlig;ten charakteristischen Faktor des Totienten von <var>n</var>
(auch bekannt als Carmichael Funktion bzw. Carmichael Lambda), 
so dass die Tabelle rechts mit einer Spalte von Einsen endet.
</p>
<p>Das optionale zweite Argument <var>gcd</var> erlaubt es, eine bestimmte Untermenge 
von (Z/<var>n</var>Z) auszuw&auml;hlen. 
Ist <var>gcd</var> eine nat&uuml;rliche Zahl, werden Potenzen von allen Restklassen 
<code>x</code> mit <code>gcd(x,n) = </code><var>gcd</var> zur&uuml;ck gegeben, 
d.h. <var>gcd</var> ist standardm&auml;&szlig;ig <code>1</code>.
Wird <var>gcd</var> auf <code>all</code> gesetzt, wird die Tabelle f&uuml;r s&auml;mtliche 
Elemente in (Z/<var>n</var>Z) ausgegeben.
</p>
<p>Wird das optionale dritte Argument <var>max_exp</var> angegeben, variiert der 
Exponent zwischen <code>1</code> und <var>max_exp</var>.
</p>
<p>Siehe auch <code><a href="#zn_005fadd_005ftable">zn_add_table</a></code>, <code><a href="#zn_005fmult_005ftable">zn_mult_table</a></code>.
</p>
<p>Beispiele:
</p>
<p>Die Standardeinstellung <var>gcd</var><code> = 1</code> erlaubt es, grundlegende S&auml;tze, 
wie die von Fermat and Euler, zu zeigen und zu betrachten.
</p>
<p>Das Argument <var>gcd</var> erlaubt es, bestimmte Teilmengen von (Z/<var>n</var>Z) 
auszuw&auml;hlen und multiplikative Untergruppen und Isomorphismen zu untersuchen. 
</p>
<p>Z.B. sind die Gruppen <code>G10</code> und <code>G10_2</code> unter der Multiplikation 
beide isomorph zu <code>G5</code>. <code>1</code> ist die Identit&auml;t in <code>G5</code>. 
So sind <code>1</code> bzw. <code>6</code> die Identit&auml;ten in <code>G10</code> bzw. <code>G10_2</code>. 
Entsprechende Zuordnungen ergeben sich bei den Primitivwurzeln, n-ten Wurzeln, etc..
</p>
<pre class="example">(%i1) zn_power_table(10);
                              [ 1  1  1  1 ]
                              [            ]
                              [ 3  9  7  1 ]
(%o1)                         [            ]
                              [ 7  9  3  1 ]
                              [            ]
                              [ 9  1  9  1 ]
(%i2) zn_power_table(10,2);
                              [ 2  4  8  6 ]
                              [            ]
                              [ 4  6  4  6 ]
(%o2)                         [            ]
                              [ 6  6  6  6 ]
                              [            ]
                              [ 8  4  2  6 ]
(%i3) zn_power_table(10,5);
(%o3)                         [ 5  5  5  5 ]
(%i4) zn_power_table(10,10);
(%o4)                         [ 0  0  0  0 ]
(%i5) G5: [1,2,3,4];
(%o6)                          [1, 2, 3, 4]
(%i6) G10_2: map(lambda([x], chinese([0,x],[2,5])), G5);
(%o6)                          [6, 2, 8, 4]
(%i7) G10: map(lambda([x], power_mod(3, zn_log(x,2,5), 10)), G5);
(%o7)                          [1, 3, 7, 9]
</pre>
<p>Wird <var>gcd</var> auf <code>all</code> gesetzt, wird die Tabelle f&uuml;r s&auml;mtliche 
Elemente in (Z/<var>n</var>Z) ausgegeben.
</p>
<p>Das dritte Argument <var>max_exp</var> erlaubt, den h&ouml;chsten Exponenten zu w&auml;hlen.  
Die folgende Tabelle zeigt ein kleines RSA-Beispiel.
</p>
<pre class="example">(%i1) N:2*5$ phi:totient(N)$ e:7$ d:inv_mod(e,phi)$

(%i5) zn_power_table(N, all, e*d);
       [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]
       [                                                               ]
       [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 ]
       [                                                               ]
       [ 2  4  8  6  2  4  8  6  2  4  8  6  2  4  8  6  2  4  8  6  2 ]
       [                                                               ]
       [ 3  9  7  1  3  9  7  1  3  9  7  1  3  9  7  1  3  9  7  1  3 ]
       [                                                               ]
       [ 4  6  4  6  4  6  4  6  4  6  4  6  4  6  4  6  4  6  4  6  4 ]
(%o5)  [                                                               ]
       [ 5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5 ]
       [                                                               ]
       [ 6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6 ]
       [                                                               ]
       [ 7  9  3  1  7  9  3  1  7  9  3  1  7  9  3  1  7  9  3  1  7 ]
       [                                                               ]
       [ 8  4  2  6  8  4  2  6  8  4  2  6  8  4  2  6  8  4  2  6  8 ]
       [                                                               ]
       [ 9  1  9  1  9  1  9  1  9  1  9  1  9  1  9  1  9  1  9  1  9 ]
</pre></dd></dl>

<p><a name="zn_005fprimroot"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_primroot</b><i> (<var>n</var>) </i>
<a name="IDX1232"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_primroot</b><i> (<var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1233"></a>
</dt>
<dd><p>Ist die multiplikative Gruppe (Z/<var>n</var>Z)* zyklisch, berechnet <code>zn_primroot</code> 
die kleinste Primitivwurzel modulo <var>n</var>.  Dies ist der Fall, wenn <var>n</var> gleich 
<code>2</code>, <code>4</code>, <code>p^k</code> oder <code>2*p^k</code> ist, wobei <code>p</code> ungerade und 
prim und <code>k</code> eine nat&uuml;rliche Zahl ist.  <code>zn_primroot</code> 
f&uuml;hrt einen entsprechenden Pr&auml;test durch, wenn die Optionsvariable 
<code><a href="#zn_005fprimroot_005fpretest">zn_primroot_pretest</a></code> (Standardwert: <code>false</code>) <code>true</code> gesetzt wurde.
In jedem Fall wird die Suche durch die obere Schranke <code><a href="#zn_005fprimroot_005flimit">zn_primroot_limit</a></code> begrenzt.
</p>
<p>Ist (Z/<var>n</var>Z)* nicht zyklisch oder kann bis <code>zn_primroot_limit</code> 
keine Primitivwurzel modulo <var>n</var> gefunden werden, gibt <code>zn_primroot</code> 
<code>false</code> zur&uuml;ck. 
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von <var>n</var>. 
Diese Berechnung kann zeitaufw&auml;ndig sein und es kann daher eventuell sinnvoll 
sein, die Primfaktoren des Totienten vorab zu berechnen und <code>zn_primroot</code> 
als zus&auml;tzliches Argument zu &uuml;bergeben. Die Form muss dabei der R&uuml;ckgabe  
von <code>ifactors(totient(n))</code> mit der Standardeinstellung <code>false</code> der 
Optionsvariable <code>factors_only</code> entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot_005fp">zn_primroot_p</a></code>, <code><a href="#zn_005forder">zn_order</a></code>, <code><a href="#ifactors">ifactors</a></code>, <code><a href="#totient">totient</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>zn_primroot</code> berechnet die kleinste Primitivwurzel modulo <var>n</var> oder gibt 
<code>false</code> zur&uuml;ck.
</p>
<pre class="example">(%i1) n : 14$
(%i2) g : zn_primroot(n);
(%o2)                               3
(%i3) zn_order(g, n) = totient(n);
(%o3)                             6 = 6
(%i4) n : 15$
(%i5) zn_primroot(n);
(%o5)                             false
</pre>
<p>Das optionale zweite Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) g : zn_primroot(p, ifs);
(%o3)                               3
(%i4) [time(%o2), time(%o3)];
(%o4)                    [[15.556972], [0.004]]
(%i5) is(zn_order(g, p, ifs) = p - 1);
(%o5)                             true
(%i6) n : 2^142 + 216$
(%i7) ifs : ifactors(totient(n))$
(%i8) zn_primroot(n, ifs), 
      zn_primroot_limit : 200, zn_primroot_verbose : true;
`zn_primroot' stopped at zn_primroot_limit = 200
(%o8)                             false
</pre></dd></dl>

<p><a name="zn_005fprimroot_005flimit"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_limit</b>
<a name="IDX1234"></a>
</dt>
<dd><p>Standardwert: <code>1000</code> 
</p>
<p>Definiert die obere Schranke f&uuml;r die Suche von <code><a href="#zn_005fprimroot">zn_primroot</a></code> nach einer 
Primitivwurzel.  Wurde die Optionsvariable <code><a href="#zn_005fprimroot_005fverbose">zn_primroot_verbose</a></code>
(Standardwert: <code>false</code>) <code>true</code> gesetzt, wird beim Erreichen von 
<code>zn_primroot_limit</code> ein entsprechender Hinweis ausgegeben.
</p></dd></dl>

<p><a name="zn_005fprimroot_005fp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>) </i>
<a name="IDX1235"></a>
</dt>
<dt><u>Funktion:</u> <b>zn_primroot_p</b><i> (<var>x</var>, <var>n</var>, [[<var>p1</var>, <var>e1</var>], &hellip;, [<var>pk</var>, <var>ek</var>]])</i>
<a name="IDX1236"></a>
</dt>
<dd><p>Testet, ob <var>x</var> eine Primitivwurzel in der multiplikativen Gruppe (Z/<var>n</var>Z)* 
ist. 
</p>
<p>Der verwendete Algorithmus ben&ouml;tigt die Primfaktorzerlegung des Totienten von  
<var>n</var>.  Wird dieser Test nacheinander auf mehrere Zahlen angewandt, 
kann es sinnvoll sein, die Primfaktoren des Totienten vorab zu berechnen 
und <code>zn_primroot_p</code> als zus&auml;tzliches drittes Argument zu &uuml;bergeben. 
Die Form muss dabei der R&uuml;ckgabe von <code>ifactors(totient(n))</code> mit der 
Standardeinstellung <code>false</code> der Optionsvariable <code>factors_only</code> 
entsprechen. 
</p>
<p>Siehe auch <code><a href="#zn_005fprimroot">zn_primroot</a></code>, <code><a href="#zn_005forder">zn_order</a></code>, <code><a href="#ifactors">ifactors</a></code>, <code><a href="#totient">totient</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>zn_primroot_p</code> als Pr&auml;dikatfunktion.
</p>
<pre class="example">(%i1) n : 14$
(%i2) units_14 : sublist(makelist(i,i,1,13), lambda([i], gcd(i, n) = 1));
(%o2)                     [1, 3, 5, 9, 11, 13]
(%i3) zn_primroot_p(13, n);
(%o3)                            false
(%i4) sublist(units_14, lambda([x], zn_primroot_p(x, n)));
(%o4)                            [3, 5]
(%i5) map(lambda([x], zn_order(x, n)), units_14);
(%o5)                      [1, 6, 6, 3, 3, 2]
</pre>
<p>Das optionale dritte Argument muss der R&uuml;ckgabe von <code>ifactors(totient(n))</code> 
entsprechen. 
</p>
<pre class="example">(%i1) (p : 2^142 + 217, primep(p));
(%o1)                             true
(%i2) ifs : ifactors( totient(p) )$
(%i3) sublist(makelist(i,i,1,50), lambda([x], zn_primroot_p(x, p, ifs)));
(%o3)      [3, 12, 13, 15, 21, 24, 26, 27, 29, 33, 38, 42, 48]
(%i4) [time(%o2), time(%o3)];
(%o4)                   [[7.748484], [0.036002]]
</pre></dd></dl>

<p><a name="zn_005fprimroot_005fpretest"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_pretest</b>
<a name="IDX1237"></a>
</dt>
<dd><p>Standardwert: <code>false</code> 
</p>
<p>Eine multiplikative Gruppe (Z/<code>n</code>Z)* ist zyklisch, wenn <code>n</code> gleich 
<code>2</code>, <code>4</code>, <code>p^k</code> oder <code>2*p^k</code> ist, wobei <code>p</code> prim und 
gr&ouml;&szlig;er <code>2</code> und <code>k</code> eine nat&uuml;rliche Zahl ist. 
</p>
<p><code>zn_primroot_pretest</code> entscheidet dar&uuml;ber, ob <code><a href="#zn_005fprimroot">zn_primroot</a></code> vor 
der Berechnung der kleinsten Primitivwurzel in (Z/<code>n</code>Z)* &uuml;berpr&uuml;ft, 
ob auf <code>n</code> &uuml;berhaupt einer der oben genannten F&auml;lle zutrifft.  Nur wenn  
<code>zn_primroot_pretest</code> <code>true</code> ist, wird dieser Pr&auml;test ausgef&uuml;hrt.
</p></dd></dl>

<p><a name="zn_005fprimroot_005fverbose"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>zn_primroot_verbose</b>
<a name="IDX1238"></a>
</dt>
<dd><p>Standardwert: <code>false</code> 
</p>
<p>Entscheidet, ob <code><a href="#zn_005fprimroot">zn_primroot</a></code> beim Erreichen von <code><a href="#zn_005fprimroot_005flimit">zn_primroot_limit</a></code>
einen Hinweis ausgibt.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC160" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC162" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
