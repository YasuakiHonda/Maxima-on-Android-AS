<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 58. linearalgebra</title>

<meta name="description" content="Maxima Manual: 58. linearalgebra">
<meta name="keywords" content="Maxima Manual: 58. linearalgebra">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="linearalgebra"></a>
<a name="SEC320"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_57.html#SEC319" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC321" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC318" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_59.html#SEC323" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 58. linearalgebra </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC321">58.1 Introduction to linearalgebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC322">58.2 Functions and Variables for linearalgebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introduction-to-linearalgebra"></a>
<a name="SEC321"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC320" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC322" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC320" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC320" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_59.html#SEC323" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 58.1 Introduction to linearalgebra </h2>

<p><code>linearalgebra</code> is a collection of functions for linear algebra.
</p>
<p>Example:
</p>
<pre class="example">(%i1) M : matrix ([1, 2], [1, 2]);
                            [ 1  2 ]
(%o1)                       [      ]
                            [ 1  2 ]
(%i2) nullspace (M);
                               [  1  ]
                               [     ]
(%o2)                     span([   1 ])
                               [ - - ]
                               [   2 ]
(%i3) columnspace (M);
                                [ 1 ]
(%o3)                      span([   ])
                                [ 1 ]
(%i4) ptriangularize (M - z*ident(2), z);
                         [ 1   2 - z   ]
(%o4)                    [             ]
                         [           2 ]
                         [ 0  3 z - z  ]
(%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                     [ 1 - z    2      3   ]
                     [                     ]
(%o5)                [   4    5 - z    6   ]
                     [                     ]
                     [   7      8    9 - z ]
(%i6) MM : ptriangularize (M, z);
              [ 4  5 - z            6            ]
              [                                  ]
              [                2                 ]
              [     66        z    102 z   132   ]
              [ 0   --      - -- + ----- + ---   ]
(%o6)         [     49        7     49     49    ]
              [                                  ]
              [               3        2         ]
              [           49 z    245 z    147 z ]
              [ 0    0    ----- - ------ - ----- ]
              [            264      88      44   ]
(%i7) algebraic : true;
(%o7)                         true
(%i8) tellrat (MM [3, 3]);
                         3       2
(%o8)                  [z  - 15 z  - 18 z]
(%i9) MM : ratsimp (MM);
               [ 4  5 - z           6           ]
               [                                ]
               [                2               ]
(%o9)          [     66      7 z  - 102 z - 132 ]
               [ 0   --    - ------------------ ]
               [     49              49         ]
               [                                ]
               [ 0    0             0           ]
(%i10) nullspace (MM);
                        [        1         ]
                        [                  ]
                        [   2              ]
                        [  z  - 14 z - 16  ]
                        [  --------------  ]
(%o10)             span([        8         ])
                        [                  ]
                        [    2             ]
                        [   z  - 18 z - 12 ]
                        [ - -------------- ]
                        [         12       ]
(%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],
                   [13, 14, 15, 16]);
                       [ 1   2   3   4  ]
                       [                ]
                       [ 5   6   7   8  ]
(%o11)                 [                ]
                       [ 9   10  11  12 ]
                       [                ]
                       [ 13  14  15  16 ]
(%i12) columnspace (M);
                           [ 1  ]  [ 2  ]
                           [    ]  [    ]
                           [ 5  ]  [ 6  ]
(%o12)                span([    ], [    ])
                           [ 9  ]  [ 10 ]
                           [    ]  [    ]
                           [ 13 ]  [ 14 ]
(%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                           [ 0 ]  [  1  ]
                           [   ]  [     ]
                           [ 1 ]  [  0  ]
(%o13)                span([   ], [     ])
                           [ 2 ]  [ - 1 ]
                           [   ]  [     ]
                           [ 3 ]  [ - 2 ]
</pre>
<hr size="6">
<a name="Functions-and-Variables-for-linearalgebra"></a>
<a name="SEC322"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC321" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_59.html#SEC323" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC320" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC320" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_59.html#SEC323" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 58.2 Functions and Variables for linearalgebra </h2>

<dl>
<dt><u>Function:</u> <b>addmatrices</b><i> (<var>f</var>, <var>M_1</var>, ..., <var>M_n</var>)</i>
<a name="IDX2436"></a>
</dt>
<dd><p>Using the function <var>f</var> as the addition function, return the sum of
the matrices <var>M_1</var>, ..., <var>M_n</var>. The function <var>f</var> must accept any
number of arguments (a Maxima nary function).
</p>
<p>Examples:
</p>
<pre class="example">(%i1) m1 : matrix([1,2],[3,4])$
(%i2) m2 : matrix([7,8],[9,10])$
(%i3) addmatrices('max,m1,m2);
(%o3) matrix([7,8],[9,10])
(%i4) addmatrices('max,m1,m2,5*m1);
(%o4) matrix([7,10],[15,20])
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>blockmatrixp</b><i> (<var>M</var>)</i>
<a name="IDX2437"></a>
</dt>
<dd><p>Return true if and only if <var>M</var> is a matrix and every entry of 
<var>M</var> is a matrix.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>columnop</b><i> (<var>M</var>, <var>i</var>, <var>j</var>, <var>theta</var>)</i>
<a name="IDX2438"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, return the matrix that results from doing the  
column operation <code>C_i &lt;- C_i - <var>theta</var> * C_j</code>. If <var>M</var> doesn't
have a row <var>i</var> or <var>j</var>, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>columnswap</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX2439"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, swap columns <var>i</var> and <var>j</var>.  If <var>M</var> doesn't 
have a column <var>i</var> or <var>j</var>, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>columnspace</b><i> (<var>M</var>)</i>
<a name="IDX2440"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, return <code>span (v_1, ..., v_n)</code>, where the set
<code>{v_1, ..., v_n}</code> is a basis for the column space of <var>M</var>.  The span 
of the empty set is <code>{0}</code>. Thus, when the column space has only 
one member, return <code>span ()</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>copy</b><i> (<var>e</var>)</i>
<a name="IDX2441"></a>
</dt>
<dd><p>Return a copy of the Maxima expression <var>e</var>. Although <var>e</var> can be any
Maxima expression, the copy function is the most useful when <var>e</var> is either 
a list or a matrix; consider:
</p>
<pre class="example">(%i1) m : [1,[2,3]]$
(%i2) mm : m$
(%i3) mm[2][1] : x$
(%i4) m;
(%o4)                      [1,[x,3]]
(%i5) mm;
(%o5)                      [1,[x,3]]
</pre>
<p>Let's try the same experiment, but this time let <var>mm</var> be a copy of <var>m</var>
</p>
<pre class="example">(%i6) m : [1,[2,3]]$
(%i7) mm : copy(m)$
(%i8) mm[2][1] : x$
(%i9) m;
(%o9)                     [1,[2,3]]
(%i10) mm;
(%o10)                    [1,[x,3]]
</pre><p>This time, the assignment to <var>mm</var> does not change the value of <var>m</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>cholesky</b><i> (<var>M</var>)</i>
<a name="IDX2442"></a>
</dt>
<dt><u>Function:</u> <b>cholesky</b><i> (<var>M</var>, <var>field</var>)</i>
<a name="IDX2443"></a>
</dt>
<dd><p>Return the Cholesky factorization of the matrix selfadjoint (or hermitian)
matrix <var>M</var>. The second argument defaults to 'generalring.' For a description
of the possible values for <var>field</var>, see <code>lu_factor</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>ctranspose</b><i> (<var>M</var>)</i>
<a name="IDX2444"></a>
</dt>
<dd><p>Return the complex conjugate transpose of the matrix <var>M</var>. The function
<code>ctranspose</code> uses <code>matrix_element_transpose</code> to transpose each matrix
element.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>diag_matrix</b><i> (<var>d_1</var>, <var>d_2</var>,...,<var>d_n</var>)</i>
<a name="IDX2445"></a>
</dt>
<dd><p>Return a diagonal matrix with diagonal entries <var>d_1</var>, <var>d_2</var>, ...,
<var>d_n</var>.  When the diagonal entries are matrices, the zero entries of the
returned matrix are zero matrices of the appropriate size; for example:
</p>
<pre class="example">(%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                            [ [ 1  0 ]  [ 0  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  2 ]  [ 0  0 ] ]
(%o1)                       [                    ]
                            [ [ 0  0 ]  [ 3  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  0 ]  [ 0  4 ] ]
(%i2) diag_matrix(p,q);

                                   [ p  0 ]
(%o2)                              [      ]
                                   [ 0  q ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>dotproduct</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX2446"></a>
</dt>
<dd><p>Return the dotproduct of vectors <var>u</var> and <var>v</var>.  This is the same
as <code>conjugate (transpose (<var>u</var>)) . <var>v</var></code>.  The arguments <var>u</var> and
<var>v</var> must be column vectors.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>eigens_by_jacobi</b><i> (<var>A</var>)</i>
<a name="IDX2447"></a>
</dt>
<dt><u>Function:</u> <b>eigens_by_jacobi</b><i> (<var>A</var>, <var>field_type</var>)</i>
<a name="IDX2448"></a>
</dt>
<dd><p>Computes the eigenvalues and eigenvectors of <var>A</var> by the method of Jacobi
rotations.  <var>A</var> must be a symmetric matrix (but it need not be positive
definite nor positive semidefinite).  <var>field_type</var> indicates the
computational field, either <code>floatfield</code> or <code>bigfloatfield</code>.  If 
<var>field_type</var> is not specified, it defaults to <code>floatfield</code>.
</p>
<p>The elements of <var>A</var> must be numbers or expressions which evaluate to numbers
via <code>float</code> or <code>bfloat</code> (depending on <var>field_type</var>).
</p>
<p>Examples:
</p>
<pre class="example">(%i1) S: matrix([1/sqrt(2), 1/sqrt(2)],[-1/sqrt(2), 1/sqrt(2)]);
                     [     1         1    ]
                     [  -------   ------- ]
                     [  sqrt(2)   sqrt(2) ]
(%o1)                [                    ]
                     [      1        1    ]
                     [ - -------  ------- ]
                     [   sqrt(2)  sqrt(2) ]
(%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                      [ sqrt(3)     0    ]
(%o2)                 [                  ]
                      [    0     sqrt(5) ]
(%i3) M : S . L . transpose (S);
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- + -------  ------- - ------- ]
            [    2         2        2         2    ]
(%o3)       [                                      ]
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- - -------  ------- + ------- ]
            [    2         2        2         2    ]
(%i4) eigens_by_jacobi (M);
The largest percent change was 0.1454972243679
The largest percent change was 0.0
number of sweeps: 2
number of rotations: 1
(%o4) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i5) float ([[sqrt(3), sqrt(5)], S]);
(%o5) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i6) eigens_by_jacobi (M, bigfloatfield);
The largest percent change was 1.454972243679028b-1
The largest percent change was 0.0b0
number of sweeps: 2
number of rotations: 1
(%o6) [[1.732050807568877b0, 2.23606797749979b0], 
                [  7.071067811865475b-1   7.071067811865475b-1 ]
                [                                              ]]
                [ - 7.071067811865475b-1  7.071067811865475b-1 ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>get_lu_factors</b><i> (<var>x</var>) </i>
<a name="IDX2449"></a>
</dt>
<dd><p>When <code><var>x</var> = lu_factor (<var>A</var>)</code>, then <code>get_lu_factors</code> returns 
a list of the form <code>[P, L, U]</code>, where <var>P</var> is a permutation matrix, 
<var>L</var> is lower triangular with ones on the diagonal, and <var>U</var> is upper 
triangular, and <code><var>A</var> = <var>P</var> <var>L</var> <var>U</var></code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>hankel</b><i> (<var>col</var>)</i>
<a name="IDX2450"></a>
</dt>
<dt><u>Function:</u> <b>hankel</b><i> (<var>col</var>, <var>row</var>)</i>
<a name="IDX2451"></a>
</dt>
<dd><p>Return a Hankel matrix <var>H</var>. The first column of <var>H</var> is <var>col</var>;
except for the first entry, the last row of <var>H</var> is <var>row</var>. The
default for <var>row</var> is the zero vector with the same length as <var>col</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>hessian</b><i> (<var>f</var>, <var>x</var>)</i>
<a name="IDX2452"></a>
</dt>
<dd><p>Returns the Hessian matrix of <var>f</var> with respect to the list of variables 
<var>x</var>.  The <code>(i, j)</code>-th element of the Hessian matrix is 
<code>diff(<var>f</var>, <var>x</var>[i], 1, <var>x</var>[j], 1)</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) hessian (x * sin (y), [x, y]);
                     [   0       cos(y)   ]
(%o1)                [                    ]
                     [ cos(y)  - x sin(y) ]
(%i2) depends (F, [a, b]);
(%o2)                       [F(a, b)]
(%i3) hessian (F, [a, b]);
                        [   2      2   ]
                        [  d F    d F  ]
                        [  ---   ----- ]
                        [    2   da db ]
                        [  da          ]
(%o3)                   [              ]
                        [   2      2   ]
                        [  d F    d F  ]
                        [ -----   ---  ]
                        [ da db     2  ]
                        [         db   ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>hilbert_matrix</b><i> (<var>n</var>)</i>
<a name="IDX2453"></a>
</dt>
<dd><p>Return the <var>n</var> by <var>n</var> Hilbert matrix. When <var>n</var> isn't a positive
integer, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>identfor</b><i> (<var>M</var>)</i>
<a name="IDX2454"></a>
</dt>
<dt><u>Function:</u> <b>identfor</b><i> (<var>M</var>, <var>fld</var>)</i>
<a name="IDX2455"></a>
</dt>
<dd><p>Return an identity matrix that has the same shape as the matrix
<var>M</var>.  The diagonal entries of the identity matrix are the 
multiplicative identity of the field <var>fld</var>; the default for
<var>fld</var> is <var>generalring</var>.
</p>
<p>The first argument <var>M</var> should be a square matrix or a 
non-matrix. When <var>M</var> is a matrix, each entry of <var>M</var> can be a
square matrix - thus <var>M</var> can be a blocked Maxima matrix. The
matrix can be blocked to any (finite) depth.
</p>
<p>See also <code>zerofor</code>
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>invert_by_lu</b><i> (<var>M</var>, <var>(rng generalring)</var>)</i>
<a name="IDX2456"></a>
</dt>
<dd><p>Invert a matrix <var>M</var> by using the LU factorization.  The LU factorization
is done using the ring <var>rng</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>jacobian</b><i> (<var>f</var>, <var>x</var>)</i>
<a name="IDX2457"></a>
</dt>
<dd><p>Returns the Jacobian matrix of the list of functions <var>f</var> with respect to 
the list of variables <var>x</var>.  The <code>(i, j)</code>-th element of the Jacobian 
matrix is <code>diff(<var>f</var>[i], <var>x</var>[j])</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                  [ cos(v - u)  - cos(v - u) ]
(%o1)             [                          ]
                  [ v cos(u v)   u cos(u v)  ]
(%i2) depends ([F, G], [y, z]);
(%o2)                  [F(y, z), G(y, z)]
(%i3) jacobian ([F, G], [y, z]);
                           [ dF  dF ]
                           [ --  -- ]
                           [ dy  dz ]
(%o3)                      [        ]
                           [ dG  dG ]
                           [ --  -- ]
                           [ dy  dz ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>kronecker_product</b><i> (<var>A</var>, <var>B</var>)</i>
<a name="IDX2458"></a>
</dt>
<dd><p>Return the Kronecker product of the matrices <var>A</var> and <var>B</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>listp</b><i> (<var>e</var>, <var>p</var>)</i>
<a name="IDX2459"></a>
</dt>
<dt><u>Function:</u> <b>listp</b><i> (<var>e</var>)</i>
<a name="IDX2460"></a>
</dt>
<dd><p>Given an optional argument <var>p</var>, return <code>true</code> if <var>e</var> is 
a Maxima list and <var>p</var> evaluates to <code>true</code> for every list element.
When <code>listp</code> is not given the optional argument, return <code>true</code> if <var>e</var> is 
a Maxima list.  In all other cases, return <code>false</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>locate_matrix_entry</b><i> (<var>M</var>, <var>r_1</var>, <var>c_1</var>, <var>r_2</var>, <var>c_2</var>, <var>f</var>, <var>rel</var>)</i>
<a name="IDX2461"></a>
</dt>
<dd><p>The first argument must be a matrix; the arguments
<var>r_1</var> through <var>c_2</var> determine a sub-matrix of <var>M</var> that consists of
rows <var>r_1</var> through <var>r_2</var> and columns <var>c_1</var> through <var>c_2</var>. 
</p>
<p>Find a entry in the sub-matrix <var>M</var> that satisfies some property. 
Three cases:
</p>
<p>(1) <code><var>rel</var> = 'bool</code> and <var>f</var> a predicate: 
</p>
<p>Scan the sub-matrix from left to right then top to bottom,
and return the index of the first entry that satisfies the 
predicate <var>f</var>. If no matrix entry satisfies <var>f</var>, return <code>false</code>.
</p>
<p>(2) <code><var>rel</var> = 'max</code> and <var>f</var> real-valued:
</p>
<p>Scan the sub-matrix looking for an entry that maximizes <var>f</var>.
Return the index of a maximizing entry.
</p>
<p>(3) <code><var>rel</var> = 'min</code> and <var>f</var> real-valued:
</p>
<p>Scan the sub-matrix looking for an entry that minimizes <var>f</var>. 
Return the index of a minimizing entry.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>lu_backsub</b><i> (<var>M</var>, <var>b</var>)</i>
<a name="IDX2462"></a>
</dt>
<dd><p>When <code><var>M</var> = lu_factor (<var>A</var>, <var>field</var>)</code>,
then <code>lu_backsub (<var>M</var>, <var>b</var>)</code> solves the linear
system <code><var>A</var> <var>x</var> = <var>b</var></code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>lu_factor</b><i> (<var>M</var>, <var>field</var>)</i>
<a name="IDX2463"></a>
</dt>
<dd><p>Return a list of the form <code>[<var>LU</var>, <var>perm</var>, <var>fld</var>]</code>, or 
<code>[<var>LU</var>, <var>perm</var>, <var>fld</var>, <var>lower-cnd</var> <var>upper-cnd</var>]</code>, where
</p>
<p>  (1) The matrix <var>LU</var> contains the factorization of <var>M</var> in a packed 
      form. Packed form means three things: First, the rows of <var>LU</var> are 
      permuted according to the list <var>perm</var>.  If, for example, <var>perm</var> 
      is the list <code>[3,2,1]</code>, the actual first row 
      of the <var>LU</var> factorization is the third row of the matrix <var>LU</var>. 
      Second, the lower triangular factor of m is the lower triangular part of 
      <var>LU</var> with the diagonal entries replaced by all ones. Third, the upper
      triangular factor of <var>M</var> is the upper triangular part of <var>LU</var>.
</p>
<p>  (2) When the field is either <code>floatfield</code> or <code>complexfield</code>,
      the numbers <var>lower-cnd</var> and <var>upper-cnd</var> are lower and upper bounds
      for the infinity norm condition number of <var>M</var>.  For all fields, the 
      condition number might not be estimated; for such fields, <code>lu_factor</code>
      returns a two item list.  Both the lower and upper bounds can differ from 
      their true values by arbitrarily large factors. 
      (See also <code>mat_cond</code>.)
</p>   
<p>  The argument <var>M</var> must be a square matrix.
</p>
<p>  The optional argument <var>fld</var> must be a symbol that determines a ring or 
  field. The pre-defined fields and rings are:
</p>
<p>    (a) <code>generalring</code> - the ring of Maxima expressions,
    (b) <code>floatfield</code> -  the field of floating point numbers of the type double,
    (c) <code>complexfield</code> -  the field of complex floating point numbers of the 
        type double,
    (d) <code>crering</code>  - the ring of Maxima CRE expressions,
    (e) <code>rationalfield</code> - the field of rational numbers,
    (f) <code>runningerror</code> - track the all floating point rounding errors,
    (g) <code>noncommutingring</code> - the ring of Maxima expressions where multiplication is the
        non-commutative dot operator.       
</p>
<p>When the field is <code>floatfield</code>, <code>complexfield</code>, or
<code>runningerror</code>, the algorithm uses partial pivoting; for all
other fields, rows are switched only when needed to avoid a zero
pivot.
</p>
<p>Floating point addition arithmetic isn't associative, so the meaning
of 'field' differs from the mathematical definition.
</p>
<p>A member of the field <code>runningerror</code> is a two member Maxima list
of the form <code>[x,n]</code>,where <var>x</var> is a floating point number and
<code>n</code> is an integer. The relative difference between the 'true'
value of <code>x</code> and <code>x</code> is approximately bounded by the machine
epsilon times <code>n</code>. The running error bound drops some terms that
of the order the square of the machine epsilon.
</p>
<p>There is no user-interface for defining a new field. A user that is
familiar with Common Lisp should be able to define a new field.  To do
this, a user must define functions for the arithmetic operations and
functions for converting from the field representation to Maxima and
back. Additionally, for ordered fields (where partial pivoting will be
used), a user must define functions for the magnitude and for
comparing field members.  After that all that remains is to define a
Common Lisp structure <code>mring</code>.  The file <code>mring</code> has many
examples.
</p> 
<p>To compute the factorization, the first task is to convert each matrix
entry to a member of the indicated field. When conversion isn't
possible, the factorization halts with an error message. Members of
the field needn't be Maxima expressions.  Members of the
<code>complexfield</code>, for example, are Common Lisp complex numbers. Thus
after computing the factorization, the matrix entries must be
converted to Maxima expressions.
</p>
<p>See also  <code>get_lu_factors</code>.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) w[i,j] := random (1.0) + %i * random (1.0);
(%o1)          w     := random(1.) + %i random(1.)
                i, j
(%i2) showtime : true$
Evaluation took 0.00 seconds (0.00 elapsed)
(%i3) M : genmatrix (w, 100, 100)$
Evaluation took 7.40 seconds (8.23 elapsed)
(%i4) lu_factor (M, complexfield)$
Evaluation took 28.71 seconds (35.00 elapsed)
(%i5) lu_factor (M, generalring)$
Evaluation took 109.24 seconds (152.10 elapsed)
(%i6) showtime : false$

(%i7) M : matrix ([1 - z, 3], [3, 8 - z]); 
                        [ 1 - z    3   ]
(%o7)                   [              ]
                        [   3    8 - z ]
(%i8) lu_factor (M, generalring);
          [ 1 - z         3        ]
          [                        ]
(%o8)    [[   3            9       ], [1, 2], generalring]
          [ -----  - z - ----- + 8 ]
          [ 1 - z        1 - z     ]
(%i9) get_lu_factors (%);
                  [   1    0 ]  [ 1 - z         3        ]
        [ 1  0 ]  [          ]  [                        ]
(%o9)  [[      ], [   3      ], [                9       ]]
        [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                  [ 1 - z    ]  [              1 - z     ]
(%i10) %[1] . %[2] . %[3];
                        [ 1 - z    3   ]
(%o10)                  [              ]
                        [   3    8 - z ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>mat_cond</b><i> (<var>M</var>, 1)</i>
<a name="IDX2464"></a>
</dt>
<dt><u>Function:</u> <b>mat_cond</b><i> (<var>M</var>, inf)</i>
<a name="IDX2465"></a>
</dt>
<dd><p>Return the <var>p</var>-norm matrix condition number of the matrix
<var>m</var>. The allowed values for <var>p</var> are 1 and <var>inf</var>.  This
function uses the LU factorization to invert the matrix <var>m</var>. Thus
the running time for <code>mat_cond</code> is proportional to the cube of
the matrix size; <code>lu_factor</code> determines lower and upper bounds
for the infinity norm condition number in time proportional to the
square of the matrix size.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>mat_norm</b><i> (<var>M</var>, 1)</i>
<a name="IDX2466"></a>
</dt>
<dt><u>Function:</u> <b>mat_norm</b><i> (<var>M</var>, inf)</i>
<a name="IDX2467"></a>
</dt>
<dt><u>Function:</u> <b>mat_norm</b><i> (<var>M</var>, frobenius)</i>
<a name="IDX2468"></a>
</dt>
<dd><p>Return the matrix <var>p</var>-norm of the matrix <var>M</var>.  The allowed values for 
<var>p</var> are 1, <code>inf</code>, and <code>frobenius</code> (the Frobenius matrix norm). 
The matrix <var>M</var> should be an unblocked matrix.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>matrixp</b><i> (<var>e</var>, <var>p</var>)</i>
<a name="IDX2469"></a>
</dt>
<dt><u>Function:</u> <b>matrixp</b><i> (<var>e</var>)</i>
<a name="IDX2470"></a>
</dt>
<dd><p>Given an optional argument <var>p</var>, return <code>true</code> if <var>e</var> is 
a matrix and <var>p</var> evaluates to <code>true</code> for every matrix element.
When <code>matrixp</code> is not given an optional argument, return <code>true</code> 
if <code>e</code> is a matrix.  In all other cases, return <code>false</code>.
</p>
<p>See also <code>blockmatrixp</code>
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>matrix_size</b><i> (<var>M</var>)</i>
<a name="IDX2471"></a>
</dt>
<dd><p>Return a two member list that gives the number of rows and columns, respectively
of the matrix <var>M</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>mat_fullunblocker</b><i> (<var>M</var>)</i>
<a name="IDX2472"></a>
</dt>
<dd><p>If <var>M</var> is a block matrix, unblock the matrix to all levels. If <var>M</var> is 
a matrix, return <var>M</var>; otherwise, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>mat_trace</b><i> (<var>M</var>)</i>
<a name="IDX2473"></a>
</dt>
<dd><p>Return the trace of the matrix <var>M</var>. If <var>M</var> isn't a matrix, return a
noun form. When <var>M</var> is a block matrix, <code>mat_trace(M)</code> returns
the same value as does <code>mat_trace(mat_unblocker(m))</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>mat_unblocker</b><i> (<var>M</var>)</i>
<a name="IDX2474"></a>
</dt>
<dd><p>If <var>M</var> is a block matrix, unblock <var>M</var> one level. If <var>M</var> is a matrix, 
<code>mat_unblocker (M)</code> returns <var>M</var>; otherwise, signal an error.
</p>
<p>Thus if each entry of <var>M</var> is matrix, <code>mat_unblocker (M)</code> returns an 
unblocked matrix, but if each entry of <var>M</var> is a block matrix, 
<code>mat_unblocker (M)</code> returns a block matrix with one less level of blocking.
</p>
<p>If you use block matrices, most likely you'll want to set 
<code>matrix_element_mult</code> to <code>&quot;.&quot;</code> and <code>matrix_element_transpose</code> 
to <code>'transpose</code>. See also <code>mat_fullunblocker</code>.
</p>
<p>Example:
</p>
<pre class="example">(%i1) A : matrix ([1, 2], [3, 4]);
                            [ 1  2 ]
(%o1)                       [      ]
                            [ 3  4 ]
(%i2) B : matrix ([7, 8], [9, 10]);
                            [ 7  8  ]
(%o2)                       [       ]
                            [ 9  10 ]
(%i3) matrix ([A, B]);
                     [ [ 1  2 ]  [ 7  8  ] ]
(%o3)                [ [      ]  [       ] ]
                     [ [ 3  4 ]  [ 9  10 ] ]
(%i4) mat_unblocker (%);
                         [ 1  2  7  8  ]
(%o4)                    [             ]
                         [ 3  4  9  10 ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>nullspace</b><i> (<var>M</var>)</i>
<a name="IDX2475"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, return <code>span (v_1, ..., v_n)</code>, where the set 
<code>{v_1, ..., v_n}</code> is a basis for the nullspace of <var>M</var>.  The span of 
the empty set is <code>{0}</code>.  Thus, when the nullspace has only one member, 
return <code>span ()</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>nullity</b><i> (<var>M</var>)</i>
<a name="IDX2476"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, return the dimension of the nullspace of <var>M</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>orthogonal_complement</b><i> (<var>v_1</var>, ..., <var>v_n</var>)</i>
<a name="IDX2477"></a>
</dt>
<dd><p>Return <code>span (u_1, ..., u_m)</code>, where the set <code>{u_1, ..., u_m}</code> is a 
basis for the orthogonal complement of the set <code>(v_1, ..., v_n)</code>.
</p>
<p>Each vector <var>v_1</var> through <var>v_n</var> must be a column vector.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>, <var>coeffp</var>, <var>exponp</var>)</i>
<a name="IDX2478"></a>
</dt>
<dt><u>Function:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>, <var>coeffp</var>)</i>
<a name="IDX2479"></a>
</dt>
<dt><u>Function:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>)</i>
<a name="IDX2480"></a>
</dt>
<dd><p>Return <code>true</code> if <var>p</var> is a polynomial in the variables in the list 
<var>L</var>.  The predicate <var>coeffp</var> must evaluate to <code>true</code> for each
coefficient, and the predicate <var>exponp</var> must evaluate to <code>true</code> for all 
exponents of the variables in <var>L</var>. If you want to use a non-default
value for <var>exponp</var>, you must supply <var>coeffp</var> with a value even if you
want to use the default for <var>coeffp</var>.
</p>
<p>The command <code>polynomialp (<var>p</var>, <var>L</var>, <var>coeffp</var>)</code> is equivalent to
<code>polynomialp (<var>p</var>, <var>L</var>, <var>coeffp</var>, 'nonnegintegerp)</code> and
<code>polynomialp (<var>p</var>, <var>L</var>)</code> is equivalent to
<code>polynomialp (<var>p</var>, L<var>,</var> 'constantp, 'nonnegintegerp)</code>.
</p>
<p>The polynomial needn't be expanded:
</p>
<pre class="example">(%i1) polynomialp ((x + 1)*(x + 2), [x]);
(%o1)                         true
(%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
(%o2)                         false
</pre>
<p>An example using non-default values for coeffp and exponp:
</p>
<pre class="example">(%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
(%o1)                         true
(%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp,
                                                        numberp);
(%o2)                         true
</pre>
<p>Polynomials with two variables:
</p>
<pre class="example">(%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
(%o1)                         false
(%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
(%o2)                         true
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>polytocompanion</b><i> (<var>p</var>, <var>x</var>)</i>
<a name="IDX2481"></a>
</dt>
<dd><p>If <var>p</var> is a polynomial in <var>x</var>, return the companion matrix of <var>p</var>. 
For a monic polynomial <var>p</var> of degree <var>n</var>, we have 
<code><var>p</var> = (-1)^<var>n</var> charpoly (polytocompanion (<var>p</var>, <var>x</var>))</code>.
</p>
<p>When <var>p</var> isn't a polynomial in <var>x</var>, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>ptriangularize</b><i> (<var>M</var>, <var>v</var>)</i>
<a name="IDX2482"></a>
</dt>
<dd><p>If <var>M</var> is a matrix with each entry a polynomial in <var>v</var>, return 
a matrix <var>M2</var> such that
</p>
<p>(1) <var>M2</var> is upper triangular,
</p>
<p>(2) <code><var>M2</var> = <var>E_n</var> ... <var>E_1</var> <var>M</var></code>,
where <var>E_1</var> through <var>E_n</var> are elementary matrices 
whose entries are polynomials in <var>v</var>,
</p>
<p>(3) <code>|det (<var>M</var>)| = |det (<var>M2</var>)|</code>,
</p>
<p>Note: This function doesn't check that every entry is a polynomial in <var>v</var>.  
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>rowop</b><i> (<var>M</var>, <var>i</var>, <var>j</var>, <var>theta</var>)</i>
<a name="IDX2483"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, return the matrix that results from doing the  
row operation <code>R_i &lt;- R_i - theta * R_j</code>. If <var>M</var> doesn't have a row
<var>i</var> or <var>j</var>, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX2484"></a>
</dt>
<dd><p>Return the rank of that matrix <var>M</var>. The rank is the dimension of the
column space. 
</p>
<p>Example:
</p>
<pre class="example">(%i1) rank(matrix([1,2],[2,4]));
(%o1)                                  1
(%i2) rank(matrix([1,b],[c,d]));
Proviso:  {d - b c # 0}
(%o2)                                  2
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>rowswap</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX2485"></a>
</dt>
<dd><p>If <var>M</var> is a matrix, swap rows <var>i</var> and <var>j</var>. If <var>M</var> doesn't have 
a row <var>i</var> or <var>j</var>, signal an error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>toeplitz</b><i> (<var>col</var>)</i>
<a name="IDX2486"></a>
</dt>
<dt><u>Function:</u> <b>toeplitz</b><i> (<var>col</var>, <var>row</var>)</i>
<a name="IDX2487"></a>
</dt>
<dd><p>Return a Toeplitz matrix <var>T</var>. The first first column of <var>T</var> is 
<var>col</var>; except for the first entry, the first row of <var>T</var> is <var>row</var>. 
The default for <var>row</var> is complex conjugate of <var>col</var>. 
</p>
<p>Example:
</p>
<pre class="example">(%i1)  toeplitz([1,2,3],[x,y,z]);

                                  [ 1  y  z ]
                                  [         ]
(%o1)                             [ 2  1  y ]
                                  [         ]
                                  [ 3  2  1 ]
(%i2)  toeplitz([1,1+%i]);

                              [   1     1 - %I ]
(%o2)                         [                ]
                              [ %I + 1    1    ]
</pre></dd></dl>

<dl>
<dt><u>Function:</u> <b>vandermonde_matrix</b><i> ([<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX2488"></a>
</dt>
<dd><p>Return a <var>n</var> by <var>n</var> matrix whose <var>i</var>-th row is 
<code>[1, <var>x_i</var>, <var>x_i</var>^2, ... <var>x_i</var>^(<var>n</var>-1)]</code>. 
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>zerofor</b><i> (<var>M</var>)</i>
<a name="IDX2489"></a>
</dt>
<dt><u>Function:</u> <b>zerofor</b><i> (<var>M</var>, <var>fld</var>)</i>
<a name="IDX2490"></a>
</dt>
<dd><p>Return a zero  matrix that has the same shape as the matrix
<var>M</var>.  Every entry of the zero matrix is the
additive identity of the field <var>fld</var>; the default for
<var>fld</var> is <var>generalring</var>.
</p>
<p>The first argument <var>M</var> should be a square matrix or a
non-matrix. When <var>M</var> is a matrix, each entry of <var>M</var> can be a
square matrix - thus <var>M</var> can be a blocked Maxima matrix. The
matrix can be blocked to any (finite) depth.
</p>
<p>See also <code>identfor</code>
</p></dd></dl>

<dl>
<dt><u>Function:</u> <b>zeromatrixp</b><i> (<var>M</var>)</i>
<a name="IDX2491"></a>
</dt>
<dd><p>If <var>M</var> is not a block matrix, return <code>true</code> if 
<code>is (equal (<var>e</var>, 0))</code> is true for each element <var>e</var> of the matrix 
<var>M</var>.  If <var>M</var> is a block matrix, return <code>true</code> if <code>zeromatrixp</code>
evaluates to <code>true</code> for each element of <var>e</var>.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC320" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_59.html#SEC323" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
