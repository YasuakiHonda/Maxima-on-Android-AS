<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 20. Tensoren</title>

<meta name="description" content="Maxima Manual: 20. Tensoren">
<meta name="keywords" content="Maxima Manual: 20. Tensoren">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Tensoren"></a>
<a name="SEC128"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_19.html#SEC127" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 20. Tensoren </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC129">20.1 Tensorpakete in Maxima</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC130">20.2 Paket <small>ITENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC143">20.3 Paket <small>CTENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC157">20.4 Paket <small>ATENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Tensorpakete-in-Maxima"></a>
<a name="SEC129"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.1 Tensorpakete in Maxima </h2>

<p>Maxima hat drei verschiedene Pakete, um mit Tensoren zu rechnen.  Das Paket
<code>ctensor</code> implementiert das Rechnen mit Tensoren in der
Koordinatendarstellung und das Paket <code>itensor</code> das Rechnen in einer
Indexnotation.  Das Paket <code>atensor</code> erlaubt die algebraische Manipulation
von Tensoren in verschiedenen Algebren.
</p>
<p>Beim Rechnen in einer Koordinatendarstellung mit dem Paket <code>ctensor</code> werden
Tensoren als Arrays oder Matrizen dargestellt.  Operationen mit Tensoren wie die
Tensorverj&uuml;ngung oder die kovariante Ableitung werden ausgef&uuml;hrt als
Operationen mit den Komponenten des Tensors, die in einem Array oder einer
Matrix gespeichert sind.
</p>
<p>Beim Rechnen in der Indexnotation mit dem Paket <code>itensor</code> werden Tensoren
als Funktionen ihrer kovarianten und kontravarianten Indizes sowie den
Ableitungen nach den Komponenten dargestellt.  Operationen wie die
Tensorverj&uuml;ngung oder die kovariante Ableitung werden ausgef&uuml;hrt, in dem die
Indizes manipuliert werden.
</p>
<p>Die beiden genannten Pakete <code>itensor</code> und <code>ctensor</code> f&uuml;r die
Behandlung von mathematischen Problemen im Zusammenhang mit der Riemannschen
Geometrie haben verschiedene Vor- und Nachteile, die sich erst anhand des zu
behandelnden Problems und dessen Schwierigkeitsgrad zeigen.  Folgenden
Eigenschaften der beiden Implementierungen sollten beachtet werden:
</p>
<p>Die Darstellung von Tensoren und Tensoroperationen in einer expliziten
Koordinatendarstellung vereinfacht die Nutzung des Paketes <code>ctensor</code>.  Die
Spezifikation der Metrik und die Ableitung von Tensoren sowie von Invarianten
ist unkompliziert.  Trotz Maximas Methoden f&uuml;r die Vereinfachung von
Ausdr&uuml;cken kann jedoch eine komplexe Metrik mit komplizierten funktionalen
Abh&auml;ngigkeiten der Koordinaten leicht zu sehr gro&szlig;en Ausdr&uuml;cken
f&uuml;hren, die die Struktur eines Ergebnisses verbergen.  Weiterhin k&ouml;nnen
Rechnungen zu sehr gro&szlig;en Zwischenergebnisse f&uuml;hren, die zu einem
Programmabbruch f&uuml;hren, bevor die Rechnung beendet werden kann.  Jedoch kann
der Nutzer mit einiger Erfahrung viele dieser Probleme vermeiden.
</p>
<p>Aufgrund der besonderen Weise, wie Tensoren und Tensoroperationen als
symbolische Operationen ihrer Indizes dargestellt werden, k&ouml;nnen Ausdr&uuml;cke,
die in einer Koordinatendarstellung sehr unhandlich sind, mit Hilfe spezieller
Routinen f&uuml;r symmetrische Objekte in <code>itensor</code> manchmal erheblich
vereinfacht werden.  Auf diese Weise kann die Struktur gro&szlig;er Ausdr&uuml;cke
transparenter sein.  Auf der anderen Seite kann die Spezifikation einer Metrik,
die Definition von Funktionen und die Auswertung von abgeleiteten indizierten
Objekten f&uuml;r den Nutzer schwierig sein.
</p>

<p>Mit dem Paket <code>itensor</code> k&ouml;nnen Ableitungen nach einer indizierten
Variablen ausgef&uuml;hrt werden, wodurch es m&ouml;glich ist, <code>itensor</code> auch
f&uuml;r Probleme im Zusammenhang mit dem Lagrange- oder Hamiltonian-Formalismus
einzusetzen.  Da es m&ouml;glich ist, die Lagrangeschen Feldgleichungen nach einer
indizierten Variablen abzuleiten, k&ouml;nnen zum Beispiel die
Euler-Lagrange-Gleichungen in einer Indexnotation aufgestellt werden.  Werden
die Gleichungen mit der Funktion <code><a href="#ic_005fconvert">ic_convert</a></code> in eine
Komponentendarstellung f&uuml;r das Paket <code>ctensor</code> transformiert, k&ouml;nnen
die Feldgleichungen in einer bestimmten Koordinatendarstellung gel&ouml;st werden.
Siehe dazu die ausf&uuml;hrlichen Beispiele in <code>einhil.dem</code> und
<code>bradic.dem</code>.
</p>

<hr size="6">
<a name="Paket-itensor"></a>
<a name="SEC130"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC129" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC131" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.2 Paket <small>ITENSOR</small> </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC131">20.2.1 Einf&uuml;hrung in <small>ITENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC132">20.2.2 Funktionen und Variablen f&uuml;r <small>ITENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-itensor"></a>
<a name="SEC131"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC130" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.1 Einf&uuml;hrung in <small>ITENSOR</small> </h3>












<p>Das Paket <code>itensor</code> f&uuml;r das Rechnen mit Tensoren in der Indexnotation
wird mit dem Kommando <code>load(itensor)</code> geladen.  Mit dem Kommando
<code>demo(tensor)</code> wird eine Liste mit verschiedenen Beispielen angezeigt.
</p>

<p>Im Paket <code>itensor</code> werden Tensoren als indiziertes Objekte dargestellt.
Ein indiziertes Objekt ist eine Funktion mit drei Gruppen an Indizes, die die
kovarianten, kontravarianten und Ableitungsindizes eines Tensors darstellen.
Das erste Argument der Funktion ist eine Liste der kovarianten Indizes und das
zweite Argument die Liste der kontravarianten Indizes.  Hat der Tensor keine
entsprechenden Komponenten, dann wird eine leere Liste als Argument angegeben.
Zum Beispiel repr&auml;sentiert <code>g([a,b], [c]</code> einen Tensor <code>g</code>, der zwei
kovariante Indizes <code>[a,b]</code>, einen kontravarianten Index <code>[c]</code> und
keinen Ableitungsindex hat.  Mit der Funktion <code><a href="#ishow">ishow</a></code> werden Tensoren
in einer besonderen Schreibweise ausgegeben.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) g([a,b], [c]);
(%o2)                    g([a, b], [c])

(%i3) ishow(g([a,b], [c]))$
                               c
(%t3)                         g
                               a b
</pre>

<p>Ableitungsindizes werden als weitere Argumente der Funktion hinzugef&uuml;gt, die
den Tensor repr&auml;sentiert.  Ableitungsindizes k&ouml;nnen vom Nutzer angegeben
oder bei der Ableitung von Tensoren von Maxima hinzugef&uuml;gt werden.  Im
Allgemeinen ist die Differentiation kommutativ, so dass die Reihenfolge der
Ableitungsindizes keine Rolle spielt.  Daher werden die Indizes von Maxima
bei der Vereinfachung mit Funktionen wie <code><a href="#rename">rename</a></code> alphabetisch sortiert.
Dies ist jedoch nicht der Fall, wenn bewegte Bezugssysteme genutzt werden, was
mit der Optionsvariablen <code><a href="#iframe_005fflag">iframe_flag</a></code> angezeigt wird, die in diesem Fall
den Wert <code>true</code> erh&auml;lt.  Es ist zu beachten, dass mit dem Paket
<code>itensor</code> Ableitungsindizes nicht angehoben werden k&ouml;nnen und
nur als kovariante Indizes auftreten.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(t([a,b],[c],j,i))$
                             c
(%t2)                       t
                             a b,j i
(%i3) ishow(rename(%))$
                             c
(%t3)                       t
                             a b,i j
(%i4) ishow(t([a,b],[c],j,i) - t([a,b],[c],i,j))$
                        c          c
(%t4)                  t        - t
                        a b,j i    a b,i j
(%i5) ishow(rename(%))$
(%t5)                           0
(%i6) iframe_flag:true;
(%o6)                         true
(%i7) ishow(t([a,b],[c],j,i) - t([a,b],[c],i,j))$
                        c          c
(%t7)                  t        - t
                        a b,j i    a b,i j
(%i8) ishow(rename(%))$
                        c          c
(%t8)                  t        - t
                        a b,j i    a b,i j
</pre>
<p>Das folgende Beispiel zeigt einen Ausdruck mit verschiedenen Ableitungen eines
Tensors <code>g</code>.  Ist <code>g</code> der metrische Tensor, dann entspricht das
Ergebnis der Definition des Christoffel-Symbols der ersten Art.
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(1/2*(idiff(g([i,k],[]),j) + idiff(g([j,k],[]),i) 
                                      - idiff(g([i,j],[]),k)))$
                    g      + g      - g
                     j k,i    i k,j    i j,k
(%t2)               ------------------------
                               2
</pre>

<p>Tensoren werden standardm&auml;&szlig;ig nicht als symmetrisch angenommen.  Erh&auml;lt
die Optionsvariable <code><a href="#allsym">allsym</a></code> den Wert <code>true</code>, dann werden alle
Tensoren als symmetrisch in den kovarianten und kontravarianten Indizes
angenommen.
</p>

<p>Das Paket <code>itensor</code> behandelt Tensoren im Allgemeinen als opake Objekte.
Auf Tensorgleichungen werden algebraischen Regeln insbesondere Symmetrieregeln
und Regeln f&uuml;r die Tensorverj&uuml;ngung angewendet.  Weiterhin kennt
<code>itensor</code> die kovariante Ableitung, Kr&uuml;mmung und die Torsion.  Rechnungen
k&ouml;nnen in bewegten Bezugssystemen ausgef&uuml;hrt werden.
</p>

<p>Beispiele:
</p>
<p>Die folgenden Beispiele zeigen einige Anwendungen des Paketes <code>itensor</code>.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
                %4 %5
(%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
        i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                         + e p       + e   p    ))/2
                                              i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %7                    %6 %7
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %7 i             %6    i j %7      i,j

                                             %6 %7
                                        - ifg      v   ifb      )/2
                                                    %6    %7 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
</pre>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-itensor"></a>
<a name="SEC132"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC131" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC133" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.2 Funktionen und Variablen f&uuml;r <small>ITENSOR</small> </h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC133">20.2.2.1 Behandlung indizierter Gr&ouml;&szlig;en</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC134">20.2.2.2 Tensorsymmetrien</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC135">20.2.2.3 Tensoranalysis</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC136">20.2.2.4 Tensoren in gekr&uuml;mmten R&auml;umen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC137">20.2.2.5 Begleitende Vielbeine</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC138">20.2.2.6 Torsion und Nichtmetrizit&auml;t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC139">20.2.2.7 Gra&szlig;mann-Algebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC140">20.2.2.8 Exportiere als TeX</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC141">20.2.2.9 Schnittstelle zum Paket <small>CTENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC142">20.2.2.10 Reservierte Bezeichner</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Behandlung-indizierter-Gr_00f6_00dfen"></a>
<a name="SEC133"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC132" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC134" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.1 Behandlung indizierter Gr&ouml;&szlig;en </h4>

<p><a name="canten"></a>
</p><dl>
<dt><u>Funktion:</u> <b>canten</b><i> (<var>expr</var>)</i>
<a name="IDX1007"></a>
</dt>
<dd>
<p>Ist vergleichbar mit der Funktion <code><a href="#rename">rename</a></code> und vereinfacht den Ausdruck
<var>expr</var> indem gebundene Indizes umbenannt und permutiert werden.  Wie die
Funktion <code>rename</code> kann <code>canten</code> nur Ausdr&uuml;cke mit Summen von
Tensorprodukten vereinfachen, in denen keine Ableitungen nach Tensorkomponenten
auftreten.  Daher sollte <code>canten</code> nur verwendet werden, wenn sich mit
der Funktion <code><a href="#canform">canform</a></code> nicht die gew&uuml;nschte Vereinfachung eines
Ausdrucks erzielen l&auml;sst.
</p>

<p>Das Ergebnis der Funktion <code>canten</code> ist mathematisch nur korrekt, wenn
die Tensoren symmetrisch in ihren Indizes sind.  Hat die Optionsvariable 
<code><a href="#allsym">allsym</a></code> <em>nicht</em> den Wert <code>true</code>, bricht <code>canten</code> mit einer
Fehlermeldung ab.
</p>
<p>Siehe auch die Funktion <code><a href="#concan">concan</a></code>, mit der Ausdr&uuml;cke mit Tensoren
ebenfalls vereinfacht werden k&ouml;nnen, wobei <code>concan</code> zus&auml;tzlich
Tensorverj&uuml;ngungen ausf&uuml;hrt.
</p></dd></dl>

<p><a name="changename"></a>
</p><dl>
<dt><u>Funktion:</u> <b>changename</b><i> (<var>old</var>, <var>new</var>, <var>expr</var>)</i>
<a name="IDX1008"></a>
</dt>
<dd>
<p>&Auml;ndert den Namen aller Tensoren im Ausdruck <var>expr</var> von
<var>old</var> nach <var>new</var>.  Das Argument <var>old</var> kann ein Symbol oder eine
Liste der Form <code>[<var>name</var>, <var>m</var>, <var>n</var>]</code> sein.  Im letzteren Fall
werden nur die Tensoren zu <var>new</var> umbenannt, die den Namen <var>name</var>
sowie <var>m</var> kovariante und <var>n</var> kontravariante Indizes haben.
</p>
<p>Beispiel:
</p>
<p>In diesem Beispiel wird der Name <var>c</var> zu <var>w</var> ge&auml;ndert.
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) expr:a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e$

(%i3) ishow(changename(c, w, expr))$
                                  k
(%t3)                 d e w    + a    b
                           x y    i j  u,v
</pre></dd></dl>

<p><a name="components"></a>
</p><dl>
<dt><u>Funktion:</u> <b>components</b><i> (<var>tensor</var>, <var>expr</var>)</i>
<a name="IDX1009"></a>
</dt>
<dd>
<p>Erlaubt die Zuweisung von Werten an die Komponenten eines Tensors <var>tensor</var>,
die mit dem Argument <var>expr</var> angegeben werden.  Immer wenn der Tensor
<var>tensor</var> mit all seinen Indizes in einem Ausdruck auftritt, werden die
Komponenten mit den angegebenen Werten substituiert.  Der Tensor muss die Form
<code>t([...],[...])</code> haben, wobei die Listen auch leer sein k&ouml;nnen.  Das
Argument <var>expr</var> ist irgendein Ausdruck, der dieselben freien Indizes wie
der Tensor <var>tensor</var> hat.  Sollen Werte an einen Metriktensor zugewiesen
werden, der Dummy-Indizes hat, so muss auf die Benennung der Indizes
sorgf&auml;ltig geachtet werden, um das Auftreten von Mehrfachen Dummy-Indizes zu
vermeiden.  Mit der Funktion <code><a href="#remcomps">remcomps</a></code> werden Zuweisungen der Funktion
<code>components</code> an die Komponenten eines Tensors entfernt.
</p>

<p>Es muss beachtet werden, dass die Funktion <code>components</code> nur den Typ eines
Tensors, aber nicht die Ordnung der Indizes beachtet.  Werden daher Werte
an die Komponenten der Tensoren <code>x([i,-j],[])</code>, <code>x([-j,i],[])</code> oder
<code>x([i],[j])</code> zugewiesen, ergibt sich jeweils dasselbe Ergebnis.
</p>

<p>Komponenten k&ouml;nnen einem indizierten Ausdruck auf vier verschiedene Methoden
zugeordnet werden.  Zwei Methoden nutzen die Funktion <code>components</code>.
</p>

<p>1) Als ein indizierte Ausdruck:
</p>
<pre class="example">(%i2) components(g([],[i,j]), e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p
</pre>

<p>2) Als eine Matrix:
</p>
<pre class="example">(%i5) lg:-ident(4)$ lg[1,1]:1$ lg;
                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]

(%i6) components(g([i,j],[]), lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1
</pre>

<p>3) Als eine Funktion: Die Werte der Komponenten eines Tensors werden durch eine
Funktion gegeben.
</p>
<pre class="example">(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l
</pre>

<p>4) Mit Mustern und Regeln: Im Folgenden wird ein Beispiel mit den Funktionen
<code><a href="maxima_24.html#defrule">defrule</a></code> und <code><a href="maxima_24.html#applyb1">applyb1</a></code> gezeigt.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n
</pre></dd></dl>

<p><a name="concan"></a>
</p><dl>
<dt><u>Funktion:</u> <b>concan</b><i> (<var>expr</var>)</i>
<a name="IDX1010"></a>
</dt>
<dd>
<p>Ist vergleichbar mit der Funktion <code><a href="#canten">canten</a></code>.  Im Unterschied zu
<code>canten</code> werden zus&auml;tzlich Tensorverj&uuml;ngungen ausgef&uuml;hrt.
</p></dd></dl>

<p><a name="contract"></a>
</p><dl>
<dt><u>Funktion:</u> <b>contract</b><i> (<var>expr</var>)</i>
<a name="IDX1011"></a>
</dt>
<dd>
<p>F&uuml;hrt die Tensorverj&uuml;ngungen im Ausdruck <var>expr</var> aus, die beliebige
Summen und Produkte sein k&ouml;nnen.  <code>contract</code> nutzt die Informationen,
die f&uuml;r die Tensoren mit der Funktion <code><a href="#defcon">defcon</a></code> definiert sind.  Die
besten Ergebnisse werden erzielt, wenn der Ausdruck <var>expr</var> vollst&auml;ndig
expandiert wird.  Die Funktion <code><a href="maxima_9.html#radexpand">radexpand</a></code> expandiert Produkte und
Potenzen von Summen am schnellsten, sofern keine Variablen im Nenner der Terme
auftreten.  Die Optionsvariable <code><a href="maxima_17.html#gcd">gcd</a></code> sollte den Wert <code>false</code> haben,
wenn das K&uuml;rzen durch einen gr&ouml;&szlig;ten gemeinsamen Teiler nicht notwendig
ist.
</p></dd></dl>

<p><a name="contractions"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>contractions</b>
<a name="IDX1012"></a>
</dt>
<dd><p>Die Liste <code><a href="#contractions">contractions</a></code> enth&auml;lt die Tensoren, die mit der Funktion
<code>defcon</code> die Eigenschaft einer Tensorverj&uuml;ngung erhalten haben.
</p></dd></dl>

<p><a name="defcon"></a>
</p><dl>
<dt><u>Funktion:</u> <b>defcon</b><i> (<var>tensor_1</var>)</i>
<a name="IDX1013"></a>
</dt>
<dt><u>Funktion:</u> <b>defcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</i>
<a name="IDX1014"></a>
</dt>
<dd>
<p>Gibt einem Tensor <var>tensor_1</var> die Eigenschaft, dass die Tensorverj&uuml;ngung
des Produktes <var>tensor_1</var> mit <var>tensor_2</var> das Ergebnis <var>tensor_3</var>
hat.  Wird nur ein Argument <var>tensor_1</var> angegeben, dann hat die
Tensorverj&uuml;ngung f&uuml;r jeden Tensor <code>tensor</code>, der die korrekten
Indizes hat, das Ergebnis <code>tensor</code> mit neuen Indizes, die die
Tensorverj&uuml;ngung widerspiegeln.
</p>

<p>Wird zum Beispiel die Metrik als <code>imetric: g</code> gesetzt, dann wird
mit <code>defcon(g)</code> das Hochstellen und Herunterstellen der Indizes mit dem
Metriktensor definiert.
</p>

<p>Wird <code>defcon</code> wiederholt f&uuml;r einen Tensor aufgerufen, ist jeweils die
letzte Definition wirksam.
</p>

<p>Die Liste <code><a href="#contractions">contractions</a></code> enth&auml;lt die Tensoren, die mit der Funktion
<code>defcon</code> die Eigenschaft einer Tensorverj&uuml;ngung erhalten haben.
</p></dd></dl>

<p><a name="dispcon"></a>
</p><dl>
<dt><u>Funktion:</u> <b>dispcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, &hellip;)</i>
<a name="IDX1015"></a>
</dt>
<dt><u>Funktion:</u> <b>dispcon</b><i> (all)</i>
<a name="IDX1016"></a>
</dt>
<dd>
<p>Zeigt die Kontraktionseigenschaften der Tensoren <var>tensor_1</var>, <var>tensor_2</var>,
&hellip; wie sie mit der Funktion <code><a href="#defcon">defcon</a></code> definiert wurden.  Das Kommando
<code>dispcon(all)</code> zeigt alle vom Nutzer definierten Kontraktionseigenschaften.
</p>
<p>Beispiel:
</p>
<p>Wird das Paket <code>itensor</code> geladen, gibt <code>dispcon</code> das folgende
Ergebnis.
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) dispcon(all);
(%o2)      [[[ifr, ifri, ifg]], [[ifg, ifg, kdelta]]]
</pre></dd></dl>

<p><a name="entertensor"></a>
</p><dl>
<dt><u>Funktion:</u> <b>entertensor</b><i> (<var>name</var>)</i>
<a name="IDX1017"></a>
</dt>
<dd>
<p>Die Funktion <code>entertensor</code> erm&ouml;glicht die Eingabe eines indizierten
Tensors mit einer beliebigen Anzahl an Tensorindizes und Ableitungen.  Es kann
ein einzelner Index oder eine Liste mit Indizes angegeben werden.  Die Liste
kann eine leere Liste sein.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                               k
(%t2)                         a
                               i j
</pre></dd></dl>

<p><a name="flipflag"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>flipflag</b>
<a name="IDX1018"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat die Optionsvariable <code>flipflag</code> den Wert <code>false</code>, werden die
Indizes von der Funktion <code><a href="#rename">rename</a></code> bei der Umbenennung in der Reihenfolge
der kontravarianten Indizes sortiert, ansonsten in der Reihenfolge der
kovarianten Indizes.
</p>
<p>Siehe auch das Beispiel f&uuml;r die Funktion <code>rename</code>.
</p>

</dd></dl>

<p><a name="icounter"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>icounter</b>
<a name="IDX1019"></a>
</dt>
<dd><p>Standardwert: <code>0</code>
</p>

<p>Enth&auml;lt die laufende Nummer, um den n&auml;chsten Dummy-Index zu bilden.
<code>icounter</code> wird automatisch erh&ouml;ht, bevor der neue Index gebildet wird.
Dem Wert <code>icounter</code> wird er Pr&auml;fix <code><a href="#idummyx">idummyx</a></code> vorangestellt.  Der
Standardwert von <code>idummyx</code> ist <code>%</code>.
</p></dd></dl>

<p><a name="idummy"></a>
</p><dl>
<dt><u>Funktion:</u> <b>idummy</b><i> ()</i>
<a name="IDX1020"></a>
</dt>
<dd>
<p>Erh&ouml;ht den Wert der laufenden Nummer <code><a href="#icounter">icounter</a></code> und gibt einen neuen
Index zur&uuml;ck, indem der Pr&auml;fix <code><a href="#idummyx">idummyx</a></code> der Nummer <code>icounter</code>
vorangestellt wird.  Siehe auch die Funktion <code><a href="#indices">indices</a></code>.
</p></dd></dl>

<p><a name="idummyx"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>idummyx</b>
<a name="IDX1021"></a>
</dt>
<dd><p>Standardwert: <code>%</code>
</p>

<p>Enth&auml;lt den Pr&auml;fix, der einem neuen Index vorangestellt wird, der mit der
Funktion <code><a href="#idummy">idummy</a></code> gebildet wird.
</p></dd></dl>

<p><a name="indexed_005ftensor"></a>
</p><dl>
<dt><u>Funktion:</u> <b>indexed_tensor</b><i> (<var>tensor</var>)</i>
<a name="IDX1022"></a>
</dt>
<dd>
<p>Muss ausgef&uuml;hrt werden, bevor einem Tensors <var>tensor</var> Komponenten
zugewiesen werden, f&uuml;r die bereits interne Werte vorliegen wie f&uuml;r
<code><a href="#ichr1">ichr1</a></code>, <code><a href="#ichr2">ichr2</a></code> oder <code><a href="#icurvature">icurvature</a></code>.  Siehe das Beispiel
zur Funktion <code>icurvature</code>.
</p></dd></dl>

<p><a name="indices"></a>
</p><dl>
<dt><u>Funktion:</u> <b>indices</b><i> (<var>expr</var>)</i>
<a name="IDX1023"></a>
</dt>
<dd>
<p>Gibt eine Liste mit zwei Elementen zur&uuml;ck.  Das erste Element ist eine Liste
mit den Indizes im Ausdruck <var>expr</var> die frei sind, also nur einmal auftreten.
Das zweite Elemente ist eine Liste mit den Indizes, &uuml;ber die summiert wird,
die also im Ausdruck genau zweimal auftreten.
</p>

<p>Ein Tensorprodukt mit einem Index der mehr als zweimal auftritt, ist nicht
korrekt formuliert.  Die Funktion <code>indices</code> gibt in einem solchen Fall
jedoch keinen Fehler aus.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                         k l      j m p
(%t2)                   a        b
                         i j,m n  k o,q r
(%i3) indices(%);
(%o3)          [[l, p, i, n, o, q, r], [k, j, m]]
</pre></dd></dl>

<p><a name="ishow"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ishow</b><i> (<var>expr</var>)</i>
<a name="IDX1024"></a>
</dt>
<dd>
<p>Zeigt den Ausdruck <var>expr</var> an, wobei Tensoren im Ausdruck mit tiefgestellten
kovarianten Indizes und hochgestellten kontravarianten Indizes sowie die
Ableitungen mit durch ein Komma getrennten tiefgestellte Indizes angezeigt
werden.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(a([i,j], [k], v,w))$
                             k
(%t2)                       a
                             i j,v w
</pre></dd></dl>

<p><a name="kdels"></a>
</p><dl>
<dt><u>Funktion:</u> <b>kdels</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1025"></a>
</dt>
<dd>
<p><code>kdels</code> gibt wie die Funktion <code><a href="#kdelta">kdelta</a></code> ein Kronecker-Delta zur&uuml;ck.
Im Unterschied zu <code>kdelta</code> ist das Kronecker-Delta der Funktion
<code>kdels</code> symmetrisch.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b
</pre></dd></dl>

<p><a name="kdelta"></a>
</p><dl>
<dt><u>Funktion:</u> <b>kdelta</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1026"></a>
</dt>
<dd>
<p>Ist das verallgemeinerte Kronecker-Delta im <code>itensor</code>-Paket.  Das Argument
<var>L1</var> ist die Liste der kovarianten und <var>L2</var> der kontravarianten 
Indizes.  <code>kdelta([i],[j])</code> gibt das einfache Kronecker-Delta zur&uuml;ck.
</p>



<p>Das <code>itensor</code>-Paket erlaubt die Definition des Kronecker-Delta nur mit
kovarianten oder kontravarianten Indizes, wie zum Beispiel
<code>kdelta([i,j],[])</code>.  Mit diesen Gr&ouml;&szlig;en kann gerechnet werden, sie
sind jedoch keine Tensoren.
</p></dd></dl>

<p><a name="lc_005fl"></a>
</p><dl>
<dt><u>Regel:</u> <b>lc_l</b>
<a name="IDX1027"></a>
</dt>
<dd>
<p><code>lc_l</code> ist eine Regel, um Ausdr&uuml;cke zu vereinfachen, die
Levi-Civita-Symbole enthalten.  Zusammen mit der Regel <code><a href="#lc_005fu">lc_u</a></code> kann die
Regel zum Beispiel mit der Funktion <code><a href="maxima_24.html#applyb1">applyb1</a></code> angewendet werden, um
Ausdr&uuml;cke effizienter zu vereinfachen, als durch eine Auswertung des Symbols
<code>levi_civita</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0
</pre></dd></dl>

<p><a name="lc_005fu"></a>
</p><dl>
<dt><u>Regel:</u> <b>lc_u</b>
<a name="IDX1028"></a>
</dt>
<dd>
<p><code>lc_u</code> ist eine Regel, um Ausdr&uuml;cke zu vereinfachen, die
Levi-Civita-Symbole enthalten.  Zusammen mit der Regel <code>lc_c</code> kann die
Regel zum Beispiel mit der Funktion <code><a href="maxima_24.html#applyb1">applyb1</a></code> angewendet werden, um
Ausdr&uuml;cke effizienter zu vereinfachen, als durch eine Auswertung des Symbols
<code>levi_civita</code>.  Siehe <code><a href="#lc_005fl">lc_l</a></code> f&uuml;r Beispiele.
</p></dd></dl>

<p><a name="lc2kdt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lc2kdt</b><i> (<var>expr</var>)</i>
<a name="IDX1029"></a>
</dt>
<dd>
<p>Vereinfacht den Ausdruck <var>expr</var> mit Levi-Civita-Symbolen.  Wenn m&ouml;glich
werden diese zu Kronecker-Delta-Symbolen vereinfacht.  Im Unterschied zu der
Auswertung eines Ausdrucks mit Levi-Civita-Symbolen, vermeidet die Funktion
<code>lc2kdt</code> das Einf&uuml;hren von numerischen Indizes, die f&uuml;r eine weitere
symbolische Vereinfachung zum Beispiel mit den Funktionen <code><a href="#rename">rename</a></code> oder
<code><a href="#contract">contract</a></code> nicht geeignet sind.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l
</pre>

<p>Die Funktion <code>lc2kdt</code> ben&ouml;tigt in einigen F&auml;llen den Metriktensor.
Ist der Metriktensor zuvor nicht mit der Funktion <code><a href="#imetric">imetric</a></code> definiert,
dann meldet Maxima einen Fehler.
</p>
<pre class="example">(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j
</pre></dd></dl>

<p><a name="levi_005fcivita"></a>
</p><dl>
<dt><u>Funktion:</u> <b>levi_civita</b><i> (<var>L</var>)</i>
<a name="IDX1030"></a>
</dt>
<dd><p>Ist der Levi-Civita-Tensor, der auch Permutationstensor genannt wird.  Der
Tensor hat den Wert <code>1</code>, wenn die Liste <var>L</var> eine gerade Permutation
ganzer Zahlen ist, den Wert <code>-1</code> f&uuml;r eine ungerade Permutation und
ansonsten den Wert <code>0</code>.
</p>
<p>Beispiel:
</p>
<p>F&uuml;r eine Kreisbewegung ist die Bahngeschwindigkeit <code>v</code> das Kreuzprodukt
aus Winkelgeschwindigkeit <code>w</code> und Ortsvektor <code>r</code>.  Wir haben also
<code>v = w x r</code>.  Hier wird eine tensorielle Schreibweise des Kreuzproduktes
mit dem Levi-Civita-Tensor eingef&uuml;hrt.  Der Ausdruck wird sodann f&uuml;r die
erste Komponente zu der bekannten Definition des Kreuzproduktes vereinfacht.
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(v([],[a])=
           'levi_civita([],[a,b,c])*w([b],[])*r([c],[]))$
                    a              a b c
(%t2)              v  = levi_civita      w  r
                                          b  c
(%i3) ishow(subst([a=1],%))$
                    1              1 b c
(%t3)              v  = levi_civita      w  r
                                          b  c
(%i4) ishow(ev(%, levi_civita))$
                      1         1 b c
(%t4)                v  = kdelta      w  r
                                1 2 3  b  c
(%i5) ishow(expand(ev(%, kdelta)))$
        1         b       c               c       b
(%t5)  v  = kdelta  kdelta  w  r  - kdelta  kdelta  w  r
                  2       3  b  c         2       3  b  c
(%i6) ishow(contract(%))$
                        1
(%t6)                  v  = w  r  - r  w
                             2  3    2  3
</pre>
<p>In diesem Beispiel wird das Spatprodukt von drei Vektoren <code>a</code>, <code>b</code> und
<code>b</code> mit dem Levi-Civita-Tensor definiert und dann vereinfacht.
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(levi_civita([],[i,j,k])*a([i],[])*b([j],[])*c([k],[]))$
                            i j k
(%t2)                 kdelta      a  b  c
                            1 2 3  i  j  k
(%i3) ishow(contract(expand(ev(%,kdelta))))$
(%t3) a  b  c  - b  a  c  - a  c  b  + c  a  b  + b  c  a
       1  2  3    1  2  3    1  2  3    1  2  3    1  2  3
                                                       - c  b  a
                                                          1  2  3
</pre></dd></dl>

<p><a name="listoftens"></a>
</p><dl>
<dt><u>Funktion:</u> <b>listoftens</b><i> (<var>expr</var>)</i>
<a name="IDX1031"></a>
</dt>
<dd>
<p>Gibt eine Liste mit allen Tensoren zur&uuml;ck, die im Argument <var>expr</var>
enthalten sind.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                  k
(%t2)                 d e c    + a    b
                           x y    i j  u,v
(%i3) ishow(listoftens(%))$
                        k
(%t3)                 [a   , b   , c   , d]
                        i j   u,v   x y
</pre></dd></dl>

<p><a name="remcomps"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1032"></a>
</dt>
<dd>
<p>Entfernt alle Werte von den Komponenten des Tensors <var>tensor</var>, die einen
Wert mit der Funktion <code><a href="#components">components</a></code> erhalten haben.
</p></dd></dl>

<p><a name="remcon"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remcon</b><i> (<var>tensor_1</var>, &hellip;, <var>tensor_n</var>)</i>
<a name="IDX1033"></a>
</dt>
<dt><u>Funktion:</u> <b>remcon</b><i> (all)</i>
<a name="IDX1034"></a>
</dt>
<dd>
<p>Entfernt die Eigenschaften der Tensorverj&uuml;ngung von den Tensoren
<var>tensor_1</var>, &hellip;, <var>tensor_n</var>.  <code>remcon(all)</code> entfernt die
Eigenschaften von der Tensorverj&uuml;ngung f&uuml;r alle Tensoren.  Das sind die
Tensoren, die in der Liste <code><a href="#contractions">contractions</a></code> enthalten sind.
</p></dd></dl>

<p><a name="rename"></a>
</p><dl>
<dt><u>Funktion:</u> <b>rename</b><i> (<var>expr</var>)</i>
<a name="IDX1035"></a>
</dt>
<dt><u>Funktion:</u> <b>rename</b><i> (<var>expr</var>, <var>count</var>)</i>
<a name="IDX1036"></a>
</dt>
<dd>
<p>Gibt einen zum Argument <var>expr</var> &auml;quivalenten Ausdruck zur&uuml;ck, wobei die
Summationsindizes mit den Werten aus der liste <code>[%1, %2, ...]</code> umbenannt
sind.  Wird das zus&auml;tzlich das Argument <var>count</var> angegeben, wird die
Nummerierung mit dem Wert <var>count</var> begonnen.  Jeder Summationsindex in einem
Produkt erh&auml;lt einen verschiedenen Namen.  F&uuml;r eine Summe wird der Z&auml;hler
f&uuml;r jeden Term zur&uuml;ckgesetzt.  Auf diese Weise wirkt die Funktion
<code>rename</code> wie eine Vereinfachung eines tensoriellen Ausdrucks.  Hat die
Optionsvariable <code><a href="#allsym">allsym</a></code> den Wert <code>true</code>, werden die Indizes
alphabetisch nach den kovarianten oder kontravarianten Indizes geordnet,
entsprechend dem Wert der Optionsvariablen <code><a href="#flipflag">flipflag</a></code>.  Hat die
Optionsvariable <code>flipflag</code> den Wert <code>true</code>, werden die Indizes
entsprechend der Ordnung der kovarianten Indizes geordnet.  Es ist h&auml;ufig der
Fall, dass das Ordnen sowohl nach den kovarianten als auch den kontravarianten
Indizes einen Ausdruck besser vereinfacht, als allein die Ordnung nach einer
der Indizes.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) allsym: true;
(%o2)                         true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])
             *ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])
             *ichr2([%7,r],[%2])
 -g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])
               *ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])
               *ichr2([%7,r],[%2])$

(%i4) expr: ishow(%)$
       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r
          %4 %5  %6 %7      u          %1         %3         %2
       - g      g      ichr2      ichr2      ichr2      ichr2
                            %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag: true;
(%o5)                         true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r
          %4 %5  %6 %7      u          %1         %3         %2
       - g      g      ichr2      ichr2      ichr2      ichr2
                            %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag: false;
(%o7)                         false
(%i8) rename(%th(2));
(%o8)                           0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7
          %1 %2  %3 %4      %6         %5         %7        u
       - g      g      ichr2      ichr2      ichr2     ichr2
                            %1 %3      %2 %6      %4 r      %5 %7
</pre></dd></dl>


<p><a name="showcomps"></a>
</p><dl>
<dt><u>Funktion:</u> <b>showcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1037"></a>
</dt>
<dd>

<p>Zeigt die Zuweisungen mit der Funktion <code><a href="#components">components</a></code> an die Komponenten des
Tensors <var>tensor</var>.  Die Funktion <code>showcomps</code> kann auch die Komponenten
eines Tensors mit einer h&ouml;heren Stufe als 2 zeigen.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(ctensor)$
(%i2) load(itensor)$
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false
</pre></dd></dl>

<hr size="6">
<a name="Tensorsymmetrien"></a>
<a name="SEC134"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC133" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.2 Tensorsymmetrien </h4>

<p><a name="allsym"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>allsym</b>
<a name="IDX1038"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat die Optionsvariable <code>allsym</code> den Wert <code>true</code>, werden alle
indizierten Gr&ouml;&szlig;en  als symmetrisch in ihren kovarianten und
kontravarianten Indizes angenommen.  Ist der Wert <code>false</code>, werden keine
Symmetrien f&uuml;r die Indizes angenommen.  Die Indizes von Ableitungen werden
immer als symmetrisch angenommen, au&szlig;er wenn die Optionsvariable
<code><a href="#iframe_005fflag">iframe_flag</a></code> den Wert <code>true</code> hat.
</p></dd></dl>

<p><a name="decsym"></a>
</p><dl>
<dt><u>Funktion:</u> <b>decsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, &hellip;], [<var>contr_1</var>, <var>contr_2</var>, &hellip;])</i>
<a name="IDX1039"></a>
</dt>
<dd>
<p>Definiert Symmetrieeigenschaften f&uuml;r den Tensor <var>tensor</var> mit <var>m</var>
kovarianten und <var>n</var> kontravarianten Indizes.  Die Argumente <var>cov_i</var> und
<var>contr_i</var> geben Symmetrieeigenschaften zwischen den kontravarianten und
kontravarianten Indizes an.  Die Argumente haben die Form
<code>symoper(<var>index_1</var>, <var>index_2, ...</var></code>.  <code>symoper</code> ist einer der
Symmetrieeigenschaften <code>sym</code> f&uuml;r symmetrisch, <code>anti</code> f&uuml;r
antisymmetrisch oder <code>cyc</code> f&uuml;r zyklisch und die Argumente <var>index_i</var>
sind ganze Zahlen, die die Position des Index im Tensor <var>tensor</var> angegeben.
Weiterhin ist die Form <code>symoper(all)</code> m&ouml;glich.  In diesem Fall wird
die entsprechende Symmetrieeigenschaft f&uuml;r alle Indizes angenommen.
</p>
<p>Ist zum Beispiel <code>b</code> ein Tensor mit 5 kovarianten Indizes, dann wird mit
<code>decsym(b, 5, 3, [sym(1,2), anti(3,4)], [cyc(all)])</code> definiert, dass
<code>b</code> symmetrisch in den Indizes <code>1</code> und <code>2</code>, antisymmetrisch in
den Indizes <code>3</code> und <code>4</code> sowie zyklisch in allen kontravarianten
Indizes ist.
</p>
<p>Symmetrieeigenschaften, die mit der Funktion <code>decsym</code> definiert werden,
werden von der Funktion <code><a href="#canform">canform</a></code> angewendet.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]
</pre></dd></dl>

<p><a name="remsym"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>)</i>
<a name="IDX1040"></a>
</dt>
<dd>
<p>Entfernt die Symmetrieeigenschaften des Tensors <var>tensor</var>, der <var>m</var>
kovariante und <var>n</var> kontravariante Indizes hat.
</p></dd></dl>

<p><a name="canform"></a>
</p><dl>
<dt><u>Funktion:</u> <b>canform</b><i> (<var>expr</var>)</i>
<a name="IDX1041"></a>
</dt>
<dt><u>Funktion:</u> <b>canform</b><i> (<var>expr</var>, <var>rename</var>)</i>
<a name="IDX1042"></a>
</dt>
<dd>

<p>Vereinfacht den Ausdruck <var>expr</var> indem alle Dummy-Indizes umbenannt und
umgeordnet werden, wobei vorhandene Symmetrieeigenschaften angewendet werden.
Hat die Optionsvariable <code>allsym</code> den Wert <code>true</code>, werden alle Indizes
als symmetrisch angenommen.  Ansonsten werden Symmetrieeigenschaften angewendet,
die mit der Funktion <code><a href="#decsym">decsym</a></code> definiert sind.  Die Dummy-Indizes werden
auf gleiche Weise umbenannt wie von der Funktion <code><a href="#rename">rename</a></code>.  Wird 
<code>canform</code> auf einen gro&szlig;en Ausdruck angewendet, kann die Ausf&uuml;hrung
eine lange Zeit beanspruchen.  Die Rechenzeit kann verk&uuml;rzt werden, indem
zuerst die Funktion <code>rename</code> auf den Ausdruck angewendet wird.
</p>
<p><code>canform</code> kann einen Ausdruck nicht immer in die einfachste Form bringen,
jedoch ist das Ergebnis immer mathematisch korrekt.
</p>
<p>Erh&auml;lt das optionale zweite Argument <var>rename</var> den Wert <code>false</code>, wird
die Umbenennung mit der Funktion <code>rename</code> nicht ausgef&uuml;hrt.
</p>
<p>F&uuml;r ein Beispiel siehe die Funktion <code><a href="#decsym">decsym</a></code>.
</p></dd></dl>

<hr size="6">
<a name="Tensoranalysis"></a>
<a name="SEC135"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC134" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.3 Tensoranalysis </h4>

<p><a name="itensor_005fdiff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>diff</b><i> (<var>expr</var>, <var>v_1</var>, <var>n_1</var>, <var>v_2</var>, <var>n_2</var>, &hellip;)</i>
<a name="IDX1043"></a>
</dt>
<dd>
<p>Ist die gleichnamige Funktion <code><a href="maxima_16.html#diff">diff</a></code> f&uuml;r die Differentiation einer
tensoriellen Gr&ouml;&szlig;e.  <code>diff</code> ist f&uuml;r das Paket <code>itensor</code>
erweitert.  Die tensorielle Gr&ouml;&szlig;e <var>expr</var> wird <var>n_1</var>-mal nach der
Variablen <var>v_1</var>, <var>n_2</var> nach der Variablen <var>v_2</var>, &hellip;
abgeleitet.  Die Argumente <code>v_1</code> k&ouml;nnen ganze Zahlen von <code>1</code>,
&hellip;, <code><a href="#dim">dim</a></code> sein.  In diesem Fall bezeichnen die ganzen Zahlen der Reihe
nach die Indizes, die in der Optionsvariablen <code><a href="#vect_005fcoords">vect_coords</a></code> abgelegt sind.
<code>dim</code> ist die Dimension der tensoriellen Gr&ouml;&szlig;en.
</p>

<p>Weiterhin erlaubt die erweiterte Funktion <code>diff</code> die Berechnung von 
Ableitungen nach indizierten Variablen.  So k&ouml;nnen Ausdr&uuml;cke, die den
Metriktensor und seine Ableitungen enthalten, nach dem Metriktensor und seinen
Ableitungen abgeleitet werden.
</p>


<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor)$

(%i2) depends(v,t);
(%o2)                        [v(t)]
(%i3) ishow(diff(v([i,j],[k])^2, t,1))$
                          k    d    k
(%t3)                  2 v    (-- (v   ))
                          i j  dt   i j
(%i4) ishow(diff(v([i,j],[k])^2, t,2))$
                       2
                 k    d     k          d    k    2
(%t4)         2 v    (--- (v   )) + 2 (-- (v   ))
                 i j    2   i j        dt   i j
                      dt
</pre></dd></dl>

<p><a name="idiff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>idiff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] &hellip;])</i>
<a name="IDX1044"></a>
</dt>
<dd>
<p><code>idiff</code> f&uuml;hrt Ableitungen nach den Koordinaten einer tensoriellen
Gr&ouml;&szlig;e aus.  Im Unterschied dazu f&uuml;hrt die Funktion <code><a href="maxima_16.html#diff">diff</a></code>
Ableitungen nach den unabh&auml;ngigen Variablen aus.  Eine tensorielle Gr&ouml;&szlig;e
erh&auml;lt zus&auml;tzlich den Index <var>v_1</var>, der die Ableitung bezeichnet.
Mehrfache Indizes f&uuml;r Ableitungen werden sortiert, au&szlig;er wenn die
Optionsvariable <code><a href="#iframe_005fflag">iframe_flag</a></code> den Wert <code>true</code> hat.
</p>

<p><code>idiff</code> kann auch die Determinante des Metriktensors ableiten.  Wird zum
Beispiel der Optionsvariablen <code><a href="#imetric">imetric</a></code> der Wert <code>g</code> zugewiesen,
dann hat das Kommando <code>idiff(determinant(g), k)</code> das Ergebnis
<code>2 * determinant(g) * ichr2([%i,k], [%i])</code>, wobei die Dummy-Variable
passend gew&auml;hlt wird.
</p></dd></dl>

<p><a name="liediff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>liediff</b><i> (<var>v</var>, <var>ten</var>)</i>
<a name="IDX1045"></a>
</dt>
<dd>
<p>Berechnet die Lie-Ableitung eines tensoriellen Ausdrucks <var>ten</var> f&uuml;r das
Vektorfeld <var>v</var>.  Das Argument <var>ten</var> kann irgendeine tensorielle
Gr&ouml;&szlig;e sein.  Das Argument <var>v</var> ist der Name eines Vektorfeldes und
wird ohne Indizes angegeben.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j
</pre></dd></dl>

<p><a name="rediff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>rediff</b><i> (<var>ten</var>)</i>
<a name="IDX1046"></a>
</dt>
<dd>
<p>Wertet jedes Auftreten von Substantivformen der Funktion <code><a href="#idiff">idiff</a></code> in
dem tensoriellem Ausdruck <var>ten</var> aus.
</p></dd></dl>

<p><a name="undiff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>undiff</b><i> (<var>expr</var>)</i>
<a name="IDX1047"></a>
</dt>
<dd>
<p>Gibt einen zum Argument <var>expr</var> &auml;quivalenten Ausdruck zur&uuml;ck, in dem
alle Ableitungen von indizierten Gr&ouml;&szlig;en durch Substantivformen der
Funktion <code><a href="#idiff">idiff</a></code> ersetzt sind.
</p>

</dd></dl>

<p><a name="evundiff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>evundiff</b><i> (<var>expr</var>)</i>
<a name="IDX1048"></a>
</dt>
<dd>
<p>Ist &auml;quivalent zur Ausf&uuml;hrung der Funktion <code><a href="#undiff">undiff</a></code>, der die
Funktionen <code><a href="maxima_8.html#ev">ev</a></code> und <code><a href="#rediff">rediff</a></code> nachfolgen.
</p>

<p><code>evundiff</code> erlaubt die Auswertung von Ausdr&uuml;cken, die nicht direkt in
ihrer abgeleiteten Form ausgewertet werden k&ouml;nnen.  So f&uuml;hrt das folgende
Beispiel zu einer Fehlermeldung:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>

<p>Wird jedoch <code>icurvature</code> in der Substantivform verwendet, kann der
Ausdruck mit <code>evundiff</code> ausgewertet werden:
</p>
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre>

<p>Um Christoffel-Symbole abzuleiten, wird die Funktion <code>evundiff</code>
nicht ben&ouml;tigt:
</p>
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre></dd></dl>

<p><a name="flush"></a>
</p><dl>
<dt><u>Funktion:</u> <b>flush</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, &hellip;)</i>
<a name="IDX1049"></a>
</dt>
<dd>
<p>Alle tensoriellen Gr&ouml;&szlig;en <var>tensor_i</var> die im Ausdruck <var>expr</var>
auftreten und keine Ableitungen haben, werden zu Null gesetzt.
</p></dd></dl>

<p><a name="flushd"></a>
</p><dl>
<dt><u>Funktion:</u> <b>flushd</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, &hellip;)</i>
<a name="IDX1050"></a>
</dt>
<dd>
<p>Alle tensoriellen Gr&ouml;&szlig;en <var>tensor_i</var> die im Ausdruck <var>expr</var>
auftreten und Ableitungen haben, werden zu Null gesetzt.
</p></dd></dl>

<p><a name="flushnd"></a>
</p><dl>
<dt><u>Funktion:</u> <b>flushnd</b><i> (<var>expr</var>, <var>tensor</var>, <var>n</var>)</i>
<a name="IDX1051"></a>
</dt>
<dd>
<p>Setzt alle Ableitungen der tensoriellen Gr&ouml;&szlig;e <var>tensor</var> die im Ausdruck
<var>expr</var> auftritt und <var>n</var> oder mehr Ableitungen hat, auf den Wert Null.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></dd></dl>

<p><a name="coord"></a>
</p><dl>
<dt><u>Funktion:</u> <b>coord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, &hellip;)</i>
<a name="IDX1052"></a>
</dt>
<dt><u>Systemvariable:</u> <b>coord</b>
<a name="IDX1053"></a>
</dt>
<dd>
<p>Gibt der tensoriellen Gr&ouml;&szlig;e <var>tensor_i</var> die Eigenschaft, dass die
kovariante Ableitung eines Vektors mit dem Namen <var>tensor_i</var> das Ergebnis
Kronecker-Delta hat.
</p>
<p><code>coord</code> ist auch eine Systemvariable, die alle tensoriellen Gr&ouml;&szlig;en
enth&auml;lt, die mit der Funktion <code>coord</code> die Eigenschaft der kovarianten
Ableitung erhalten haben.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) coord(x);
(%o1)                         done
(%i2) idiff(x([],[i]),j);
(%o2)                   kdelta([j], [i])
(%i3) coord;
(%o3)                          [x]
</pre></dd></dl>

<p><a name="remcoord"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remcoord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, &hellip;)</i>
<a name="IDX1054"></a>
</dt>
<dt><u>Funktion:</u> <b>remcoord</b><i> (all)</i>
<a name="IDX1055"></a>
</dt>
<dd>
<p>Entfernt die mit der Funktion <code><a href="#coord">coord</a></code> definierte Eigenschaft f&uuml;r die
tensoriellen Gr&ouml;&szlig;en <var>tensor_i</var>.  Das Kommando <code>remcoord(all)</code>
entfernt diese Eigenschaft f&uuml;r alle tensoriellen Gr&ouml;&szlig;en.
</p></dd></dl>

<p><a name="makebox"></a>
</p><dl>
<dt><u>Funktion:</u> <b>makebox</b><i> (<var>expr</var>, <var>name</var>)</i>
<a name="IDX1056"></a>
</dt>
<dd>
<p>Zeigt das Argument <var>expr</var> auf die gleiche Weise an wie die Funktion
<code><a href="#ishow">ishow</a></code> mit dem Unterschied, dass der d’Alembert-Operator <var>name</var> im
Ausdruck durch <code>[]</code> ersetzt wird.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) makebox(g([],[i,j])*p([m],[n],i,j),g);
(%o1)                     []p([m], [n])
</pre></dd></dl>

<p><a name="conmetderiv"></a>
</p><dl>
<dt><u>Funktion:</u> <b>conmetderiv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1057"></a>
</dt>
<dd>
<p>Vereinfacht Ausdr&uuml;cke, die kovariante und kontravariante Ableitungen des
Metriktensors enthalten.  <code>conmetderiv</code> kann zum Beispiel die Ableitungen
des kontravarianten Metriktensors in Beziehung zu den Christoffel-Symbolen 
setzen:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></dd></dl>

<p><a name="simpmetderiv"></a>
</p><dl>
<dt><u>Funktion:</u> <b>simpmetderiv</b><i> (<var>expr</var>)</i>
<a name="IDX1058"></a>
</dt>
<dt><u>Funktion:</u> <b>simpmetderiv</b><i> (<var>expr</var>[, <var>stop</var>])</i>
<a name="IDX1059"></a>
</dt>
<dd>
<p>Vereinfacht Ausdr&uuml;cke die Produkte von Ableitungen des Metriktensors
enthalten.  Im besonderen erkennt <code>simpmetderiv</code> die folgenden
Identit&auml;ten:
</p>
<pre class="example">   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d
</pre>
<p>daher ist
</p>
<pre class="example">   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre>
<p>und
</p>
<pre class="example">  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j
</pre>

<p>was aus den Symmetrien der Christoffel-Symbole folgt.
</p>

<p>Die Funktion <code>simpmetderiv</code> akzeptiert einen optionalen Parameter
<var>stop</var>.  Ist dieser vorhanden, stoppt die Funktion nach der ersten
erfolgreichen Substitution in einem Produkt.  <code>simpmetderiv</code> beachtet
ferner die Optionsvariable <code><a href="#flipflag">flipflag</a></code>, welche die Ordnung der Indizes
kontrolliert.
</p>

<p>Siehe auch <code>weyl.dem</code> f&uuml;r Beispiele der Funktionen <code>simpmetderiv</code>
und <code><a href="#conmetderiv">conmetderiv</a></code>, die die Vereinfachung des Weyl-Tensors zeigen.
</p>


<p>Beispiel:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d
</pre></dd></dl>

<p><a name="flush1deriv"></a>
</p><dl>
<dt><u>Funktion:</u> <b>flush1deriv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1060"></a>
</dt>
<dd>
<p>Setzt alle tensoriellen Gr&ouml;&szlig;en, die genau einen Ableitungsindex haben,
auf den Wert Null.
</p></dd></dl>

<p><a name="vect_005fcoords"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>vect_coords</b>
<a name="IDX1061"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>Tensoren k&ouml;nnen durch Angabe von ganzen Zahlen nach den einzelnen Komponenten
abgeleitet werden.  In diesem Fall bezeichnen die ganzen Zahlen der Reihe nach
die Indizes, die in der Optionsvariablen <code>vect_coords</code> abgelegt sind.
</p></dd></dl>

<hr size="6">
<a name="Tensoren-in-gekr_00fcmmten-R_00e4umen"></a>
<a name="SEC136"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC135" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.4 Tensoren in gekr&uuml;mmten R&auml;umen </h4>

<p><a name="imetric"></a>
</p><dl>
<dt><u>Funktion:</u> <b>imetric</b><i> (<var>g</var>)</i>
<a name="IDX1062"></a>
</dt>
<dt><u>Systemvariable:</u> <b>imetric</b>
<a name="IDX1063"></a>
</dt>
<dd>
<p>Spezifiziert die Metrik, indem der Variablen <code>imetric</code> der Wert <code>g</code>
zugewiesen wird.  Die Eigenschaften f&uuml;r die Verj&uuml;ngung von Tensoren werden
mit den Kommandos <code>defcon(<var>g</var>)</code> und
<code>defcon(<var>g</var>, <var>g</var>, kdelta)</code> initialisiert.
</p></dd></dl>

<p><a name="idim"></a>
</p><dl>
<dt><u>Funktion:</u> <b>idim</b><i> (<var>n</var>)</i>
<a name="IDX1064"></a>
</dt>
<dd>
<p>Die Funktion <code>idim</code> setzt die Dimension der Metrik zu <var>n</var>.  Die
Variable <code>dim</code> auf den Wert <var>n</var> gesetzt und die antisymmetrischen
Eigenschaften des Levi-Civita-Symbols f&uuml;r die Dimension <var>n</var>
werden initialisiert.
</p></dd></dl>

<p><a name="ichr1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ichr1</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>])</i>
<a name="IDX1065"></a>
</dt>
<dd>
<p>Gibt das Christoffel-Symbol der ersten Art zur&uuml;ck, das definiert ist als
</p>
<pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre>

<p>Um das Christoffel-Symbol f&uuml;r eine spezielle Metrik auszuwerten, muss der
Optionsvariablen <code><a href="#imetric">imetric</a></code> ein Wert zugewiesen werden.  Siehe dazu das
Beispiel zu <code><a href="#ichr2">ichr2</a></code>.
</p></dd></dl>

<p><a name="ichr2"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ichr2</b><i> ([<var>i</var>, <var>j</var>], [<var>k</var>])</i>
<a name="IDX1066"></a>
</dt>
<dd>
<p>Gibt das Christoffel-Symbol der zweiten Art zur&uuml;ck, das definiert ist als
</p>
<pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></dd></dl>

<p><a name="icurvature"></a>
</p><dl>
<dt><u>Funktion:</u> <b>icurvature</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</i>
<a name="IDX1067"></a>
</dt>
<dd>
<p>Gibt den Riemannschen Kr&uuml;mmungstensor in einer Darstellung mit
Christoffel-Symbolen zur&uuml;ck:
</p>
<pre class="example">            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
</pre></dd></dl>

<p><a name="covdiff"></a>
</p><dl>
<dt><u>Funktion:</u> <b>covdiff</b><i> (<var>expr</var>, <var>v_1</var>, <var>v_2</var>, &hellip;)</i>
<a name="IDX1068"></a>
</dt>
<dd>
<p>Gibt die kovariante Ableitung des Ausdruck <var>expr</var> nach den Variablen
<var>v_i</var> in einer Darstellung mit Christoffel-Symbolen der zweiten Art
<code><a href="#ichr2">ichr2</a></code> zur&uuml;ck.  Um den erhaltenen Ausdruck auszuwerten, kann das 
Kommando <code>ev(<var>expr</var>, ichr2)</code>.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s
(%i6)
</pre></dd></dl>

<p><a name="lorentz-gauge"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lorentz_gauge</b><i> (<var>expr</var>)</i>
<a name="IDX1069"></a>
</dt>
<dd>
<p>Wendet die Lorenz-Eichung an, indem alle indizierten Gr&ouml;&szlig;en in <var>expr</var>
zu Null gesetzt werden, die einen zu einem kontravarianten Index identischen
Ableitungsindex haben.
</p></dd></dl>

<p><a name="igeodesic_005fcoords"></a>
</p><dl>
<dt><u>Funktion:</u> <b>igeodesic_coords</b><i> (<var>expr</var>, <var>name</var>)</i>
<a name="IDX1070"></a>
</dt>
<dd>
<p>Bewirkt, dass nicht abgeleitete Christoffel-Symbole und erste Ableitungen des
Metriktensors im Ausdruck <var>expr</var> verschwinden.  Das Argument <var>name</var>
bezeichnet die Metrik <var>name</var>, wenn im Ausdruck <var>expr</var> vorhanden und die
Christoffel-Symbole werden mit <var>ichr1</var> und <var>ichr2</var> bezeichnet.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0
</pre></dd></dl>

<hr size="6">
<a name="Begleitende-Vielbeine"></a>
<a name="SEC137"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.5 Begleitende Vielbeine </h4>

<p>Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary frame.
</p>
<p>To use frames, you must first set <code>iframe_flag</code> to <code>true</code>.  This
causes the Christoffel-symbols, <code>ichr1</code> and <code>ichr2</code>, to be replaced
by the more general frame connection coefficients <code>icc1</code> and <code>icc2</code>
in calculations.  Speficially, the behavior of <code>covdiff</code> and
<code>icurvature</code> is changed.
</p>
<p>The frame is defined by two tensors: the inverse frame field (<code>ifri</code>,
the dual basis tetrad),
and the frame metric <code>ifg</code>.  The frame metric is the identity matrix for
orthonormal frames, or the Lorentz metric for orthonormal frames in Minkowski
spacetime.  The inverse frame field defines the frame base (unit vectors).
Contraction properties are defined for the frame field and the frame metric.
</p>
<p>When <code>iframe_flag</code> is true, many <code>itensor</code> expressions use the frame
metric <code>ifg</code> instead of the metric defined by <code>imetric</code> for
raising and lowerind indices.
</p>
<p>IMPORTANT: Setting the variable <code>iframe_flag</code> to <code>true</code> does NOT
undefine the contraction properties of a metric defined by a call to
<code>defcon</code> or <code>imetric</code>.  If a frame field is used, it is best to
define the metric by assigning its name to the variable <code>imetric</code>
and NOT invoke the <code>imetric</code> function.
</p>
<p>Maxima uses these two tensors to define the frame coefficients (<code>ifc1</code>
and <code>ifc2</code>) which form part of the connection coefficients (<code>icc1</code>
and <code>icc2</code>), as the following example demonstrates:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c
</pre>
<p>An alternate method is used to compute the frame bracket (<code>ifb</code>) if
the <code>iframe_bracket_form</code> flag is set to <code>false</code>:
</p>
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

</pre>
<p><a name="iframe_005fflag"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>iframe_flag</b>
<a name="IDX1071"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>To use frames, you must first set <code>iframe_flag</code> to <code>true</code>.  This
causes the Christoffel-symbols, <code>ichr1</code> and <code>ichr2</code>, to be replaced
by the more general frame connection coefficients <code>icc1</code> and <code>icc2</code>
in calculations.  Speficially, the behavior of <code>covdiff</code> and
<code>icurvature</code> is changed.
</p>
<p>The frame is defined by two tensors: the inverse frame field (<code>ifri</code>,
the dual basis tetrad),
and the frame metric <code>ifg</code>.  The frame metric is the identity matrix for
orthonormal frames, or the Lorentz metric for orthonormal frames in Minkowski
spacetime.  The inverse frame field defines the frame base (unit vectors).
Contraction properties are defined for the frame field and the frame metric.
</p>
<p>When <code>iframe_flag</code> is true, many <code>itensor</code> expressions use the frame
metric <code>ifg</code> instead of the metric defined by <code>imetric</code> for
raising and lowerind indices.
</p>
<p>IMPORTANT: Setting the variable <code>iframe_flag</code> to <code>true</code> does NOT
undefine the contraction properties of a metric defined by a call to
<code>defcon</code> or <code>imetric</code>.  If a frame field is used, it is best to
define the metric by assigning its name to the variable <code>imetric</code>
and NOT invoke the <code>imetric</code> function.
</p></dd></dl>

<p><a name="iframes"></a>
</p><dl>
<dt><u>Function:</u> <b>iframes</b><i> ()</i>
<a name="IDX1072"></a>
</dt>
<dd><p>Since in this version of Maxima, contraction identities for <code>ifr</code> and
<code>ifri</code> are always defined, as is the frame bracket (<code>ifb</code>), this
function does nothing.
</p></dd></dl>

<p><a name="ifb"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifb</b>
<a name="IDX1073"></a>
</dt>
<dd><p>The frame bracket.  The contribution of the frame metric to the connection
coefficients is expressed using the frame bracket:
</p>
<pre class="example">          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2
</pre>
<p>The frame bracket itself is defined in terms of the frame field and frame
metric.  Two alternate methods of computation are used depending on the
value of <code>frame_bracket_form</code>.  If true (the default) or if the
<code>itorsion_flag</code> is <code>true</code>:
</p>
<pre class="example">          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e
</pre>
<p>Otherwise:
</p>
<pre class="example">             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d
</pre></dd></dl>

<p><a name="icc1"></a>
</p><dl>
<dt><u>Variable:</u> <b>icc1</b>
<a name="IDX1074"></a>
</dt>
<dd><p>Connection coefficients of the first kind.  In <code>itensor</code>, defined as
</p>
<pre class="example">icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc
</pre>
<p>In this expression, if <code>iframe_flag</code> is true, the Christoffel-symbol
<code>ichr1</code> is replaced with the frame connection coefficient <code>ifc1</code>.
If <code>itorsion_flag</code> is <code>false</code>, <code>ikt1</code>
will be omitted.  It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code>inonmet_flag</code> is <code>false</code>,
<code>inmc1</code> will not be present.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>icc2</b>
<a name="IDX1075"></a>
</dt>
<dd><p>Connection coefficients of the second kind.  In <code>itensor</code>, defined as
</p>
<pre class="example">    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab
</pre>
<p>In this expression, if <code>iframe_flag</code> is true, the Christoffel-symbol
<code>ichr2</code> is replaced with the frame connection coefficient <code>ifc2</code>.
If <code>itorsion_flag</code> is <code>false</code>, <code>ikt2</code>
will be omitted.  It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code>inonmet_flag</code> is <code>false</code>,
<code>inmc2</code> will not be present.
</p></dd></dl>

<p><a name="ifc1"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifc1</b>
<a name="IDX1076"></a>
</dt>
<dd><p>Frame coefficient of the first kind (also known as Ricci-rotation
coefficients.) This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind.  Defined
as:
</p>
<pre class="example">          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2
</pre></dd></dl>

<p><a name="ifc2"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifc2</b>
<a name="IDX1077"></a>
</dt>
<dd><p>Frame coefficient of the first kind.  This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind.  Defined
as a permutation of the frame bracket (<code>ifb</code>) with the appropriate
indices raised and lowered as necessary:
</p>
<pre class="example">    c       cd
ifc2   = ifg   ifc1
    ab             abd
</pre></dd></dl>

<p><a name="ifr"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifr</b>
<a name="IDX1078"></a>
</dt>
<dd><p>The frame field.  Contracts with the inverse frame field (<code>ifri</code>) to
form the frame metric (<code>ifg</code>).
</p></dd></dl>

<p><a name="ifri"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifri</b>
<a name="IDX1079"></a>
</dt>
<dd><p>The inverse frame field.  Specifies the frame base (dual basis vectors).  Along
with the frame metric, it forms the basis of all calculations based on
frames.
</p></dd></dl>

<p><a name="ifg"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifg</b>
<a name="IDX1080"></a>
</dt>
<dd><p>The frame metric.  Defaults to <code>kdelta</code>, but can be changed using
<code>components</code>.
</p></dd></dl>

<p><a name="ifgi"></a>
</p><dl>
<dt><u>Variable:</u> <b>ifgi</b>
<a name="IDX1081"></a>
</dt>
<dd><p>The inverse frame metric.  Contracts with the frame metric (<code>ifg</code>)
to <code>kdelta</code>.
</p></dd></dl>

<p><a name="iframe_005fbracket_005fform"></a>
</p><dl>
<dt><u>Option variable:</u> <b>iframe_bracket_form</b>
<a name="IDX1082"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>Specifies how the frame bracket (<code>ifb</code>) is computed.
</p></dd></dl>

<hr size="6">
<a name="Torsion-und-Nichtmetrizit_00e4t"></a>
<a name="SEC138"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC137" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.6 Torsion und Nichtmetrizit&auml;t </h4>

<p>Maxima can now take into account torsion and nonmetricity.  When the flag
<code>itorsion_flag</code> is set to <code>true</code>, the contribution of torsion
is added to the connection coefficients.  Similarly, when the flag
<code>inonmet_flag</code> is true, nonmetricity components are included.
</p>
<p><a name="inm"></a>
</p><dl>
<dt><u>Variable:</u> <b>inm</b>
<a name="IDX1083"></a>
</dt>
<dd><p>The nonmetricity vector. Conformal nonmetricity is defined through the
covariant derivative of the metric tensor. Normally zero, the metric
tensor's covariant derivative will evaluate to the following when
<code>inonmet_flag</code> is set to <code>true</code>:
</p>
<pre class="example">g     =- g  inm
 ij;k     ij   k
</pre></dd></dl>

<p><a name="inmc1"></a>
</p><dl>
<dt><u>Variable:</u> <b>inmc1</b>
<a name="IDX1084"></a>
</dt>
<dd><p>Covariant permutation of the nonmetricity vector components. Defined as
</p>
<pre class="example">           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2
</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p></dd></dl>

<p><a name="inmc2"></a>
</p><dl>
<dt><u>Variable:</u> <b>inmc2</b>
<a name="IDX1085"></a>
</dt>
<dd><p>Contravariant permutation of the nonmetricity vector components. Used
in the connection coefficients if <code>inonmet_flag</code> is <code>true</code>. Defined
as:
</p>
<pre class="example">                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2
</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p></dd></dl>

<p><a name="ikt1"></a>
</p><dl>
<dt><u>Variable:</u> <b>ikt1</b>
<a name="IDX1086"></a>
</dt>
<dd><p>Covariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<pre class="example">                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2
</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p></dd></dl>

<p><a name="ikt2"></a>
</p><dl>
<dt><u>Variable:</u> <b>ikt2</b>
<a name="IDX1087"></a>
</dt>
<dd><p>Contravariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<pre class="example">    c     cd
ikt2   = g   ikt1
    ab           abd
</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p></dd></dl>

<p><a name="itr"></a>
</p><dl>
<dt><u>Variable:</u> <b>itr</b>
<a name="IDX1088"></a>
</dt>
<dd><p>The torsion tensor. For a metric with torsion, repeated covariant
differentiation on a scalar function will not commute, as demonstrated
by the following example:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j
</pre></dd></dl>

<hr size="6">
<a name="Gra_00dfmann_002dAlgebra"></a>
<a name="SEC139"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC138" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.7 Gra&szlig;mann-Algebra </h4>

<p>The <code>itensor</code> package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge product,
is defined.
</p>
<p>Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of
two vector fields, for instance, would be defined as
</p>
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre>
<p>More generally, the product of a p-form and a q-form would be defined as
</p>
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>where <code>D</code> stands for the Kronecker-delta.
</p>
<p>Other authors, however, prefer a &quot;geometric&quot; definition that corresponds
with the notion of the volume element:
</p>
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre>
<p>and, in the general case
</p>
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>Since <code>itensor</code> is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications, however,
utilize the second definition. To resolve this dilemma, a flag has been
implemented that controls the behavior of the wedge product: if
<code>igeowedge_flag</code> is <code>false</code> (the default), the first, &quot;tensorial&quot;
definition is used, otherwise the second, &quot;geometric&quot; definition will
be applied.
</p>
<dl>
<dt><u>Operator:</u> <b>~</b>
<a name="IDX1089"></a>
</dt>
<dd><p>The wedge product operator is denoted by the tilde <code>~</code>. This is
a binary operator. Its arguments should be expressions involving scalars,
covariant tensors of rank one, or covariant tensors of rank <code>l</code> that
have been declared antisymmetric in all covariant indices.
</p>
<p>The behavior of the wedge product operator is controlled by the
<code>igeowedge_flag</code> flag, as in the following example:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre></dd></dl>

<dl>
<dt><u>Operator:</u> <b>|</b>
<a name="IDX1090"></a>
</dt>
<dd><p>The vertical bar <code>|</code> denotes the &quot;contraction with a vector&quot; binary
operation. When a totally antisymmetric covariant tensor is contracted
with a contravariant vector, the result is the same regardless which index
was used for the contraction. Thus, it is possible to define the
contraction operation in an index-free manner.
</p>
<p>In the <code>itensor</code> package, contraction with a vector is always carried out
with respect to the first index in the literal sorting order. This ensures
better simplification of expressions involving the <code>|</code> operator. For instance:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre>
<p>Note that it is essential that the tensors used with the <code>|</code> operator be
declared totally antisymmetric in their covariant indices. Otherwise,
the results will be incorrect.
</p></dd></dl>

<p><a name="extdiff"></a>
</p><dl>
<dt><u>Function:</u> <b>extdiff</b><i> (<var>expr</var>, <var>i</var>)</i>
<a name="IDX1091"></a>
</dt>
<dd><p>Computes the exterior derivative of <var>expr</var> with respect to the index
<var>i</var>. The exterior derivative is formally defined as the wedge
product of the partial derivative operator and a differential form. As
such, this operation is also controlled by the setting of <code>igeowedge_flag</code>.
For instance:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

</pre></dd></dl>

<p><a name="hodge"></a>
</p><dl>
<dt><u>Function:</u> <b>hodge</b><i> (<var>expr</var>)</i>
<a name="IDX1092"></a>
</dt>
<dd><p>Compute the Hodge-dual of <var>expr</var>. For instance:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108
</pre></dd></dl>

<p><a name="igeowedge_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>igeowedge_flag</b>
<a name="IDX1093"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>Controls the behavior of the wedge product and exterior derivative. When
set to <code>false</code> (the default), the notion of differential forms will
correspond with that of a totally antisymmetric covariant tensor field.
When set to <code>true</code>, differential forms will agree with the notion
of the volume element.
</p></dd></dl>

<hr size="6">
<a name="Exportiere-als-TeX"></a>
<a name="SEC140"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC139" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.8 Exportiere als TeX </h4>

<p>The <code>itensor</code> package provides limited support for exporting tensor
expressions to TeX. Since <code>itensor</code> expressions appear as function calls,
the regular Maxima <code>tex</code> command will not produce the expected
output. You can try instead the <code>tentex</code> command, which attempts
to translate tensor expressions into appropriately indexed TeX objects.
</p>
<p><a name="tentex"></a>
</p><dl>
<dt><u>Function:</u> <b>tentex</b><i> (<var>expr</var>)</i>
<a name="IDX1094"></a>
</dt>
<dd><p>To use the <code>tentex</code> function, you must first load <code>tentex</code>,
as in the following example:
</p>
<pre class="example">(%i1) load(itensor)$
(%i2) load(tentex)$
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$
</pre>
<p>Note the use of the <code>idummyx</code> assignment, to avoid the appearance
of the percent sign in the TeX expression, which may lead to compile errors.
</p>
<p>NB: This version of the <code>tentex</code> function is somewhat experimental.
</p></dd></dl>

<hr size="6">
<a name="Schnittstelle-zum-Paket-ctensor"></a>
<a name="SEC141"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC140" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.9 Schnittstelle zum Paket <small>CTENSOR</small> </h4>


<p>Das Paket <code>itensor</code> erm&ouml;glicht die Generierung von Maxima-Code, der im
Kontext des Paketes <code>ctensor</code> ausgef&uuml;hrt werden kann.  Die Funktion
<code><a href="#ic_005fconvert">ic_convert</a></code> erzeugt den Maxima-Code.
</p>

<p><a name="ic_005fconvert"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ic_convert</b><i> (<var>eqn</var>)</i>
<a name="IDX1095"></a>
</dt>
<dd>
<p>Konvertiert eine <code>itensor</code>-Gleichung <var>eqn</var> in einen
<code>ctensor</code>-Ausdruck.  Implizite Summen &uuml;ber Dummy-Indizes werden explizit
ausgef&uuml;hrt und indizierte Gr&ouml;&szlig;en werden in Arrays umgewandelt.  Die
Indizes der Arrays sind in der Reihenfolge der kovarianten und dann der
kontravarianten Indizes der indizierte Gr&ouml;&szlig;e.  Die Ableitung einer
indizierten Gr&ouml;&szlig;e wird durch die Substantivform der Ableitung
<code><a href="maxima_16.html#diff">diff</a></code> nach der Variablen <code><a href="#ct_005fcoords">ct_coords</a></code> ersetzt, die den Index der
Ableitung erh&auml;lt.  Die Christoffel-Symbole <code><a href="#ichr1">ichr1</a></code> und <code><a href="#ichr2">ichr2</a></code>
werden zu den Funktionen <code>lcs</code> und <code>mcs</code> transformiert.  Hat
<code>metricconvert</code> den Wert <code>true</code>, dann wird der Metriktensor mit zwei
kovarianten Indizes durch <code><a href="#lg">lg</a></code> und mit zwei kontravarianten Indizes durch
<code><a href="#ug">ug</a></code> ersetzt.  Weiterhin werden <code>do</code>-Schleifen f&uuml;r die Summation
&uuml;ber die freien Indizes eingef&uuml;hrt.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre></dd></dl>

<hr size="6">
<a name="Reservierte-Bezeichner"></a>
<a name="SEC142"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.2.2.10 Reservierte Bezeichner </h4>


<p>Die folgenden Maxima Bezeichner werden im Paket <code>itensor</code> intern genutzt
und sollten vom Nutzer nicht umdefiniert werden.
</p>
<pre class="example">  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices of a indexed object
  deri       Lists derivative indices of an indexed object
  name       Returns the name of an indexed object
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre>




<hr size="6">
<a name="Paket-ctensor"></a>
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.3 Paket <small>CTENSOR</small> </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC144">20.3.1 Einf&uuml;hrung in <small>CTENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC145">20.3.2 Funktionen und Variablen f&uuml;r <small>CTENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-ctensor"></a>
<a name="SEC144"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.3.1 Einf&uuml;hrung in <small>CTENSOR</small> </h3>


<p><code>ctensor</code> ist ein Paket, um mit den Komponenten eines Tensors zu rechnen.
Das Paket wird mit dem Kommando <code>load(ctensor)</code> geladen.  Zu Beginn muss
das Paket mit dem Kommando <code><a href="#csetup">csetup</a></code> initialisiert werden.  Als erstes wird
die Anzahl der Dimensionen angegeben.  Werden <code>2</code>, <code>3</code> oder <code>4</code>
Dimensionen angegeben, dann erhalten die Koordinaten standardm&auml;&szlig;ig die
Bezeichnungen <code>[x,y]</code>, <code>[x,y,z]</code> oder <code>[x,y,z,t]</code>.  Diese
Bezeichnungen k&ouml;nnen ge&auml;ndert werden, indem der Optionsvariablen
<code><a href="#ct_005fcoords">ct_coords</a></code> eine neue Liste mit den gew&uuml;nschten Bezeichnungen zugewiesen
wird.
</p>
      
<p>Danach wird eine Metrik eingegeben oder aus einer Datei geladen.  Die Metrik
wird in der Matrix <code><a href="#lg">lg</a></code> gespeichert.  Maxima berechnet die inverse der
Metrik und speichert diese in der Matrix <code><a href="#ug">ug</a></code> ab.  Maxima bietet die
Option an, alle Rechnungen in einer Reihenentwicklung auszuf&uuml;hren.
</p>

<p>Die folgende Sitzung zeigt ein Beispiel f&uuml;r die Initialisierung einer
sph&auml;rischen, symmetrischen Metrik, wie sie zum Beispiel im Falle der
Einsteinschen Vakuumgleichen verwendet wird.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)      /share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system:
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none
depends([a,d],x);
Do you wish to see the metric?
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done
</pre>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-ctensor"></a>
<a name="SEC145"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC144" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC146" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.3.2 Funktionen und Variablen f&uuml;r <small>CTENSOR</small> </h3>

<hr size="6">
<a name="SEC146"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC147" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.1 Initialisierung </h4>

<p><a name="csetup"></a>
</p><dl>
<dt><u>Funktion:</u> <b>csetup</b><i> ()</i>
<a name="IDX1096"></a>
</dt>
<dd>
<p>Mit der Funktion <code>csetup</code> wird das Paket <code>ctensor</code> initialisiert.  Vom
Nutzer werden die Angaben zu einer Metrik abgefragt.  F&uuml;r ein Beispiel siehe 
<a href="#SEC144">Einf&uuml;hrung in <small>CTENSOR</small></a>.
</p></dd></dl>

<p><a name="cmetric"></a>
</p><dl>
<dt><u>Funktion:</u> <b>cmetric</b><i> (<var>dis</var>)</i>
<a name="IDX1097"></a>
</dt>
<dt><u>Funktion:</u> <b>cmetric</b><i> ()</i>
<a name="IDX1098"></a>
</dt>
<dd>
<p>Die Funktion <code>cmetric</code> berechnet die inverse der Metrik und f&uuml;hrt weitere
Initialisierungen f&uuml;r die Rechnung mit Tensoren aus.
</p>

<p>Hat die Optionsvariable <code><a href="#cframe_005fflag">cframe_flag</a></code> den Wert <code>false</code>, wird die
inverse Metrik mit der vom Nutzer angegebenen Metrik berechnet, die in der
Matrix <code><a href="#lg">lg</a></code> enthalten ist, und in der Matrix <code><a href="#ug">ug</a></code> abgespeichert.
Die Determinante der Metrik wird in der Variablen <code><a href="#gdet">gdet</a></code> abgelegt.
Ist die Metrik diagonal wird die Variable <code><a href="#diagmetric">diagmetric</a></code> entsprechend
gesetzt.  Hat das optionale Argument <var>dis</var> einen von <code>false</code>
verschiedenen Wert wird die inverse Metrik ausgegeben.
</p>

<p>Hat die Optionsvariable <code><a href="#cframe_005fflag">cframe_flag</a></code> den Wert <code>true</code>, erwartet
<code>cmetric</code>, dass die Matrizen <code><a href="#lfg">lfg</a></code> f&uuml;r die Metrik des bewegten
Bezugssystems und <code>fri</code> f&uuml;r die inverse dieser Metrik definiert sind.
Mit diesen Matrizen berechnet <code>cmetric</code> dann die Werte der Matrizen
<code>fr</code> und die inverse <code><a href="#ufg">ufg</a></code>.
</p></dd></dl>

<p><a name="ct_005fcoordsys"></a>
</p><dl>
<dt><u>Function:</u> <b>ct_coordsys</b><i> (<var>coordinate_system</var>, <var>extra_arg</var>)</i>
<a name="IDX1099"></a>
</dt>
<dt><u>Function:</u> <b>ct_coordsys</b><i> (<var>coordinate_system</var>)</i>
<a name="IDX1100"></a>
</dt>
<dd><p>Sets up a predefined coordinate system and metric. The argument
<var>coordinate_system</var> can be one of the following symbols:
</p>
<pre class="example"> SYMBOL             Dim Coordinates     Description/comments
 ------------------------------------------------------------------
 cartesian2d           2  [x,y]             Cartesian 2D coordinate
                                            system
 polar                 2  [r,phi]           Polar coordinate system
 elliptic              2  [u,v]             Elliptic coord. system
 confocalelliptic      2  [u,v]             Confocal elliptic
                                            coordinates
 bipolar               2  [u,v]             Bipolar coord. system
 parabolic             2  [u,v]             Parabolic coord. system
 cartesian3d           3  [x,y,z]           Cartesian 3D coordinate
                                            system
 polarcylindrical      3  [r,theta,z]       Polar 2D with
                                            cylindrical z
 ellipticcylindrical   3  [u,v,z]           Elliptic 2D with
                                            cylindrical z
 confocalellipsoidal   3  [u,v,w]           Confocal ellipsoidal
 bipolarcylindrical    3  [u,v,z]           Bipolar 2D with
                                            cylindrical z
 paraboliccylindrical  3  [u,v,z]           Parabolic 2D with
                                            cylindrical z
 paraboloidal          3  [u,v,phi]         Paraboloidal coords.
 conical               3  [u,v,w]           Conical coordinates
 toroidal              3  [u,v,phi]         Toroidal coordinates
 spherical             3  [r,theta,phi]     Spherical coord. system
 oblatespheroidal      3  [u,v,phi]         Oblate spheroidal
                                            coordinates
 oblatespheroidalsqrt  3  [u,v,phi]
 prolatespheroidal     3  [u,v,phi]         Prolate spheroidal
                                            coordinates
 prolatespheroidalsqrt 3  [u,v,phi]
 ellipsoidal           3  [r,theta,phi]     Ellipsoidal coordinates
 cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate
                                            system
 spherical4d           4  [r,theta,eta,phi] Spherical 4D coordinate
                                            system
 exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
 interiorschwarzschild 4  [t,z,u,v]         Interior Schwarzschild
                                            metric
 kerr_newman           4  [t,r,theta,phi]   Charged axially
                                            symmetric metric
</pre>
<p><code>coordinate_system</code> can also be a list of transformation functions,
followed by a list containing the coordinate variables. For instance,
you can specify a spherical metric as follows:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                   r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3
</pre>
<p>Transformation functions can also be used when <code>cframe_flag</code> is 
<code>true</code>:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
(%o4)
 [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
 [                                                                ]
 [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
 [                                                                ]
 [    sin(theta)           r cos(theta)                0          ]

(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
</pre>
<p>The optional argument <var>extra_arg</var> can be any one of the following:
</p>
<p><code>cylindrical</code> tells <code>ct_coordsys</code> to attach an additional cylindrical 
coordinate.
</p>
<p><code>minkowski</code> tells <code>ct_coordsys</code> to attach an additional coordinate 
with negative metric signature.
</p>
<p><code>all</code> tells <code>ct_coordsys</code> to call <code>cmetric</code> and 
<code>christof(false)</code> after setting up the metric.
</p>
<p>If the global variable <code>verbose</code> is set to <code>true</code>, <code>ct_coordsys</code> 
displays the values of <code>dim</code>, <code>ct_coords</code>, and either <code>lg</code> or 
<code>lfg</code> and <code>fri</code>, depending on the value of <code>cframe_flag</code>.
</p></dd></dl>

<p><a name="init_005fctensor"></a>
</p><dl>
<dt><u>Function:</u> <b>init_ctensor</b><i> ()</i>
<a name="IDX1101"></a>
</dt>
<dd><p>Initializes the <code>ctensor</code> package.
</p>
<p>The <code>init_ctensor</code> function reinitializes the <code>ctensor</code> package. It 
removes all arrays and matrices used by <code>ctensor</code>, resets all flags, resets
<code>dim</code> to 4, and resets the frame metric to the Lorentz-frame.
</p></dd></dl>

<hr size="6">
<a name="SEC147"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC146" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC148" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.2 The tensors of curved space </h4>

<p>The main purpose of the <code>ctensor</code> package is to compute the tensors
of curved space(time), most notably the tensors used in general
relativity.
</p>
<p>When a metric base is used, <code>ctensor</code> can compute the following tensors:
</p>
<pre class="example"> lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem
</pre>
<p><code>ctensor</code> can also work using moving frames. When <code>cframe_flag</code> is
set to <code>true</code>, the following tensors can be calculated:
</p>
<pre class="example"> lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem
</pre>
<p><a name="christof"></a>
</p><dl>
<dt><u>Function:</u> <b>christof</b><i> (<var>dis</var>)</i>
<a name="IDX1102"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package.  It computes the 
Christoffel symbols of both kinds.  The argument <var>dis</var> determines which 
results are to be immediately displayed.  The Christoffel symbols of the first 
and second kinds are stored in the arrays <code>lcs[i,j,k]</code> and 
<code>mcs[i,j,k]</code> respectively and defined to be symmetric in the first two 
indices.  If the argument to <code>christof</code> is <code>lcs</code> or <code>mcs</code> then 
the unique non-zero values of <code>lcs[i,j,k]</code> or <code>mcs[i,j,k]</code>, 
respectively, will be displayed. If the argument is <code>all</code> then the unique 
non-zero values of <code>lcs[i,j,k]</code> and <code>mcs[i,j,k]</code> will be displayed.  
If the argument is <code>false</code> then the display of the elements will not occur.
The array elements <code>mcs[i,j,k]</code> are defined in such a manner that the final
index is contravariant.
</p></dd></dl>
  
<p><a name="ricci"></a>
</p><dl>
<dt><u>Function:</u> <b>ricci</b><i> (<var>dis</var>)</i>
<a name="IDX1103"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package. <code>ricci</code> 
computes the covariant (symmetric) components <code>ric[i,j]</code> of the Ricci 
tensor.  If the argument <var>dis</var> is <code>true</code>, then the non-zero components 
are displayed.
</p></dd></dl>

<p><a name="uricci"></a>
</p><dl>
<dt><u>Function:</u> <b>uricci</b><i> (<var>dis</var>)</i>
<a name="IDX1104"></a>
</dt>
<dd><p>This function first computes the covariant components <code>ric[i,j]</code> of the 
Ricci tensor.  Then the mixed Ricci tensor is computed using the contravariant 
metric tensor.  If the value of the argument <var>dis</var> is <code>true</code>, then 
these mixed components, <code>uric[i,j]</code> (the index <code>i</code> is covariant and 
the index <code>j</code> is contravariant), will be displayed directly.  Otherwise, 
<code>ricci(false)</code> will simply compute the entries of the array 
<code>uric[i,j]</code> without displaying the results.
</p></dd></dl>

<p><a name="scurvature"></a>
</p><dl>
<dt><u>Function:</u> <b>scurvature</b><i> ()</i>
<a name="IDX1105"></a>
</dt>
<dd><p>Returns the scalar curvature (obtained by contracting
the Ricci tensor) of the Riemannian manifold with the given metric.
</p></dd></dl>

<p><a name="einstein"></a>
</p><dl>
<dt><u>Function:</u> <b>einstein</b><i> (<var>dis</var>)</i>
<a name="IDX1106"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package.  <code>einstein</code> 
computes the mixed Einstein tensor after the Christoffel symbols and Ricci 
tensor have been obtained (with the functions <code>christof</code> and <code>ricci</code>).
If the argument <var>dis</var> is <code>true</code>, then the non-zero values of the mixed 
Einstein tensor <code>ein[i,j]</code> will be displayed where <code>j</code> is the 
contravariant index.  The variable <code>rateinstein</code> will cause the rational 
simplification on these components. If <code>ratfac</code> is <code>true</code> then the 
components will also be factored.
</p></dd></dl>

<p><a name="leinstein"></a>
</p><dl>
<dt><u>Function:</u> <b>leinstein</b><i> (<var>dis</var>)</i>
<a name="IDX1107"></a>
</dt>
<dd><p>Covariant Einstein-tensor.  <code>leinstein</code> stores the values of the covariant 
Einstein tensor in the array <code>lein</code>.  The covariant Einstein-tensor is 
computed from the mixed Einstein tensor <code>ein</code> by multiplying it with the 
metric tensor.  If the argument <var>dis</var> is <code>true</code>, then the non-zero 
values of the covariant Einstein tensor are displayed.
</p></dd></dl>

<p><a name="riemann"></a>
</p><dl>
<dt><u>Function:</u> <b>riemann</b><i> (<var>dis</var>)</i>
<a name="IDX1108"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package.  <code>riemann</code> computes the Riemann curvature tensor
from the given metric and the corresponding Christoffel symbols. The following
index conventions are used:
</p>
<pre class="example">                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
</pre>
<p>This notation is consistent with the notation used by the <code>itensor</code>
package and its <code>icurvature</code> function.
If the optional argument <var>dis</var> is <code>true</code>,
the non-zero components <code>riem[i,j,k,l]</code> will be displayed.
As with the Einstein tensor, various switches set by the user
control the simplification of the components of the Riemann tensor.
If <code>ratriemann</code> is <code>true</code>, then
rational simplification will be done. If <code>ratfac</code>
is <code>true</code> then
each of the components will also be factored.
</p>
<p>If the variable <code>cframe_flag</code> is <code>false</code>, the Riemann tensor is
computed directly from the Christoffel-symbols. If <code>cframe_flag</code> is
<code>true</code>, the covariant Riemann-tensor is computed first from the
frame field coefficients.
</p></dd></dl>

<p><a name="lriemann"></a>
</p><dl>
<dt><u>Function:</u> <b>lriemann</b><i> (<var>dis</var>)</i>
<a name="IDX1109"></a>
</dt>
<dd><p>Covariant Riemann-tensor (<code>lriem[]</code>).
</p>
<p>Computes the covariant Riemann-tensor as the array <code>lriem</code>. If the
argument <var>dis</var> is <code>true</code>, unique nonzero values are displayed.
</p>
<p>If the variable <code>cframe_flag</code> is <code>true</code>, the covariant Riemann
tensor is computed directly from the frame field coefficients. Otherwise,
the (3,1) Riemann tensor is computed first.
</p>
<p>For information on index ordering, see <code>riemann</code>.
</p></dd></dl>

<p><a name="uriemann"></a>
</p><dl>
<dt><u>Function:</u> <b>uriemann</b><i> (<var>dis</var>)</i>
<a name="IDX1110"></a>
</dt>
<dd><p>Computes the contravariant components of the Riemann
curvature tensor as array elements <code>uriem[i,j,k,l]</code>.  These are displayed
if <var>dis</var> is <code>true</code>.
</p></dd></dl>

<p><a name="rinvariant"></a>
</p><dl>
<dt><u>Function:</u> <b>rinvariant</b><i> ()</i>
<a name="IDX1111"></a>
</dt>
<dd><p>Forms the Kretchmann-invariant (<code>kinvariant</code>) obtained by
contracting the tensors
</p>
<pre class="example">lriem[i,j,k,l]*uriem[i,j,k,l].
</pre>
<p>This object is not automatically simplified since it can be very large.
</p></dd></dl>

<p><a name="weyl"></a>
</p><dl>
<dt><u>Function:</u> <b>weyl</b><i> (<var>dis</var>)</i>
<a name="IDX1112"></a>
</dt>
<dd><p>Computes the Weyl conformal tensor.  If the argument <var>dis</var> is
<code>true</code>, the non-zero components <code>weyl[i,j,k,l]</code> will be displayed to 
the user.  Otherwise, these components will simply be computed and stored.
If the switch <code>ratweyl</code> is set to <code>true</code>, then the components will be
rationally simplified; if <code>ratfac</code> is <code>true</code> then the results will be
factored as well.
</p></dd></dl>

<hr size="6">
<a name="SEC148"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC147" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC149" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.3 Taylor series expansion </h4>

<p>The <code>ctensor</code> package has the ability to truncate results by assuming
that they are Taylor-series approximations. This behavior is controlled by
the <code>ctayswitch</code> variable; when set to true, <code>ctensor</code> makes use
internally of the function <code>ctaylor</code> when simplifying results.
</p>
<p>The <code>ctaylor</code> function is invoked by the following <code>ctensor</code> 
functions:
</p>
<pre class="example">    Function     Comments
    ---------------------------------
    christof()   For mcs only
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
</pre>
<p><a name="ctaylor"></a>
</p><dl>
<dt><u>Function:</u> <b>ctaylor</b><i> ()</i>
<a name="IDX1113"></a>
</dt>
<dd><p>The <code>ctaylor</code> function truncates its argument by converting
it to a Taylor-series using <code>taylor</code>, and then calling
<code>ratdisrep</code>. This has the combined effect of dropping terms
higher order in the expansion variable <code>ctayvar</code>. The order
of terms that should be dropped is defined by <code>ctaypov</code>; the
point around which the series expansion is carried out is specified
in <code>ctaypt</code>.
</p>
<p>As an example, consider a simple metric that is a perturbation of
the Minkowski metric. Without further restrictions, even a diagonal
metric produces expressions for the Einstein tensor that are far too
complex:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                [0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
      [ h11 l - 1      0          0                 0            ]
      [                                                          ]
      [     0      h22 l + 1      0                 0            ]
      [                                                          ]
(%o8) [                        2                                 ]
      [     0          0      r  + h33 l            0            ]
      [                                                          ]
      [                                    2    2                ]
      [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 24]
[[2, 3], 0]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 0]
[[3, 3], 46]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 46]
(%o12)                               done
</pre>
<p>However, if we recompute this example as an approximation that is
linear in the variable <code>l</code>, we get much simpler expressions:
</p>
<pre class="example">(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 13]
[[2, 3], 2]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 2]
[[3, 3], 9]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 9]
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                            2               2      4    2
              - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                       r r                r
</pre>
<p>This capability can be useful, for instance, when working in the weak
field limit far from a gravitational source.
</p></dd></dl>

<hr size="6">
<a name="SEC149"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC148" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC150" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.4 Frame fields </h4>

<p><a name="cframe_005fflag"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>cframe_flag</b>
<a name="IDX1114"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>When the variable <code>cframe_flag</code> is set to true, the <code>ctensor</code> package
performs its calculations using a moving frame.
</p></dd></dl>

<p><a name="frame_005fbracket"></a>
</p><dl>
<dt><u>Function:</u> <b>frame_bracket</b><i> (<var>fr</var>, <var>fri</var>, <var>diagframe</var>)</i>
<a name="IDX1115"></a>
</dt>
<dd><p>The frame bracket (<code>fb[]</code>).
</p>
<p>Computes the frame bracket according to the following definition:
</p>
<pre class="example">   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
</pre></dd></dl>

<hr size="6">
<a name="SEC150"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC149" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.5 Algebraic classification </h4>

<p>A new feature (as of November, 2004) of <code>ctensor</code> is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
<code>share/tensor/petrov.dem</code>.
</p>
<p><a name="nptetrad"></a>
</p><dl>
<dt><u>Function:</u> <b>nptetrad</b><i> ()</i>
<a name="IDX1116"></a>
</dt>
<dd><p>Computes a Newman-Penrose null tetrad (<code>np</code>) and its raised-index
counterpart (<code>npi</code>). See <code>petrov</code> for an example.
</p>
<p>The null tetrad is constructed on the assumption that a four-diemensional
orthonormal frame metric with metric signature (-,+,+,+) is being used.
The components of the null tetrad are related to the inverse frame matrix
as follows:
</p>
<pre class="example">np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4
</pre></dd></dl>

<p><a name="ctensor_005fpsi"></a>
</p><dl>
<dt><u>Function:</u> <b>psi</b><i> (<var>dis</var>)</i>
<a name="IDX1117"></a>
</dt>
<dd><p>Computes the five Newman-Penrose coefficients <code>psi[0]</code>...<code>psi[4]</code>.
If <code>psi</code> is set to <code>true</code>, the coefficients are displayed.
See <code>petrov</code> for an example.
</p>
<p>These coefficients are computed from the Weyl-tensor in a coordinate base.
If a frame base is used, the Weyl-tensor is first converted to a coordinate
base, which can be a computationally expensive procedure. For this reason,
in some cases it may be more advantageous to use a coordinate base in the
first place before the Weyl tensor is computed. Note however, that
constructing a Newman-Penrose null tetrad requires a frame base. Therefore,
a meaningful computation sequence may begin with a frame base, which
is then used to compute <code>lg</code> (computed automatically by <code>cmetric</code>
and then <code>ug</code>. At this point, you can switch back to a coordinate base
by setting <code>cframe_flag</code> to false before beginning to compute the
Christoffel symbols. Changing to a frame base at a later stage could yield
inconsistent results, as you may end up with a mixed bag of tensors, some
computed in a frame base, some in a coordinate base, with no means to
distinguish between the two.
</p></dd></dl>

<p><a name="petrov"></a>
</p><dl>
<dt><u>Function:</u> <b>petrov</b><i> ()</i>
<a name="IDX1118"></a>
</dt>
<dd><p>Computes the Petrov classification of the metric characterized by 
<code>psi[0]</code> &hellip; <code>psi[4]</code>.
</p>
<p>For example, the following demonstrates how to obtain the Petrov-classification
of the Kerr metric:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np =

[ sqrt(r - 2 m)           sqrt(r)                                 ]
[---------------   ---------------------    0            0        ]
[sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
[                                                                 ]
[ sqrt(r - 2 m)            sqrt(r)                                ]
[---------------  - ---------------------   0            0        ]
[sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
[                                                                 ]
[                                          r      %i r sin(theta) ]
[       0                    0          -------   --------------- ]
[                                       sqrt(2)       sqrt(2)     ]
[                                                                 ]
[                                          r       %i r sin(theta)]
[       0                    0          -------  - ---------------]
[                                       sqrt(2)        sqrt(2)    ]

                             sqrt(r)         sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                      sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0],
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------],
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D
</pre>
<p>The Petrov classification function is based on the algorithm published in
&quot;Classifying geometries in general relativity: III Classification in practice&quot;
by Pollney, Skea, and d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Except for some simple test cases, the implementation is untested as of
December 19, 2004, and is likely to contain errors.
</p></dd></dl>

<hr size="6">
<a name="SEC151"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC150" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.6 Torsion and nonmetricity </h4>

<p><code>ctensor</code> has the ability to compute and include torsion and nonmetricity
coefficients in the connection coefficients.
</p>
<p>The torsion coefficients are calculated from a user-supplied tensor
<code>tr</code>, which should be a rank (2,1) tensor. From this, the torsion
coefficients <code>kt</code> are computed according to the following formulae:
</p>
<pre class="example">              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm
</pre>
<p>Note that only the mixed-index tensor is calculated and stored in the
array <code>kt</code>.
</p>
<p>The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector <code>nm</code>. From this, the nonmetricity coefficients
<code>nmc</code> are computed as follows:
</p>
<pre class="example">             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2
</pre>
<p>where D stands for the Kronecker-delta.
</p>
<p>When <code>ctorsion_flag</code> is set to <code>true</code>, the values of <code>kt</code>
are substracted from the mixed-indexed connection coefficients computed by
<code>christof</code> and stored in <code>mcs</code>. Similarly, if <code>cnonmet_flag</code>
is set to <code>true</code>, the values of <code>nmc</code> are substracted from the
mixed-indexed connection coefficients.
</p>
<p>If necessary, <code>christof</code> calls the functions <code>contortion</code> and
<code>nonmetricity</code> in order to compute <code>kt</code> and <code>nm</code>.
</p>
<dl>
<dt><u>Function:</u> <b>contortion</b><i> (<var>tr</var>)</i>
<a name="IDX1119"></a>
</dt>
<dd><p>Computes the (2,1) contortion coefficients from the torsion tensor <var>tr</var>.
</p></dd></dl>

<p><a name="nonmetricity"></a>
</p><dl>
<dt><u>Function:</u> <b>nonmetricity</b><i> (<var>nm</var>)</i>
<a name="IDX1120"></a>
</dt>
<dd><p>Computes the (2,1) nonmetricity coefficients from the nonmetricity
vector <var>nm</var>.
</p></dd></dl>

<hr size="6">
<a name="SEC152"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC151" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC153" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.7 Miscellaneous features </h4>

<p><a name="ctransform"></a>
</p><dl>
<dt><u>Function:</u> <b>ctransform</b><i> (<var>M</var>)</i>
<a name="IDX1121"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package which will perform a coordinate transformation
upon an arbitrary square symmetric matrix <var>M</var>. The user must input the
functions which define the transformation.  (Formerly called <code>transform</code>.)
</p></dd></dl>

<p><a name="findde"></a>
</p><dl>
<dt><u>Function:</u> <b>findde</b><i> (<var>A</var>, <var>n</var>)</i>
<a name="IDX1122"></a>
</dt>
<dd><p>returns a list of the unique differential equations (expressions)
corresponding to the elements of the <var>n</var> dimensional square
array <var>A</var>. Presently, <var>n</var> may be 2 or 3. <code>deindex</code> is a global list
containing the indices of <var>A</var> corresponding to these unique
differential equations. For the Einstein tensor (<code>ein</code>), which
is a two dimensional array, if computed for the metric in the example
below, <code>findde</code> gives the following independent differential equations:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                              [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
        x                     x x         x        x    x

                                              2          2
                          + 2 a d d   - 2 a  d , a  x + a  - a]
                                   x       x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]
</pre></dd></dl>

<p><a name="cograd"></a>
</p><dl>
<dt><u>Function:</u> <b>cograd</b><i> ()</i>
<a name="IDX1123"></a>
</dt>
<dd><p>Computes the covariant gradient of a scalar function allowing the
user to choose the corresponding vector name as the example under
<code>contragrad</code> illustrates.
</p></dd></dl>

<p><a name="contragrad"></a>
</p><dl>
<dt><u>Function:</u> <b>contragrad</b><i> ()</i>
<a name="IDX1124"></a>
</dt>
<dd><p>Computes the contravariant gradient of a scalar function allowing
the user to choose the corresponding vector name as the example
below for the Schwarzschild metric illustrates:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r
</pre></dd></dl>

<p><a name="ctensor_005fdscalar"></a>
</p><dl>
<dt><u>Function:</u> <b>dscalar</b><i> ()</i>
<a name="IDX1125"></a>
</dt>
<dd><p>computes the tensor d'Alembertian of the scalar function once
dependencies have been declared upon the function. For example:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
</pre></dd></dl>

<p><a name="checkdiv"></a>
</p><dl>
<dt><u>Function:</u> <b>checkdiv</b><i> ()</i>
<a name="IDX1126"></a>
</dt>
<dd><p>computes the covariant divergence of the mixed second rank tensor
(whose first index must be covariant) by printing the
corresponding n components of the vector field (the divergence) where
n = <code>dim</code>. If the argument to the function is <code>g</code> then the
divergence of the Einstein tensor will be formed and must be zero.
In addition, the divergence (vector) is given the array name <code>div</code>.
</p></dd></dl>

<p><a name="cgeodesic"></a>
</p><dl>
<dt><u>Function:</u> <b>cgeodesic</b><i> (<var>dis</var>)</i>
<a name="IDX1127"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package.  <code>cgeodesic</code> computes the geodesic equations of
motion for a given metric.  They are stored in the array <code>geod[i]</code>.  If
the argument <var>dis</var> is <code>true</code> then these equations are displayed.
</p></dd></dl>

<p><a name="bdvac"></a>
</p><dl>
<dt><u>Function:</u> <b>bdvac</b><i> (<var>f</var>)</i>
<a name="IDX1128"></a>
</dt>
<dd><p>generates the covariant components of the vacuum field equations of
the Brans- Dicke gravitational theory. The scalar field is specified
by the argument <var>f</var>, which should be a (quoted) function name
with functional dependencies, e.g., <code>'p(x)</code>.
</p>
<p>The components of the second rank covariant field tensor are
represented by the array <code>bd</code>.
</p></dd></dl>

<p><a name="invariant1"></a>
</p><dl>
<dt><u>Function:</u> <b>invariant1</b><i> ()</i>
<a name="IDX1129"></a>
</dt>
<dd><p>generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of R^2. The field equations are the components of an
array named <code>inv1</code>.
</p></dd></dl>

<p><a name="invariant2"></a>
</p><dl>
<dt><u>Function:</u> <b>invariant2</b><i> ()</i>
<a name="IDX1130"></a>
</dt>
<dd><p>*** NOT YET IMPLEMENTED ***
</p>
<p>generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of <code>ric[i,j]*uriem[i,j]</code>. The field equations are the
components of an array named <code>inv2</code>.
</p></dd></dl>

<p><a name="bimetric"></a>
</p><dl>
<dt><u>Function:</u> <b>bimetric</b><i> ()</i>
<a name="IDX1131"></a>
</dt>
<dd><p>*** NOT YET IMPLEMENTED ***
</p>
<p>generates the field equations of Rosen's bimetric theory. The field
equations are the components of an array named <code>rosen</code>.
</p></dd></dl>

<hr size="6">
<a name="SEC153"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC152" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.8 Utility functions </h4>

<p><a name="diagmatrixp"></a>
</p><dl>
<dt><u>Function:</u> <b>diagmatrixp</b><i> (<var>M</var>)</i>
<a name="IDX1132"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>M</var> is a diagonal matrix or (2D) array.
</p></dd></dl>

<p><a name="symmetricp"></a>
</p><dl>
<dt><u>Function:</u> <b>symmetricp</b><i> (<var>M</var>)</i>
<a name="IDX1133"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>M</var> is a symmetric matrix or (2D) array.
</p></dd></dl>

<p><a name="ntermst"></a>
</p><dl>
<dt><u>Function:</u> <b>ntermst</b><i> (<var>f</var>)</i>
<a name="IDX1134"></a>
</dt>
<dd><p>gives the user a quick picture of the &quot;size&quot; of the doubly subscripted
tensor (array) <var>f</var>.  It prints two element lists where the second
element corresponds to NTERMS of the components specified by the first
elements.  In this way, it is possible to quickly find the non-zero
expressions and attempt simplification.
</p></dd></dl>

<p><a name="cdisplay"></a>
</p><dl>
<dt><u>Function:</u> <b>cdisplay</b><i> (<var>ten</var>)</i>
<a name="IDX1135"></a>
</dt>
<dd><p>displays all the elements of the tensor <var>ten</var>, as represented by
a multidimensional array. Tensors of rank 0 and 1, as well as other types
of variables, are displayed as with <code>ldisplay</code>. Tensors of rank 2 are
displayed as 2-dimensional matrices, while tensors of higher rank are displayed
as a list of 2-dimensional matrices. For instance, the Riemann-tensor of
the Schwarzschild metric can be viewed as:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
          [ 0               0                   0           0     ]
          [                                                       ]
          [                              2                        ]
          [      3 m (r - 2 m)   m    2 m                         ]
          [ 0  - ------------- + -- - ----      0           0     ]
          [            4          3     4                         ]
          [           r          r     r                          ]
          [                                                       ]
riem    = [                                m (r - 2 m)            ]
    1, 1  [ 0               0              -----------      0     ]
          [                                     4                 ]
          [                                    r                  ]
          [                                                       ]
          [                                           m (r - 2 m) ]
          [ 0               0                   0     ----------- ]
          [                                                4      ]
          [                                               r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

             [     2 m                                         ]
             [ ------------  0        0               0        ]
             [  2                                              ]
             [ r  (r - 2 m)                                    ]
             [                                                 ]
             [      0        0        0               0        ]
             [                                                 ]
  riem     = [                         m                       ]
      2, 2   [      0        0  - ------------        0        ]
             [                     2                           ]
             [                    r  (r - 2 m)                 ]
             [                                                 ]
             [                                         m       ]
             [      0        0        0         - ------------ ]
             [                                     2           ]
             [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

           [        2                                             ]
           [   m sin (theta)                                      ]
           [ - -------------         0                0         0 ]
           [         r                                            ]
           [                                                      ]
           [                         2                            ]
           [                    m sin (theta)                     ]
riem     = [        0         - -------------         0         0 ]
    4, 4   [                          r                           ]
           [                                                      ]
           [                                          2           ]
           [                                   2 m sin (theta)    ]
           [        0                0         ---------------  0 ]
           [                                          r           ]
           [                                                      ]
           [        0                0                0         0 ]

(%o5)                                done
</pre></dd></dl>

<p><a name="deleten"></a>
</p><dl>
<dt><u>Function:</u> <b>deleten</b><i> (<var>L</var>, <var>n</var>)</i>
<a name="IDX1136"></a>
</dt>
<dd><p>Returns a new list consisting of <var>L</var> with the <var>n</var>'th element
deleted.
</p></dd></dl>

<hr size="6">
<a name="SEC154"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC153" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC155" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.9 Variables used by <code>ctensor</code> </h4>

<p><a name="dim"></a>
</p><dl>
<dt><u>Option variable:</u> <b>dim</b>
<a name="IDX1137"></a>
</dt>
<dd><p>Default value: 4
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  <code>dim</code> is the dimension of the manifold with the
default 4. The command <code>dim: n</code> will reset the dimension to any other
value <code>n</code>.
</p></dd></dl>

<p><a name="diagmetric"></a>
</p><dl>
<dt><u>Option variable:</u> <b>diagmetric</b>
<a name="IDX1138"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  If <code>diagmetric</code> is <code>true</code> special routines compute
all geometrical objects (which contain the metric tensor explicitly)
by taking into consideration the diagonality of the metric. Reduced
run times will, of course, result. Note: this option is set
automatically by <code>csetup</code> if a diagonal metric is specified.
</p></dd></dl>

<p><a name="ctrgsimp"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctrgsimp</b>
<a name="IDX1139"></a>
</dt>
<dd><p>Causes trigonometric simplifications to be used when tensors are computed. 
Presently, <code>ctrgsimp</code> affects only computations involving a moving frame.
</p></dd></dl>

<p><a name="cfram_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>cframe_flag</b>
<a name="IDX1140"></a>
</dt>
<dd><p>Causes computations to be performed relative to a moving frame as opposed to
a holonomic metric. The frame is defined by the inverse frame array <code>fri</code>
and the frame metric <code>lfg</code>. For computations using a Cartesian frame,
<code>lfg</code> should be the unit matrix of the appropriate dimension; for
computations in a Lorentz frame, <code>lfg</code> should have the appropriate
signature.
</p></dd></dl>

<p><a name="ctorsion_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctorsion_flag</b>
<a name="IDX1141"></a>
</dt>
<dd><p>Causes the contortion tensor to be included in the computation of the
connection coefficients. The contortion tensor itself is computed by
<code>contortion</code> from the user-supplied tensor <code>tr</code>.
</p></dd></dl>

<p><a name="cnonmet_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>cnonmet_flag</b>
<a name="IDX1142"></a>
</dt>
<dd><p>Causes the nonmetricity coefficients to be included in the computation of
the connection coefficients. The nonmetricity coefficients are computed
from the user-supplied nonmetricity vector <code>nm</code> by the function
<code>nonmetricity</code>.
</p></dd></dl>

<p><a name="ctayswitch"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctayswitch</b>
<a name="IDX1143"></a>
</dt>
<dd><p>If set to <code>true</code>, causes some <code>ctensor</code> computations to be carried out
using Taylor-series expansions. Presently, <code>christof</code>, <code>ricci</code>,
<code>uricci</code>, <code>einstein</code>, and <code>weyl</code> take into account this
setting.
</p></dd></dl>

<p><a name="ctayvar"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctayvar</b>
<a name="IDX1144"></a>
</dt>
<dd><p>Variable used for Taylor-series expansion if <code>ctayswitch</code> is set to
<code>true</code>.
</p></dd></dl>

<p><a name="ctaypov"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctaypov</b>
<a name="IDX1145"></a>
</dt>
<dd><p>Maximum power used in Taylor-series expansion when <code>ctayswitch</code> is
set to <code>true</code>.
</p></dd></dl>

<p><a name="ctaypt"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctaypt</b>
<a name="IDX1146"></a>
</dt>
<dd><p>Point around which Taylor-series expansion is carried out when
<code>ctayswitch</code> is set to <code>true</code>.
</p></dd></dl>

<p><a name="gdet"></a>
</p><dl>
<dt><u>System variable:</u> <b>gdet</b>
<a name="IDX1147"></a>
</dt>
<dd><p>The determinant of the metric tensor <code>lg</code>. Computed by <code>cmetric</code> when
<code>cframe_flag</code> is set to <code>false</code>.
</p></dd></dl>

<p><a name="ratchristof"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratchristof</b>
<a name="IDX1148"></a>
</dt>
<dd><p>Causes rational simplification to be applied by <code>christof</code>.
</p></dd></dl>

<p><a name="ratstein"></a>
</p><dl>
<dt><u>Option variable:</u> <b>rateinstein</b>
<a name="IDX1149"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>If <code>true</code> rational simplification will be
performed on the non-zero components of Einstein tensors; if
<code>ratfac</code> is <code>true</code> then the components will also be factored.
</p></dd></dl>

<p><a name="ratriemann"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratriemann</b>
<a name="IDX1150"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>One of the switches which controls
simplification of Riemann tensors; if <code>true</code>, then rational
simplification will be done; if <code>ratfac</code> is <code>true</code> then each of the
components will also be factored.
</p></dd></dl>

<p><a name="ratweyl"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratweyl</b>
<a name="IDX1151"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>If <code>true</code>, this switch causes the <code>weyl</code> function
to apply rational simplification to the values of the Weyl tensor. If
<code>ratfac</code> is <code>true</code>, then the components will also be factored.
</p></dd></dl>

<p><a name="lfg"></a>
</p><dl>
<dt><u>Variable:</u> <b>lfg</b>
<a name="IDX1152"></a>
</dt>
<dd><p>The covariant frame metric. By default, it is initialized to the 4-dimensional 
Lorentz frame with signature (+,+,+,-). Used when <code>cframe_flag</code> is 
<code>true</code>.
</p></dd></dl>

<p><a name="ufg"></a>
</p><dl>
<dt><u>Variable:</u> <b>ufg</b>
<a name="IDX1153"></a>
</dt>
<dd><p>The inverse frame metric. Computed from <code>lfg</code> when <code>cmetric</code> is 
called while <code>cframe_flag</code> is set to <code>true</code>.
</p></dd></dl>

<p><a name="riem"></a>
</p><dl>
<dt><u>Variable:</u> <b>riem</b>
<a name="IDX1154"></a>
</dt>
<dd><p>The (3,1) Riemann tensor. Computed when the function <code>riemann</code> is invoked. 
For information about index ordering, see the description of <code>riemann</code>.
</p>
<p>If <code>cframe_flag</code> is <code>true</code>, <code>riem</code> is computed from the 
covariant Riemann-tensor <code>lriem</code>.
</p></dd></dl>

<p><a name="lriem"></a>
</p><dl>
<dt><u>Variable:</u> <b>lriem</b>
<a name="IDX1155"></a>
</dt>
<dd><p>The covariant Riemann tensor. Computed by <code>lriemann</code>.
</p></dd></dl>

<p><a name="uriem"></a>
</p><dl>
<dt><u>Variable:</u> <b>uriem</b>
<a name="IDX1156"></a>
</dt>
<dd><p>The contravariant Riemann tensor. Computed by <code>uriemann</code>.
</p></dd></dl>

<p><a name="ric"></a>
</p><dl>
<dt><u>Variable:</u> <b>ric</b>
<a name="IDX1157"></a>
</dt>
<dd><p>The mixed Ricci-tensor. Computed by <code>ricci</code>.
</p></dd></dl>

<p><a name="uric"></a>
</p><dl>
<dt><u>Variable:</u> <b>uric</b>
<a name="IDX1158"></a>
</dt>
<dd><p>The contravariant Ricci-tensor. Computed by <code>uricci</code>.
</p></dd></dl>

<p><a name="lg"></a>
</p><dl>
<dt><u>Variable:</u> <b>lg</b>
<a name="IDX1159"></a>
</dt>
<dd><p>The metric tensor. This tensor must be specified (as a <code>dim</code> by 
<code>dim</code> matrix) before other computations can be performed.
</p></dd></dl>

<p><a name="ug"></a>
</p><dl>
<dt><u>Variable:</u> <b>ug</b>
<a name="IDX1160"></a>
</dt>
<dd><p>The inverse of the metric tensor. Computed by <code>cmetric</code>.
</p></dd></dl>

<p><a name="variable_005fweyl"></a>
</p><dl>
<dt><u>Variable:</u> <b>weyl</b>
<a name="IDX1161"></a>
</dt>
<dd><p>The Weyl tensor. Computed by <code>weyl</code>.
</p></dd></dl>

<p><a name="fb"></a>
</p><dl>
<dt><u>Variable:</u> <b>fb</b>
<a name="IDX1162"></a>
</dt>
<dd><p>Frame bracket coefficients, as computed by <code>frame_bracket</code>.
</p></dd></dl>

<p><a name="kinvariant"></a>
</p><dl>
<dt><u>Variable:</u> <b>kinvariant</b>
<a name="IDX1163"></a>
</dt>
<dd><p>The Kretchmann invariant. Computed by <code>rinvariant</code>.
</p></dd></dl>

<p><a name="np"></a>
</p><dl>
<dt><u>Variable:</u> <b>np</b>
<a name="IDX1164"></a>
</dt>
<dd><p>A Newman-Penrose null tetrad. Computed by <code>nptetrad</code>.
</p></dd></dl>

<p><a name="npi"></a>
</p><dl>
<dt><u>Variable:</u> <b>npi</b>
<a name="IDX1165"></a>
</dt>
<dd><p>The raised-index Newman-Penrose null tetrad. Computed by <code>nptetrad</code>.
Defined as <code>ug.np</code>. The product <code>np.transpose(npi)</code> is constant:
</p>
<pre class="example">(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
</pre></dd></dl>

<p><a name="tr"></a>
</p><dl>
<dt><u>Variable:</u> <b>tr</b>
<a name="IDX1166"></a>
</dt>
<dd><p>User-supplied rank-3 tensor representing torsion. Used by <code>contortion</code>.
</p></dd></dl>

<p><a name="kt"></a>
</p><dl>
<dt><u>Variable:</u> <b>kt</b>
<a name="IDX1167"></a>
</dt>
<dd><p>The contortion tensor, computed from <code>tr</code> by <code>contortion</code>.
</p></dd></dl>

<p><a name="nm"></a>
</p><dl>
<dt><u>Variable:</u> <b>nm</b>
<a name="IDX1168"></a>
</dt>
<dd><p>User-supplied nonmetricity vector. Used by <code>nonmetricity</code>.
</p></dd></dl>

<p><a name="nmc"></a>
</p><dl>
<dt><u>Variable:</u> <b>nmc</b>
<a name="IDX1169"></a>
</dt>
<dd><p>The nonmetricity coefficients, computed from <code>nm</code> by <code>nonmetricity</code>.
</p></dd></dl>

<p><a name="tensorkill"></a>
</p><dl>
<dt><u>System variable:</u> <b>tensorkill</b>
<a name="IDX1170"></a>
</dt>
<dd><p>Variable indicating if the tensor package has been initialized. Set and used by
<code>csetup</code>, reset by <code>init_ctensor</code>.
</p></dd></dl>

<p><a name="ct_005fcoords"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ct_coords</b>
<a name="IDX1171"></a>
</dt>
<dd><p>Default value: <code>[]</code>
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  <code>ct_coords</code> contains a list of coordinates.
While normally defined when the function <code>csetup</code> is called,
one may redefine the coordinates with the assignment
<code>ct_coords: [j1, j2, ..., jn]</code> where the j's are the new coordinate names.
See also <code>csetup</code>.
</p></dd></dl>

<hr size="6">
<a name="SEC155"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC154" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC156" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.10 Reserved names </h4>

<p>The following names are used internally by the <code>ctensor</code> package and
should not be redefined:
</p>
<pre class="example">  Name         Description
  ---------------------------------------------------------------------
  _lg()        Evaluates to lfg if frame metric used, lg otherwise
  _ug()        Evaluates to ufg if frame metric used, ug otherwise
  cleanup()    Removes items drom the deindex list
  contract4()  Used by psi()
  filemet()    Used by csetup() when reading the metric from a file
  findde1()    Used by findde()
  findde2()    Used by findde()
  findde3()    Used by findde()
  kdelt()      Kronecker-delta (not generalized)
  newmet()     Used by csetup() for setting up a metric interactively
  setflags()   Used by init_ctensor()
  readvalue()
  resimp()
  sermet()     Used by csetup() for entering a metric as Taylor-series
  txyzsum()
  tmetric()    Frame metric, used by cmetric() when cframe_flag:true
  triemann()   Riemann-tensor in frame base, used when cframe_flag:true
  tricci()     Ricci-tensor in frame base, used when cframe_flag:true
  trrc()       Ricci rotation coefficients, used by christof()
  yesp()
</pre>
<hr size="6">
<a name="SEC156"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC155" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 20.3.2.11 Changes </h4>

<p>In November, 2004, the <code>ctensor</code> package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of Macsyma.
</p>
<pre class="example">  New Name     Old Name        Description
  ---------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
  lgeod[]      EM              Geodesic equations
  ein[]        G[]             Mixed Einstein-tensor
  ric[]        LR[]            Mixed Ricci-tensor
  ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
  ctaypov      MINP            Maximum power in Taylor-series expansion
  cgeodesic()  MOTION          Compute geodesic equations
  ct_coords    OMEGA           Metric coordinates
  ctayvar      PARAM           Taylor-series expansion variable
  lriem[]      R[]             Covariant Riemann-tensor
  uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
  ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
  uric[]       RICCI[]         Contravariant Ricci-tensor
  uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
  cmetric()    SETMETRIC()     Set up the metric
  ctaypt       TAYPT           Point for Taylor-series expansion
  ctayswitch   TAYSWITCH       Taylor-series setting switch
  csetup()     TSETUP()        Start interactive setup session
  ctransform() TTRANSFORM()    Interactive coordinate transformation
  uriem[]      UR[]            Contravariant Riemann-tensor
  weyl[]       W[]             (3,1) Weyl-tensor
</pre>




<hr size="6">
<a name="Paket-atensor"></a>
<a name="SEC157"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC156" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.4 Paket <small>ATENSOR</small> </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC158">20.4.1 Einf&uuml;hrung in <small>ATENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC159">20.4.2 Funktionen und Variablen f&uuml;r <small>ATENSOR</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-atensor"></a>
<a name="SEC158"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC157" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC159" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.1 Einf&uuml;hrung in <small>ATENSOR</small> </h3>


<p>Das Paket <code>atensor</code> erlaubt das algebraische Rechnen mit Tensoren.  Mit
dem Kommando <code>load(atensor)</code> wird das Paket geladen.  Um das Paket zu
initialisieren, wird die Funktion <code><a href="#init_005fatensor">init_atensor</a></code> ausgef&uuml;hrt.
</p>

<p>Im wesentlichen enth&auml;lt das Paket <code>atensor</code> Regeln f&uuml;r die
Vereinfachung von Ausdr&uuml;cken mit dem <code><a href="maxima_19.html#dot">dot-Operator</a></code> Operator
<code>&quot;.&quot;</code>.  <code>atensor</code> kennt verschiedene Algebren.  Mit der Funktion
<code>init_atensor</code> werden die Regeln einer Algebra initialisiert.
</p>

<p>Um die M&ouml;glichkeiten des Paketes <code>atensor</code> zu zeigen, wird im Folgenden
die Algebra der Quaternionen als eine Clifford-Algebra Cl(0,2) mit zwei
Basisvektoren definiert.  Die drei imagin&auml;ren Einheiten <code>i</code>, <code>j</code>
und <code>k</code> werden durch die zwei Vektoren <code>v[1]</code> und <code>v[2]</code> sowie
das Produkt <code>v[1] . v[2]</code> dargestellt:
</p>
<pre class="example">    i = v     j = v     k = v  . v
         1         2         1    2
</pre>

<p>Das Paket <code>atensor</code> hat eine vordefinierte Algebra der Quaternionen.  Hier
wird die Algebra der Quaterinonen als Clifford-Algebra Cl(0,2) definiert und
die Multiplikationstabelle der Basisvektoren konstruiert.
</p>
<pre class="example">(%i1) load(atensor)$

(%i2) init_atensor(clifford,0,0,2);
(%o2)                         done
(%i3) atensimp(v[1].v[1]);
(%o3)                          - 1
(%i4) atensimp((v[1].v[2]).(v[1].v[2]));
(%o4)                          - 1
(%i5) q:zeromatrix(4,4);
                         [ 0  0  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o5)                    [            ]
                         [ 0  0  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%i6) q[1,1]:1;
(%o6)                           1
(%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
(%o7)                         done
(%i8) q[1,4]:q[4,1]:v[1].v[2];
(%o8)                        v  . v
                              1    2
(%i9) for i from 2 thru 4 do
          for j from 2 thru 4 do
              q[i,j]:atensimp(q[i,1].q[1,j]);
(%o9)                         done
(%i10) q;
            [    1        v         v      v  . v  ]
            [              1         2      1    2 ]
            [                                      ]
            [   v         - 1     v  . v    - v    ]
            [    1                 1    2      2   ]
(%o10)      [                                      ]
            [   v      - v  . v     - 1      v     ]
            [    2        1    2              1    ]
            [                                      ]
            [ v  . v      v        - v       - 1   ]
            [  1    2      2          1            ]
</pre>

<p>Indizierte Symbole mit dem Namen, der in der Optionsvariablen <code><a href="#asymbol">asymbol</a></code>
abgelegt ist, werden von <code>atensor</code> als Basisvektoren erkannt.  Dabei
l&auml;uft der Index von <code>1</code> bis <code><a href="#adim">adim</a></code>.  F&uuml;r indizierte Symbole
werden die Bilinearformen <code><a href="#sf">sf</a></code>, <code><a href="#af">af</a></code> und <code><a href="#av">av</a></code> ausgewertet.
Die Auswertung ersetzt die Bilinearform <code>fun(v[i].v[j])</code>, durch das
Matrixelement <code>aform[i,j]</code>, wobei <code>v</code> einen Basisvektor bezeichnet
und <code>fun</code> einer der Bilinearformen <code>sf</code> oder <code>af</code> ist.  Ist
<code>fun</code> die Bilinearform <code>av</code>, dann wird <code>v[aform[i,j]]</code> f&uuml;r
<code>av(v[i],v[j])</code> substituiert.  Siehe auch die Optionsvariable
<code><a href="#aform">aform</a></code>.
</p>

<p>Die Bilinearformen <code>sf</code>, <code>af</code> und <code>av</code> k&ouml;nnen vom Nutzer
neu definiert werden, um eine gew&uuml;nschte Algebra zu definieren.
</p>

<p>Wird das Paket <code>atensor</code> geladen, werden die folgenden Schalter auf die
angegebenen Werte gesetzt:
</p>
<pre class="example">dotscrules  : true
dotdistrib  : true
dotexptsimp : false
</pre>

<p>Wird das symbolische Rechnen in einer nicht-assoziativen Algebra gew&uuml;nscht,
kann auch noch der Schalter <code><a href="maxima_19.html#dotassoc">dotassoc</a></code> auf den Wert <code>false</code> gesetzt
werden.  In diesem Fall kann jedoch die Funktion <code><a href="#atensimp">atensimp</a></code> nicht immer
eine gew&uuml;nschte Vereinfachung erzielen.
</p>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-atensor"></a>
<a name="SEC159"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC158" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.2 Funktionen und Variablen f&uuml;r <small>ATENSOR</small> </h3>

<p><a name="init_005fatensor"></a>
</p><dl>
<dt><u>Funktion:</u> <b>init_atensor</b><i> (<var>alg_type</var>, <var>opt_dims</var>)</i>
<a name="IDX1172"></a>
</dt>
<dt><u>Funktion:</u> <b>init_atensor</b><i> (<var>alg_type</var>)</i>
<a name="IDX1173"></a>
</dt>
<dd>
<p>Initialisiert das Paket <code>atensor</code> mit der angegebenen Algebra
<var>alg_type</var>.  Das Argument <var>alg_type</var> kann einen der folgenden
Werte haben:
</p>
<dl compact="compact">
<dt> <code>universal</code></dt>
<dd><p>Eine allgemeine Algebra, f&uuml;r die keine Vertauschungsregeln definiert sind.
</p>
</dd>
<dt> <code>grassmann</code></dt>
<dd><p>Eine Gra&szlig;mann-Algebra, f&uuml;r die die Vertauschungsregel <code>u.v + v.u = 0</code>
definiert ist.
</p>
</dd>
<dt> <code>clifford</code></dt>
<dd><p>Eine Clifford-Algebra, die durch die Vertauschungsregel <code>u.v + v.u =
-2*sf(u,v)</code> definiert ist.  Die Bilinearform <code><a href="#sf">sf</a></code> ist eine symmetrische
Funktion, die einen skalaren Wert als Ergebnis hat.  Das Argument <var>opt_dims</var>
kann bis zu drei positive ganze Zahlen sein, die die positiven, 
entarteten und negativen Dimensionen der Algebra bezeichnen.  Die Dimension
<code><a href="#adim">adim</a></code> und die Matrix <code><a href="#aform">aform</a></code> werden entsprechend der angegebenen
Argumente <var>opt_dims</var> initialisiert.  Sind keine Argumente <var>opt_dims</var>
vorhanden, wird die Dimension <code>adim</code> zu Null initialisiert und keine
Matrix <code>aform</code> definiert.
</p>
</dd>
<dt> <code>symmetric</code></dt>
<dd><p>Eine symmetrische Algebra, die durch die Vertauschungsregel <code>u.v - v.u = 0</code>
definiert ist.
</p>
</dd>
<dt> <code>symplectic</code></dt>
<dd><p>Eine symplektische Algebra, die durch die Vertauschungsregel
<code>u.v - v.u = 2*af(u,v)</code> definiert ist.  Die Bilinearform <code><a href="#af">af</a></code> ist
eine antisymmetrische Funktion, die einen skalaren Wert als Ergebnis hat.  Das 
Argument <var>opt_dims</var> kann bis zu zwei positive ganze Zahlen enthalten,
die die nicht-degenerierten und degenerierten Dimensionen der Algebra
bezeichnen.  Die Dimension <code><a href="#adim">adim</a></code> und die Matrix <code><a href="#aform">aform</a></code>
werden entsprechend der angegebenen Argumente <var>opt_dims</var> initialisiert.
Sind keine Argumente <var>opt_dims</var> vorhanden, wird die Dimension <code>adim</code>
zu Null initialisiert und keine Matrix <code>aform</code> definiert. 
</p>
</dd>
<dt> <code>lie_envelop</code></dt>
<dd><p>Eine einh&uuml;llende Lie-Algebra, die durch die Vertauschungsregel
<code>u.v - v.u = 2*av(u,v)</code> definiert ist, wobei die Bilinearform <code><a href="#av">av</a></code>
eine antisymmetrische Funktion ist.  Das Argument <var>opt_dims</var> kann eine
positive ganze Zahl sein, welche die Dimension der Lie-Algebra angibt.  Die
Dimension <code><a href="#adim">adim</a></code> und die Matrix <code><a href="#aform">aform</a></code> werden entsprechend des
Argumentes <var>opt_dims</var> initialisiert.  Ist kein Argument <var>opt_dims</var>
vorhanden, wird die Dimension <code>adim</code> zu Null initialisiert und keine Matrix
<code>aform</code> definiert.
</p></dd>
</dl>


<p>Die Funktion <code>init_atensor</code> kennt weiterhin einige vordefinierte
Algebren:
</p>
<dl compact="compact">
<dt> <code>complex</code></dt>
<dd><p>Die Algebra der komplexen Zahlen, die als eine Clifford-Algebra Cl(0,1)
definiert wird.  Das Kommando <code>init_atensor(complex)</code> ist &auml;quivalent zum
Kommando <code>init_atensor(clifford, 0, 0, 1)</code>.
</p>
</dd>
<dt> <code>quaternion</code></dt>
<dd><p>Die Algebra der Quaternionen, die als eine Clifford-Algebra vom Typ Cl(0,2)
definiert wird.  Das Kommando <code>init_atensor(quaternion)</code>
ist &auml;quivalent zum Kommando <code>init_atensor(clifford, 0, 0, 2)</code>.
</p>
</dd>
<dt> <code>pauli</code></dt>
<dd><p>Die Algebra der Pauli-Matrizen, die als eine Clifford-Algebra Cl(3,0)
definiert wird.  Das Kommando <code>init_atensor(pauli)</code> ist &auml;quivalent
zum Kommando <code>init_atensor(clifford, 3)</code>.
</p>
</dd>
<dt> <code>dirac</code></dt>
<dd><p>Die Algebra der Dirac-Matrizen, die als eine Clifford-Algebra Cl(3,0,1)
definiert wird.  Das Kommando <code>init_atensor(dirac)</code> ist &auml;quivalent zum
Kommando <code>init_atensor(clifford, 3, 0, 1)</code>.
</p></dd>
</dl>
</dd></dl>

<p><a name="atensimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>atensimp</b><i> (<var>expr</var>)</i>
<a name="IDX1174"></a>
</dt>
<dd>
<p>Vereinfacht einen Ausdruck <var>expr</var> entsprechend der Regeln f&uuml;r die Algebra,
die mit der Funktion <code><a href="#init_005fatensor">init_atensor</a></code> festgelegt ist.  Die Regeln werden
rekursiv auf den Ausdruck angewendet.  Dabei werden auch Bilinearformen
<code><a href="#sf">sf</a></code>, <code><a href="#af">af</a></code> und <code><a href="#av">av</a></code> ausgewertet.
</p>
<p>Beispiele:
</p>
<p>Die folgenden Beispiele zeigen das Rechnen mit der Algebra der Quaternionen.
</p>
<pre class="example">(%i1) load(atensor)$

(%i2) init_atensor(quaternion);
(%o2)                         done
(%i3) atensimp(v[1].v[1]);
(%o3)                          - 1
(%i4) atensimp(v[2].v[2]);
(%o4)                          - 1
(%i5) atensimp((v[1].v[2]) . (v[1].v[2]));
(%o5)                          - 1
(%i6) expand((2*v[1]+3*v[2])^^2);
(%o6) 9 (v  . v ) + 6 (v  . v ) + 6 (v  . v ) + 4 (v  . v )
          2    2        2    1        1    2        1    1
(%i7) atensimp(%);
(%o7)                         - 13
</pre></dd></dl>

<p><a name="alg_005ftype"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>alg_type</b>
<a name="IDX1175"></a>
</dt>
<dd><p>Standardwert: <code>universal</code>
</p>

<p>Der Typ der Algebra, die bei der Vereinfachung von Ausdr&uuml;cken mit der
Funktion <code><a href="#atensimp">atensimp</a></code> angewendet wird.  Die Algebra wird von der Funktion
<code>init_atensor</code> initialisiert.  M&ouml;gliche Algebren sind <code>universal</code>,
<code>grassmann</code>, <code>clifford</code>, <code>symmetric</code>, <code>symplectic</code> und
<code>lie_envelop</code>.  Siehe f&uuml;r eine ausf&uuml;hrliche Erl&auml;uterung der Algebren
die Funktion <code><a href="#init_005fatensor">init_atensor</a></code>.
</p></dd></dl>

<p><a name="adim"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>adim</b>
<a name="IDX1176"></a>
</dt>
<dd><p>Standardwert: <code>0</code>
</p>

<p>Die Dimension der Algebra, die bei der Vereinfachung von Ausdr&uuml;cken mit der
Funktion <code><a href="#atensimp">atensimp</a></code> angewendet wird.  Die Dimension wird von der Funktion
<code><a href="#init_005fatensor">init_atensor</a></code> initialisiert.  Ein indiziertes Symbol mit dem Bezeichner
<code><a href="#asymbol">asymbol</a></code> ist dann ein Basisvektor, wenn der Index kleiner oder gleich
der Dimension <code>adim</code> ist.
</p>
<p>Beispiel:
</p>
<p>Die Dirac-Algebra hat die Dimension <code>4</code> und <code>v[4]</code> ist ein
Basisvektor.
</p>
<pre class="example">(%i1) load(atensor)$

(%i2) init_atensor(dirac);
(%o2)                         done
(%i3) adim;
(%o3)                           4
(%i4) abasep(v[4]);
(%o4)                         true
</pre></dd></dl>

<p><a name="aform"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>aform</b>
<a name="IDX1177"></a>
</dt>
<dd><p>Standardwert: <code>ident(3)</code>
</p>

<p>Matrix mit den Werten der Bilinearformen <code><a href="#sf">sf</a></code>, <code><a href="#af">af</a></code> und
<code><a href="#av">av</a></code>.  Der Standardwert ist die dreidimensionale Einheitsmatrix.
</p>
<p>Beispiel:
</p>
<p>Das Beispiel zeigt die Matrix <code>aform</code> f&uuml;r eine Lie-Algebra mit drei
Dimensionen und die Ergebnisse der Bilinearform <code>av</code> f&uuml;r diese Algebra.
</p>
<pre class="example">(%i1) load(atensor)$

(%i2) init_atensor(lie_envelop, 3);
(%o2)                         done
(%i3) aform;
                        [  0    3   - 2 ]
                        [               ]
(%o3)                   [ - 3   0    1  ]
                        [               ]
                        [  2   - 1   0  ]
(%i4) av(v[1], v[2]);
(%o4)                          v
                                3
(%i5) av(v[1], v[3]);
(%o5)                         - v
                                 2
</pre></dd></dl>

<p><a name="asymbol"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>asymbol</b>
<a name="IDX1178"></a>
</dt>
<dd><p>Standardwert: <code>v</code>
</p>

<p>Enth&auml;lt das Symbol, das einen Basisvektor des Paketes <code>atensor</code>
bezeichnet.  Mit der Funktion <code><a href="#abasep">abasep</a></code> kann getestet werde, ob ein
indiziertes Symbol einen Basisvektor der Algebra bezeichnet.
</p>
<p>Beispiel:
</p>
<p>In diesem Beispiel wird <code>asymbol</code> auf den Wert <code>x</code> gesetzt.
</p>
<pre class="example">(%i1) load(atensor)$

(%i2) init_atensor(symmetric, 2);
(%o2)                         done
(%i3) asymbol;
(%o3)                           v
(%i4) abasep(v[2]);
(%o4)                         true
(%i5) asymbol: x;
(%o5)                           x
(%i6) abasep(x[2]);
(%o6)                         true
</pre></dd></dl>

<p><a name="sf"></a>
</p><dl>
<dt><u>Funktion:</u> <b>sf</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1179"></a>
</dt>
<dd>
<p>Eine symmetrische Bilinearform, die bei der Vereinfachung von Ausdr&uuml;cken
mit der Funktion <code><a href="#atensimp">atensimp</a></code> angewendet wird.  Die Funktion kann vom Nutzer
durch eine neue Funktion ersetzt werden.  Die Standardimplementation pr&uuml;ft
mit der Funktion <code><a href="#abasep">abasep</a></code>, ob die Argumente <var>u</var> und <var>v</var>
Basisvektoren sind und setzt f&uuml;r diesen Fall den entsprechen Wert der Matrix
<code><a href="#aform">aform</a></code> ein.
</p></dd></dl>

<p><a name="af"></a>
</p><dl>
<dt><u>Funktion:</u> <b>af</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1180"></a>
</dt>
<dd>
<p>Eine antisymmetrische Bilinearform, die bei der Vereinfachung von Ausdr&uuml;cken
mit der Funktion <code><a href="#atensimp">atensimp</a></code> angewendet wird.  Die Funktion kann vom Nutzer
durch eine neue Funktion ersetzt werden.  Die Standardimplementation pr&uuml;ft
mit der Funktion <code><a href="#abasep">abasep</a></code>, ob die Argumente <var>u</var> und <var>v</var>
Basisvektoren sind und setzt f&uuml;r diesen Fall den entsprechenden Wert der
Matrix <code><a href="#aform">aform</a></code> ein.
</p></dd></dl>

<p><a name="av"></a>
</p><dl>
<dt><u>Funktion:</u> <b>av</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1181"></a>
</dt>
<dd>
<p>Eine antisymmetrische Bilinearform, die bei der Vereinfachung von Ausdr&uuml;cken
mit der Funktion <code><a href="#atensimp">atensimp</a></code> angewendet wird.  Die Funktion kann vom Nutzer
durch eine neue Funktion ersetzt werden.  Die Standardimplementation pr&uuml;ft
mit der Funktion <code><a href="#abasep">abasep</a></code>, ob die Argumente <var>u</var> und <var>v</var>
Basisvektoren sind und setzt f&uuml;r diesen Fall den entsprechenden Wert
<code>v[aform[i,j]]</code> der Matrix <code><a href="#aform">aform</a></code> ein.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(atensor)$
(%i2) adim: 3;
(%o2)                           3
(%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                        [  0    3   - 2 ]
                        [               ]
(%o3)                   [ - 3   0    1  ]
                        [               ]
                        [  2   - 1   0  ]
(%i4) asymbol: x;
(%o4)                           x
(%i5) av(x[1], x[2]);
(%o5)                          x
                                3
(%i6) av(x[1], x[3]);
(%o6)                         - x
                                 2
</pre></dd></dl>

<p><a name="abasep"></a>
</p><dl>
<dt><u>Funktion:</u> <b>abasep</b><i> (<var>v</var>)</i>
<a name="IDX1182"></a>
</dt>
<dd>
<p>Pr&uuml;ft, ob das Argument <var>v</var> ein Basisvektor ist.  Ein Basisvektor ist ein
indiziertes Symbol mit dem Symbol <code><a href="#asymbol">asymbol</a></code> als Bezeichner und einem
Index im Bereich von <code>1</code> bis <code><a href="#adim">adim</a></code>.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(atensor)$
(%i2) asymbol: x$
(%i3) adim:3$
(%i4) abasep(x[1]);
(%o4)                         true
(%i5) abasep(x[3]);
(%o5)                         true
(%i6) abasep(x[4]);
(%o6)                         false
</pre></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
