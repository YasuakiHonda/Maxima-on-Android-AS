<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 24. Muster und Regeln</title>

<meta name="description" content="Maxima Manual: 24. Muster und Regeln">
<meta name="keywords" content="Maxima Manual: 24. Muster und Regeln">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Muster-und-Regeln"></a>
<a name="SEC183"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_23.html#SEC182" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC184" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_23.html#SEC178" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_25.html#SEC186" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 24. Muster und Regeln </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC184">24.1 Einf&uuml;hrung in Muster und Regeln</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC185">24.2 Funktionen und Variablen f&uuml;r Muster und Regeln</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-Muster-und-Regeln"></a>
<a name="SEC184"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC183" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC185" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC183" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC183" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_25.html#SEC186" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.1 Einf&uuml;hrung in Muster und Regeln </h2>

<p>Dieses Kapitel beschreibt nutzerdefinierte Muster und Regeln f&uuml;r die
Vereinfachung von Ausdr&uuml;cken.  Es gibt zwei verschiedene Gruppen von
Funktionen, die einen unterschiedlichen Musterabgleich implementieren.
Die eine Gruppe enth&auml;lt die Funktionen <code><a href="#tellsimp">tellsimp</a></code>,
<code><a href="#tellsimpafter">tellsimpafter</a></code>, <code><a href="#defmatch">defmatch</a></code>, <code><a href="#defrule">defrule</a></code>,
<code><a href="#apply1">apply1</a></code>, <code><a href="#applyb1">applyb1</a></code> und <code><a href="#apply2">apply2</a></code>.  In der anderen Gruppe
sind die Funktionen <code><a href="#let">let</a></code> und <code><a href="#letsimp">letsimp</a></code> enthalten.  Beide Methoden
verwenden Mustervariablen, die mit der Funktion <code><a href="#matchdeclare">matchdeclare</a></code> definiert
werden.
</p>
<p>Regeln, die mit den Funktionen <code>tellsimp</code> und <code>tellsimpafter</code>
definiert werden, werden von Maxima automatisch bei der Vereinfachung von
Ausdr&uuml;cken angewendet.  Regeln, die mit den Funktionen <code>defmatch</code>, 
<code>defrule</code> oder <code>let</code> definiert werden, werden durch den Aufruf einer 
Funktion auf einen Ausdruck angewendet.
</p>
<p>Maxima kennt weitere Methoden wie die Definition von minimalen Polynomen mit
der Funktion <code><a href="maxima_17.html#tellrat">tellrat</a></code>, um Einfluss auf die Vereinfachung von 
Polynomen zu nehmen, oder Funktionen der kommutativen und nicht-kommutativen
Algebra, die in dem Paket <a href="maxima_32.html#SEC219">affine</a> definiert sind.
</p>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-Muster-und-Regeln"></a>
<a name="SEC185"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC184" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_25.html#SEC186" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC183" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC183" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_25.html#SEC186" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.2 Funktionen und Variablen f&uuml;r Muster und Regeln </h2>

<p><a name="announce_005frules_005ffiring"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>announce_rules_firing</b>
<a name="IDX1372"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>Hat die Optionsvariable <code>announce_rules_firing</code> den Wert <code>true</code> und
wird mit den Funktionen <code><a href="#tellsimp">tellsimp</a></code> oder <code><a href="#tellsimpafter">tellsimpafter</a></code> eine Regel
definiert, dann wird immer dann eine Meldung ausgegeben, wenn die Regel
angewendet wird.  <code>announce_rules_firing</code> hat keinen Einfluss auf Regeln,
die bereits definiert sind.  Die Meldung von Regeln kann auch nicht durch das
Setzen von <code>announce_rules_firing</code> auf den Wert <code>false</code> abgeschaltet
werden.
</p>
<p>Diese Optionsvariable ist n&uuml;tzlich, wenn die Anwendung von nutzerdefinierten
Regeln f&uuml;r die Fehlersuche kontrolliert werden soll.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) announce_rules_firing:true;
(%o1)                         true
(%i2) tellsimpafter(tan(x), sin(x)/cos(x));
(%o2)                 [tanrule1, simp-%tan]
(%i3) tan(x);

By tanrule1 , tan(x) --&gt; sin(x)/cos(x) 
                             sin(x)
(%o3)                        ------
                             cos(x)
</pre></dd></dl>

<p><a name="apply1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>apply1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1373"></a>
</dt>
<dd><p>Wendet die Regel <var>rule_1</var> auf den Ausdruck <var>expr</var> solange an, bis sich
das Ergebnis nicht mehr &auml;ndert.  Die Regel wird zuerst auf der obersten Ebene
des Ausdrucks und dann nacheinander von links nach rechts auf die
Teilausdr&uuml;cke angewendet.  Ist <var>expr_1</var> das Ergebnis der Anwendung der
Regel <var>rule_1</var>, dann wird die Regel <var>rule_2</var> auf gleiche Weise auf den
Ausdruck <var>expr_1</var> angewendet.  Zuletzt wird die Regel <var>rule_n</var>
angewendet.  Das letzte Ergebnis wird zur&uuml;ckgegeben.
</p>
<p>Die Optionsvariable <code><a href="#maxapplydepth">maxapplydepth</a></code> enth&auml;lt die gr&ouml;&szlig;te
Verschachtelungstiefe, f&uuml;r die die Funktionen <code>apply1</code> und
<code>apply2</code> auf einen Ausdruck angewendet werden.
</p>
<p>Siehe auch die Funktionen <code><a href="#applyb1">applyb1</a></code> und <code><a href="#apply2">apply2</a></code>, um Regeln auf
einen Ausdruck anzuwenden, die mit der Funktion <code><a href="#defrule">defrule</a></code> definiert sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o1)               trig1 : tan(x) -&gt; ------
                                      cos(x)
(%i2) defrule(trig2, cot(x), 1/tan(x));
                                        1
(%o2)               trig2 : cot(x) -&gt; ------
                                      tan(x)
(%i3) apply1(cot(x), trig1, trig2);
                               1
(%o3)                        ------
                             tan(x)
(%i4) apply1(cot(x), trig2, trig1);
                             cos(x)
(%o4)                        ------
                             sin(x)
</pre>
<p>Die folgenden Beispiele zeigen, wie mit der Optionsvariablen
<code>maxapplydepth</code> die Tiefe kontrolliert wird, in der eine Regel
auf die Teilausdr&uuml;cke angewendet wird.
</p>
<pre class="example">(%i1) expr: tan(x)+exp(a+2*tan(x));
                                2 tan(x) + a
(%o1)                tan(x) + %e
(%i2) defrule(trig, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o2)                trig : tan(x) -&gt; ------
                                      cos(x)
(%i3) maxapplydepth: 1;
(%o3)                           1
(%i4) apply1(expr, trig);
                     sin(x)     2 tan(x) + a
(%o4)                ------ + %e
                     cos(x)
(%i5) maxapplydepth: 4;
(%o5)                           4
(%i6) apply1(expr, trig);
                                2 sin(x)
                                -------- + a
                     sin(x)      cos(x)
(%o6)                ------ + %e
                     cos(x)
</pre></dd></dl>

<p><a name="apply2"></a>
</p><dl>
<dt><u>Funktion:</u> <b>apply2</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1374"></a>
</dt>
<dd><p>Zun&auml;chst werden nacheinander die Regeln <var>rule_1</var>, <var>rule_2</var>, &hellip;
auf den Ausdruck <var>expr</var> angewendet.  Schl&auml;gt die Anwendung aller Regeln
fehl, werden die Regeln nacheinander auf die Teilausdr&uuml;cke des Argumentes
<var>expr</var> angewendet.  Kann eine der Regeln erfolgreich angewendet werden,
wird die Anwendung aller Regeln auf den Teilausdruck wiederholt.
</p>
<p>Im Unterschied zur Funktion <code><a href="#apply1">apply1</a></code> werden von der Funktion <code>apply2</code>
immer alle Regeln angewendet.  Sind jedoch die Regeln, die als Argumente
&uuml;bergeben werden, zirkul&auml;r definiert, so f&uuml;hrt Maxima eine Endlosschleife
aus.  Siehe dazu auch das Beispiel unten.
</p>
<p>Die Optionsvariable <code><a href="#maxapplydepth">maxapplydepth</a></code> enth&auml;lt die gr&ouml;&szlig;te
Verschachtelungstiefe, f&uuml;r die die Funktionen <code>apply1</code> und <code>apply2</code>
auf einen Ausdruck angewendet werden.
</p>
<p>Siehe auch die Funktionen <code><a href="#apply1">apply1</a></code> und <code><a href="#applyb1">applyb1</a></code>, um Regeln
auf einen Ausdruck anzuwenden, die mit der Funktion <code><a href="#defrule">defrule</a></code> definiert
sind.
</p>
<p>Beispiele:
</p>
<p>Im Unterschied zur Funktion <code><a href="#apply1">apply1</a></code> ist in diesem Fall das Ergebnis
immer <code>sin(x)/cos(x)</code>, da alle Regeln wiederholt auf einen Teilausdruck
angewendet werden, wenn sich der Ausdruck f&uuml;r eine Regel &auml;ndert.
</p>
<pre class="example">(%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o1)               trig1 : tan(x) -&gt; ------
                                      cos(x)
(%i2) defrule(trig2, cot(x), 1/tan(x));
                                        1
(%o2)               trig2 : cot(x) -&gt; ------
                                      tan(x)
(%i3) apply2(cot(x), trig1, trig2);
                             cos(x)
(%o3)                        ------
                             sin(x)
(%i4) apply2(cot(x), trig2, trig1);
                             cos(x)
(%o4)                        ------
                             sin(x)
</pre>
<p>Das folgende Beispiel zeigt eine zirkul&auml;re Definition der Regeln <code>trig1</code>
und <code>trig2</code>.  Mit der Funktion <code>apply1</code> h&auml;ngt das Ergebnis von der
Reihenfolge der Anwendung der Regeln ab.  Die Anwendung der Funktion
<code>apply2</code> f&uuml;hrt f&uuml;r dieses Beispiel zu einer Endlosschleife.
</p>
<pre class="example">(%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o1)               trig1 : tan(x) -&gt; ------
                                      cos(x)
(%i2) defrule(trig2, sin(x)/cos(x), tan(x));
                            sin(x)
(%o2)               trig2 : ------ -&gt; tan(x)
                            cos(x)
(%i3) expr: tan(x) + exp(sin(x)/cos(x));
                                   sin(x)
                                   ------
                                   cos(x)
(%o3)                   tan(x) + %e
(%i4) apply1(expr, trig1, trig2);
                                   tan(x)
(%o4)                   tan(x) + %e
(%i5) apply1(expr, trig2, trig1);
                                   sin(x)
                                   ------
                        sin(x)     cos(x)
(%o5)                   ------ + %e
                        cos(x)
</pre></dd></dl>

<p><a name="applyb1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>applyb1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1375"></a>
</dt>
<dd><p>Wendet die Regel <var>rule_1</var> auf den tiefsten Teilausdruck in der Baumstruktur
eines Ausdrucks an.  Schl&auml;gt die Anwendung fehl, wird der Teilausdruck eine
Ebene h&ouml;her betrachtet, bis <var>rule_1</var> auf die oberste Ebene des Ausdrucks
<var>expr</var> angewendet wird.  Danach wird auf gleiche Weise die Regel
<var>rule_2</var> auf den Ausdruck <var>expr</var> angewendet.  Nachdem die letzte Regel
<var>rule_n</var> angewendet wurde, wird das Ergebnis zur&uuml;ckgegeben.
</p>
<p><code>applyb1</code> ist vergleichbar mit <code><a href="#apply1">apply1</a></code> mit dem Unterschied, dass
die Regeln Bottom-Up angewendet werden.
</p>
<p>Die Optionsvariable <code><a href="#maxapplyheight">maxapplyheight</a></code> enth&auml;lt den Wert der gr&ouml;&szlig;ten
Verschachtelungstiefe, f&uuml;r die <code>applyb1</code> angewendet wird.
</p>
<p>Siehe auch die Funktionen <code><a href="#apply1">apply1</a></code> und <code><a href="#apply2">apply2</a></code>, um Regeln auf
einen Ausdruck anzuwenden, die mit der Funktion <code><a href="#defrule">defrule</a></code> definiert sind.
</p>
<p>Beispiel:
</p>
<p>Das folgende Beispiel zeigt, wie die Regel <code>trig</code> zuerst auf die
unterste Ebene des Ausdrucks angewendet wird.  Dazu wird die Optionsvariable
<code>maxapplyheight</code> zun&auml;chst auf den Wert <code>1</code> gesetzt und dann auf den
Wert <code>4</code> erh&ouml;ht.
</p>
<pre class="example">(%i1) matchdeclare(x, true);
(%o1)                         done
(%i2) defrule(trig, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o2)                trig : tan(x) -&gt; ------
                                      cos(x)
(%i3) expr: exp(a+2*tan(b+exp(tan(x))));
                              tan(x)
                      2 tan(%e       + b) + a
(%o3)               %e
(%i4) maxapplyheight: 1;
(%o4)                           1
(%i5) applyb1(expr, trig);
                              sin(x)
                              ------
                              cos(x)
                      2 tan(%e       + b) + a
(%o5)               %e
(%i6) maxapplyheight: 4;
(%o6)                           4
(%i7) applyb1(expr, trig);
                              sin(x)
                              ------
                              cos(x)
                      2 sin(%e       + b)
                      ------------------- + a
                             sin(x)
                             ------
                             cos(x)
                       cos(%e       + b)
(%o7)               %e
</pre></dd></dl>

<p><a name="clear_005frules"></a>
</p><dl>
<dt><u>Funktion:</u> <b>clear_rules</b><i> ()</i>
<a name="IDX1376"></a>
</dt>
<dd><p>F&uuml;hrt das Kommando <code>kill(rules)</code> aus und setzt die internen Z&auml;hler
f&uuml;r die Benennung der Regeln f&uuml;r die Addition, die Multiplikation und die
Exponentiation auf den Anfangswert zur&uuml;ck.  Mit dem Kommando
<code>kill(rules)</code> werden alle Regeln entfernt, ohne dass die internen Z&auml;hler
zur&uuml;ckgesetzt werden.  Siehe auch die Funktion <code><a href="maxima_4.html#kill">kill</a></code>.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) tellsimpafter(a+b, add(a,b));
(%o1)                   [+rule1, simplus]
(%i2) tellsimpafter(a*b, mul(a,b));
(%o2)                  [*rule1, simptimes]
(%i3) tellsimpafter(a^b, expt(a,b));
(%o3)                  [^rule1, simpexpt]
(%i4) rules;
(%o4)               [+rule1, *rule1, ^rule1]
(%i5) clear_rules();
(%o5)                         done
(%i6) rules;
(%o6)                          []
</pre>
<p>Das folgende Beispiel zeigt einen Programmfehler von Maxima.  Die Funktion
<code><a href="maxima_10.html#trigsimp">trigsimp</a></code> ist mit Hilfe von Regeln implementiert.  Die Regeln werden
automatisch beim ersten Aufruf der Funktion <code>trigsimp</code> geladen und in die
Liste <code><a href="#rules">rules</a></code> eingetragen.  Werden die Regeln mit der Funktion
<code>clear_rules</code> oder <code>kill</code> gel&ouml;scht, f&uuml;hrt der n&auml;chste Aufruf
der Funktion <code>trigsimp</code> zu einem Fehler.
</p>
<pre class="example">(%i1) trigsimp(sin(x)^2+cos(x)^2);
(%o1)                           1
(%i2) rules;
(%o2) [trigrule1, trigrule2, trigrule3, trigrule4, htrigrule1, 
                              htrigrule2, htrigrule3, htrigrule4]
(%i3) disprule(trigrule1, trigrule2, trigrule3, trigrule4)$
                                        sin(a)
(%t3)             trigrule1 : tan(a) -&gt; ------
                                        cos(a)

                                          1
(%t4)             trigrule2 : sec(a) -&gt; ------
                                        cos(a)

                                          1
(%t5)             trigrule3 : csc(a) -&gt; ------
                                        sin(a)

                                        cos(a)
(%t6)             trigrule4 : cot(a) -&gt; ------
                                        sin(a)

(%i7) clear_rules();
(%o7)                         done
(%i8) rules;
(%o8)                          []
(%i9) trigsimp(sin(x)^2+cos(x)^2);

apply1: no such rule: trigrule1
#0: trigsimp(x=sin(x)^2+cos(x)^2)(trgsmp.mac line 71)
 -- an error. To debug this try: debugmode(true);
</pre></dd></dl>

<p><a name="current_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>current_let_rule_package</b>
<a name="IDX1377"></a>
</dt>
<dd><p>Standardwert: <code>default_let_rule_package</code>
</p>
<p>Die Optionsvariable <code>current_let_rule_package</code> enth&auml;lt den Namen des
aktuellen Regelpaketes, das von den Funktionen <code><a href="#let">let</a></code>,
<code><a href="#letrules">letrules</a></code>, <code><a href="#letsimp">letsimp</a></code> und <code><a href="#remlet">remlet</a></code> verwendet wird.  Der
Optionsvariablen kann jedes mit der Funktion <code>let</code> definierte Regelpaket
zugewiesen werden.
</p>
<p>Wird das Kommando <code>letsimp(expr, rule_pkg_name)</code> ausgef&uuml;hrt, dann wird 
f&uuml;r das aktuelle Kommando das Paket <code>rule_pkg_name</code> verwendet.  Der 
Wert der Variablen <code>current_let_rule_package</code> wird nicht ge&auml;ndert.
</p>
<p>Siehe auch die Optionsvariable <code><a href="#default_005flet_005frule_005fpackage">default_let_rule_package</a></code>.
</p></dd></dl>

<p><a name="default_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>default_let_rule_package</b>
<a name="IDX1378"></a>
</dt>
<dd><p>Standardwert: <code>default_let_rule_package</code>
</p>
<p>Die Optionsvariable <code>default_let_rule_package</code> bezeichnet das Regelpaket,
das verwendet wird, wenn kein Regelpaket mit der Funktion <code>let</code> explizit
definiert und der Wert der Optionsvariablen <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code>
nicht ge&auml;ndert wurde.
</p></dd></dl>

<p><a name="defmatch"></a>
</p><dl>
<dt><u>Funktion:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>, <var>x_1</var>, &hellip;, <var>x_n</var>)</i>
<a name="IDX1379"></a>
</dt>
<dt><u>Funktion:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>)</i>
<a name="IDX1380"></a>
</dt>
<dd><p>Definiert eine Aussagefunktion <code><var>progname</var>(<var>expr</var>)</code> oder
<code><var>progname</var>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>, die einen
Ausdruck <var>expr</var> testet, um zu pr&uuml;fen, ob dieser das Muster <var>pattern</var>
enth&auml;lt.
</p>
<p>Das Argument <var>pattern</var> ist ein Ausdruck mit den Musterargumenten <var>x_1</var>,
&hellip;, <var>x_n</var>.  Die Musterargumente k&ouml;nnen entfallen.  Der Ausdruck kann
weiterhin Mustervariablen enthalten, die mit der Funktion
<code><a href="#matchdeclare">matchdeclare</a></code> definiert sind.  Alle anderen Variablen und Bezeichner
entsprechen sich selbst bei einem Musterabgleich.
</p>
<p>Das erste Argument der Aussagefunktion <var>progname</var> ist ein Ausdruck
<var>expr</var>, f&uuml;r den gepr&uuml;ft wird, ob das Muster <var>pattern</var> enthalten ist.
Die weiteren Argumente der Funktion <code>progname</code> sind die Variablen, die den
Musterargumenten <var>x_1</var>, &hellip;, <var>x_n</var> des Musters <var>pattern</var>
entsprechen.
</p>
<p>Ist der Musterabgleich erfolgreich, gibt die Aussagefunktion <var>progname</var> eine
Liste mit Gleichungen zur&uuml;ck.  Die linken Seiten der Gleichungen sind die
Musterargumente und Mustervariablen und die rechten Seiten sind die
Teilausdr&uuml;cke, f&uuml;r die der Musterabgleich eine &Uuml;bereinstimmung gefunden
hat.  Die erhaltenen Ergebnisse des Musterabgleichs werden den mit
<code><a href="#matchdeclare">matchdeclare</a></code> definierten Mustervariablen, jedoch nicht den
Musterargumenten der Funktion <code>defmatch</code> zugewiesen.  Ist der
Musterabgleich nicht erfolgreich, ist die R&uuml;ckgabe <code>false</code>.
</p>
<p>Ein Muster, das keine Musterargumente oder Mustervariablen enth&auml;lt, hat den
R&uuml;ckgabewert <code>true</code>, wenn der Musterabgleich erfolgreich ist.
</p>
<p>Die Aussagefunktion <code>progname</code> wird in die Informationsliste
<code><a href="#rules">rules</a></code> eingetragen.
</p>
<p>Siehe auch die Funktionen <code><a href="#matchdeclare">matchdeclare</a></code>, <code><a href="#defrule">defrule</a></code>,
<code><a href="#tellsimp">tellsimp</a></code> und <code><a href="#tellsimpafter">tellsimpafter</a></code>.
</p>
<p>Beispiele:
</p>
<p>Definition einer Funktion <code>linearp(expr, x)</code>, die pr&uuml;ft, ob ein Ausdruck
<var>expr</var> die Form <code>a*x+b</code> hat, wobei <code>a</code> und <code>b</code> die Variable
<var>x</var> nicht enthalten und <code>a</code> von Null verschieden ist.  Die Definition
enth&auml;lt das Musterargument <var>x</var>, so dass die Linearit&auml;t des Ausdrucks
f&uuml;r eine beliebige Variable getestet werden kann.  Den Mustervariablen
<code>a</code> und <code>b</code> werden die Teilausdr&uuml;cke des Musterabgleichs zugewiesen,
nicht jedoch dem Musterargument <code>x</code>.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), 
                    b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre>
<p>Wie im letzten Beispiel wird eine Aussagefunktion definiert, die pr&uuml;ft, ob ein
Ausdruck <var>expr</var> linear ist.  In diesem Fall wird kein Musterargument
angegeben.  Der Musterabgleich kann nur feststellen, ob ein Ausdruck linear in
der Variablen <var>x</var> ist.  Eine andere Variable ist nicht m&ouml;glich.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre>
<p>Definition eine Aussagefunktion <code>checklimits(expr)</code>, die pr&uuml;ft, ob ein
Ausdruck <var>expr</var> ein bestimmtes Integral ist.
</p>
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre></dd></dl>

<p><a name="defrule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>defrule</b><i> (<var>rulename</var>, <var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1381"></a>
</dt>
<dd><p>Definiert eine Regel, um das Muster <var>pattern</var> durch den Ausdruck
<var>replacement</var> zu ersetzen.  Wird die Regel mit dem Namen <var>rulename</var>
mit den Funktionen <code><a href="#apply1">apply1</a></code>, <code><a href="#apply2">apply2</a></code> oder <code><a href="#applyb1">applyb1</a></code> auf
einen Ausdruck angewendet, werden alle Teilausdr&uuml;cke, die dem Muster
<var>pattern</var> entsprechen, durch den Ausdruck <var>replacement</var> ersetzt.  Sind
Mustervariablen vorhanden, die durch den Musterabgleich einen Wert erhalten
haben, werden die Werte eingesetzt und der Ausdruck wird vereinfacht.
</p>
<p>Die Regel <var>rulename</var> kann als eine Funktion aufgefasst werden, die einen
Ausdruck durch Anwendung eines Musterabgleichs transformiert.  Die Regel kann
wie ein Funktionsaufruf auf einen Ausdruck angewendet werden.
</p>
<p>Schl&auml;gt der Musterabgleich fehl, gibt die Regel den Wert <code>false</code>
zur&uuml;ck.
</p>
<p>Die Regel wird in die Informationsliste <code><a href="#rules">rules</a></code> eingetragen.
</p>
<p>Beispiele:
</p>
<p>Es wird eine Regel <code>trig</code> definiert, die den Ausdruck <code>sin(x)^2</code> nach
<code>1-cos(x)^2</code> transformiert.  Diese Definition funktioniert nur, wenn das
Argument der Sinusfunktion das Symbol <code>x</code> ist.
</p>
<pre class="example">(%i1) defrule(trig, sin(x)^2, 1-cos(x)^2);
                            2              2
(%o1)             trig : sin (x) -&gt; 1 - cos (x)
(%i2) trig(sin(x)^2);
                                  2
(%o2)                      1 - cos (x)
(%i3) trig(sin(y)^2);
(%o3)                         false
</pre>
<p>In diesem Beispiel wird zun&auml;chst mit der Funktion <code><a href="#matchdeclare">matchdeclare</a></code> eine
Mustervariable <code>a</code> definiert, der jeder Ausdruck zugewiesen werden kann
und die als Argument der Regel verwendet wird.  Jetzt kann das Argument der
Sinusfunktion ein beliebiger Ausdruck sein.
</p>
<pre class="example">(%i1) matchdeclare(a, true);
(%o1)                         done
(%i2) defrule(trig, sin(a)^2, 1-cos(a)^2);
                            2              2
(%o2)             trig : sin (a) -&gt; 1 - cos (a)
(%i3) trig(sin(x)^2);
                                  2
(%o3)                      1 - cos (x)
(%i4) trig(sin(exp(x))^2);
                                 2   x
(%o4)                     1 - cos (%e )
</pre>
<p>Die Regel kann mit der Funktion <code><a href="#apply1">apply1</a></code> auf Ausdr&uuml;cke angewendet werden,
wobei Teilausdr&uuml;cke, die das Muster enthalten transformiert werden.
</p>
<pre class="example">(%i5) trig(exp(sin(x)^2));
(%o5)                         false
(%i6) apply1(exp(sin(x)^2), trig);
                                   2
                            1 - cos (x)
(%o6)                     %e
</pre></dd></dl>

<p><a name="disprule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>disprule</b><i> (<var>rulename_1</var>, &hellip;, <var>rulename_n</var>)</i>
<a name="IDX1382"></a>
</dt>
<dt><u>Funktion:</u> <b>disprule</b><i> (all)</i>
<a name="IDX1383"></a>
</dt>
<dd><p>Zeigt die Regeln mit den Namen <var>rulename_1</var>, &hellip;, <var>rulename_n</var> an,
die mit den Funktionen <code><a href="#defrule">defrule</a></code>, <code><a href="#tellsimp">tellsimp</a></code> oder
<code><a href="#tellsimpafter">tellsimpafter</a></code> definiert sind, oder ein Muster, das mit der
Funktion <code><a href="#defmatch">defmatch</a></code> definiert ist.  Die Regeln werden mit einer
Zwischenmarke <code><a href="maxima_4.html#linechar">%t</a></code> angezeigt.
</p>
<p>Mit dem Kommando <code>disprule(all)</code> werden alle Regeln und Muster angezeigt,
die der Nutzer definiert hat und in der Informationsliste <code><a href="#rules">rules</a></code>
enthalten sind.
</p>
<p><code>disprule</code> wertet die Argumente nicht aus.  Der R&uuml;ckgabewert ist eine
Liste mit den Zwischenmarken, denen eine Regel zugewiesen wurde.
</p>
<p>Siehe auch die Funktion <code><a href="#letrules">letrules</a></code>, die die Regeln anzeigt, die mit
der Funktion <code><a href="#let">let</a></code> definiert sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x), 
     +rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre></dd></dl>

<p><a name="let"></a>
</p><dl>
<dt><u>Funktion:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>)</i>
<a name="IDX1384"></a>
</dt>
<dt><u>Funktion:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>)</i>
<a name="IDX1385"></a>
</dt>
<dt><u>Funktion:</u> <b>let</b><i> ([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>], <var>package_name</var>)</i>
<a name="IDX1386"></a>
</dt>
<dd><p>Definiert eine Regel, die mit der Funktion <code><a href="#letsimp">letsimp</a></code> auf einen Ausdruck
angewendet werden kann, so dass <var>prod</var> durch <var>repl</var> ersetzt wird.
Das Argument <var>prod</var> ist ein Produkt von positiven oder negativen Potenzen
der folgenden Terme:
</p>
<ul>
<li>
Atome, nach denen die Funktion <code>letsimp</code> w&ouml;rtlich sucht, wenn diese keine
Mustervariablen sind, die mit Funktion <code><a href="#matchdeclare">matchdeclare</a></code> definiert sind,
sowie Atome, die Mustervariablen sind.  In diesem Fall f&uuml;hrt die Funktion
<code>letsimp</code> einen Musterabgleich f&uuml;r die Atome durch, auf die die mit
der Funktion <code>matchdeclare</code> zugeordnete Aussagefunktion zutrifft.

</li><li>
Terme wie <code>sin(x)</code>, <code>n!</code> oder <code>f(x,y)</code>:  wie f&uuml;r Atome
sucht die Funktion <code>letsimp</code> nach w&ouml;rtlichen &Uuml;bereinstimmungen,
au&szlig;er wenn die Argumente der Terme Mustervariablen sind, die mit der
Funktion <code><a href="#matchdeclare">matchdeclare</a></code> definiert sind.  In diesem Fall wird ein
Musterabgleich ausgef&uuml;hrt.
</li></ul>

<p>Ein Term mit einer positiven Potenz stimmt mit einem Ausdruck nur dann
&uuml;berein, wenn dieser mindestens dieselbe Potenz hat.  Entsprechend gilt f&uuml;r
einen Term mit einer negativen Potenz, dass dieser dann mit einem Ausdruck
&uuml;bereinstimmt, wenn dieser mindestens dieselbe negative Potenz hat.  F&uuml;r
negative Potenzen wird eine &Uuml;bereinstimmung nur dann gefunden, wenn
die Optionsvariable <code><a href="#letrat">letrat</a></code> den Wert <code>true</code> hat.
</p>
<p>Hat die Funktion <code>let</code> eine Aussagefunktion <var>predname</var> als Argument
mit den Argumenten <var>arg_1</var>, &hellip;, <var>arg_n</var>, wird eine
&Uuml;bereinstimmung dann festgestellt, wenn der Ausdruck
<code>predname(arg_1', ..., arg_n')</code> das Ergebnis <code>true</code> hat.  Dabei sind
die Argumente <var>arg_i'</var> die Werte aus dem Musterabgleich.  Die Argumente
<var>arg_i</var> k&ouml;nnen die Namen von Variablen oder Termen sein, die im Ausdruck
<var>pred</var> auftreten.  <var>repl</var> kann ein beliebiger rationaler Ausdruck sein.
Treten irgendwelche der Symbole oder Argumente aus <var>prod</var> im Argument
<var>repl</var> auf, wird die entsprechende Substitution ausgef&uuml;hrt.
</p>
<p>Die Optionsvariable <code><a href="#letrat">letrat</a></code> kontrolliert die Vereinfachung von Quotienten
durch <code><a href="#letsimp">letsimp</a></code>.  Hat <code>letrat</code> den Wert <code>false</code>, werden der
Z&auml;hler und der Nenner eines Bruches einzeln vereinfacht.  Der Bruch als ganzes
wird dagegen nicht vereinfacht.  Hat die Optionsvariable <code>letrat</code> den Wert
<code>true</code>, werden nacheinander der Z&auml;hler, der Nenner und dann der Bruch
vereinfacht.
</p>
<p>Die Funktion <code><a href="#letsimp">letsimp</a></code> kann mit verschiedenen Regelpaketen arbeiten.  Jedes
Regelpaket kann eine beliebige Anzahl an Regeln enthalten.  Das Kommando
<code>let([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, ...,
<var>arg_n</var>], <var>package_name</var>)</code> f&uuml;gt die Regel <var>predname</var> dem Paket
<var>package_name</var> hinzu.
</p>
<p>Die Optionsvariable <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code> enth&auml;lt den Namen des
Regelpaketes, das aktuell von der Funktion <code>letsimp</code> verwendet wird.  Der
Optionsvariablen kann jedes mit dem Kommando <code>let</code> definierte Regelpaket 
zugewiesen werden.  Wird mit <code>letsimp(<var>expr</var>, <var>package_name</var>)</code>
ein Regelpaket als Argument &uuml;bergeben, wird dieses anstatt dem in 
<code>current_let_rule_package</code> enthaltene Regelpaket f&uuml;r die Vereinfachung
verwendet.  Wenn nicht anders spezifiziert, hat <code>current_let_rule_package</code>
den Standardwert <code><a href="#default_005flet_005frule_005fpackage">default_let_rule_package</a></code>.
</p>
<p>Die Informationsliste <code><a href="#let_005frule_005fpackages">let_rule_packages</a></code> enth&auml;lt die definierten
Regelpakete.  Mit der Funktion <code><a href="#letrules">letrules</a></code> k&ouml;nnen alle definierten Regeln
oder Regeln einzelner Pakete angezeigt werden.
</p>
<p>Beispiele:
</p>
<p>Die Funktion <code>isintegerp</code> pr&uuml;ft auch, ob Variablen oder Ausdr&uuml;cke eine
ganze Zahl repr&auml;sentieren.  Es wird eine Regel definiert, die dann angewendet
wird, wenn das Argument eine ganze Zahl repr&auml;sentiert.
</p>
<pre class="example">(%i1) isintegerp(x) := featurep(x, integer)$

(%i2) let(tan(x), sin(x)/cos(x), isintegerp, x);
(%o2) tan(x) --&gt; sin(x)/cos(x) where isintegerp(x)

(%i3) letsimp(tan(x));
(%o3) tan(x)

(%i4) declare(x, integer)$

(%i5) letsimp(tan(x));
(%o5) sin(x)/cos(x)
(%i6) letsimp(tan(1));
(%o6) tan(1)
</pre>
<p>Weitere Beispiele:
</p>
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre></dd></dl>

<p><a name="let_005frule_005fpackages"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>let_rule_packages</b>
<a name="IDX1387"></a>
</dt>
<dd><p>Standardwert: <code>[default_let_rule_package]</code>
</p>
<p><code>let_rule_packages</code> ist eine Informationsliste mit den vom Nutzer mit der
Funktion <code><a href="#let">let</a></code> definierten Regelpaketen.
</p></dd></dl>

<p><a name="letrat"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>letrat</b>
<a name="IDX1388"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p>Hat die Optionsvariable <code>letrat</code> den Wert <code>false</code>, werden von der
Funktion <code><a href="#letsimp">letsimp</a></code> der Z&auml;hler und der Nenner eines Bruches einzeln
vereinfacht.  Der Bruch als ganzes wird dagegen nicht vereinfacht.
</p>
<p>Hat die Optionsvariable <code>letrat</code> den Wert <code>true</code>, werden nacheinander
der Z&auml;hler, der Nenner und dann der Bruch vereinfacht.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre></dd></dl>

<p><a name="letrules"></a>
</p><dl>
<dt><u>Funktion:</u> <b>letrules</b><i> ()</i>
<a name="IDX1389"></a>
</dt>
<dt><u>Funktion:</u> <b>letrules</b><i> (<var>package_name</var>)</i>
<a name="IDX1390"></a>
</dt>
<dd><p>Zeigt die Regeln eines Regelpaketes an.  Das Kommando <code>letrules()</code> zeigt
die Regeln des aktuellen Regelpaketes an, das durch die Optionsvariable
<code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code> bezeichnet wird.  Das Kommando
<code>letrules(<var>package_name</var>)</code> zeigt die Regeln des Paketes
<var>package_name</var> an.
</p>
<p>Wenn der Optionsvariablen <code>current_let_rule_package</code> kein Name eines
Paketes zugewiesen wurde, enth&auml;lt es den Standardwert
<code><a href="#default_005flet_005frule_005fpackage">default_let_rule_package</a></code>.
</p>
<p>Siehe auch die Funktion <code><a href="#disprule">disprule</a></code>, um Regeln anzuzeigen, die mit
den Funktionen <code><a href="#tellsimp">tellsimp</a></code>, <code><a href="#tellsimpafter">tellsimpafter</a></code> und <code><a href="#defrule">defrule</a></code>
definiert wurden.
</p>
<p>Beispiel:
</p>
<p>Im folgenden Beispiel werden einem Paket mit dem Namen <code>trigrules</code> zwei
Regeln hinzugef&uuml;gt.  Die Regeln werden mit dem Kommando 
<code>letrules(trigrules)</code> angezeigt.  Wird das Paket zum aktuellen Paket
erkl&auml;rt, indem es der Variablen <code>current_let_rule_package</code> zugewiesen
wird, dann werden die Regeln auch mit dem Kommando <code>letrules()</code> angezeigt.
</p>
<pre class="example">(%i1) let([sin(x)^2, 1-cos(x)^2], trigrules);
                        2               2
(%o1)                sin (x) --&gt; 1 - cos (x)
(%i2) let([tan(x), sin(x)/cos(x)], trigrules);
                                   sin(x)
(%o2)                   tan(x) --&gt; ------
                                   cos(x)
(%i3) letrules(trigrules);
                                   sin(x)
                        tan(x) --&gt; ------
                                   cos(x)

                        2               2
                     sin (x) --&gt; 1 - cos (x)

(%o3)                         done
(%i4) letrules();
(%o4)                         done
(%i5) current_let_rule_package: trigrules;
(%o5)                       trigrules
(%i6) letrules();
                                   sin(x)
                        tan(x) --&gt; ------
                                   cos(x)

                        2               2
                     sin (x) --&gt; 1 - cos (x)

(%o6)                         done
</pre></dd></dl>

<p><a name="letsimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1391"></a>
</dt>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name</var>)</i>
<a name="IDX1392"></a>
</dt>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name_1</var>, &hellip;, <var>package_name_n</var>)</i>
<a name="IDX1393"></a>
</dt>
<dd><p>Wendet die Regeln, die mit der Funktion <code><a href="#let">let</a></code> definiert sind,
solange an, bis sich das Argument <var>expr</var> nicht mehr &auml;ndert.
<code>letsimp(<var>expr</var>)</code> wendet die aktuellen Regeln an, die mit der
Optionsvariablen <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code> bezeichnet werden.
</p>
<p><code>letsimp(<var>expr</var>, <var>package_name</var>)</code> wendet die Regeln des
Argumentes <var>package_name</var> an.  Die Optionsvariable
<code>current_let_rule_package</code> &auml;ndert ihren Wert nicht.  Es k&ouml;nnen auch
mehrere Regelpakete <var>package_name_1</var>, &hellip;, <var>package_name_n</var>
angegeben werden.
</p>
<p>Die Optionsvariable <code><a href="#letrat">letrat</a></code> kontrolliert die Vereinfachung von Quotienten
durch <code>letsimp</code>.  Hat <code>letrat</code> den Wert <code>false</code>, werden der
Z&auml;hler und der Nenner eines Bruches einzeln vereinfacht.  Der Bruch als ganzes
wird dagegen nicht vereinfacht.  Hat die Optionsvariable <code>letrat</code> den Wert
<code>true</code>, werden nacheinander der Z&auml;hler, der Nenner und dann der Bruch
vereinfacht.
</p></dd></dl>

<p><a name="matchdeclare"></a>
</p><dl>
<dt><u>Funktion:</u> <b>matchdeclare</b><i> (<var>a_1</var>, <var>pred_1</var>, &hellip;, <var>a_n</var>, <var>pred_n</var>)</i>
<a name="IDX1394"></a>
</dt>
<dd><p>Mit der Funktion <code>matchdeclare</code> werden Mustervariablen definiert.
<code>matchdeclare</code> ordnet eine Aussagefunktion <var>pred_k</var> einer Variable
oder eine Liste von Variablen <var>a_k</var> zu, so dass <var>a_k</var> bei einem
Musterabgleich mit Ausdr&uuml;cken &uuml;bereinstimmt, f&uuml;r die die Aussage ein
anderes Ergebnis als <code>false</code> hat.
</p>
<p>Eine Aussagefunktion <var>pred_i</var> kann durch den Namen einer Funktion, einen
Lambda-Ausdruck, einen Funktionsaufruf, einen Lambda-Ausdruck, dem das letzte
Argument fehlt, oder die Werte <code>true</code> oder <code>all</code> bezeichnet werden.
Ist die Aussagefunktion ein Funktionsaufruf oder ein Lambda-Aufruf, dann wird
der zu testende Ausdruck der Liste der Argumente hinzugef&uuml;gt.  Die Argumente
werden ausgewertet, wenn der Musterabgleich ausgef&uuml;hrt wird.  Ist die Aussage
der Name einer Funktion oder ein Lambda-Ausdruck, ist die zu testende Aussage
das einzige Argument.  Die Aussagefunktion braucht noch nicht definiert zu sein,
wenn mit <code>matchdeclare</code> eine Mustervariable definiert wird, da die
Aussagefunktion erst aufgerufen wird, wenn ein Musterabgleich durchgef&uuml;hrt
wird.
</p>
<p>Eine Aussagefunktion kann einen logischen Ausdruck oder die Werte <code>true</code>
oder <code>false</code> zur&uuml;ckgeben.  Logische Ausdr&uuml;cke werden von der Funktion
<code><a href="maxima_11.html#is">is</a></code> ausgewertet, wenn die Regel angewendet wird.  Daher ist es nicht
notwendig, dass die Aussagefunktion selbst die Funktion <code>is</code> aufruft.
</p>
<p>Wenn f&uuml;r einen Ausdruck eine &Uuml;bereinstimmung bei einem Musterabgleich
gefunden wird, wird der Mustervariablen der Ausdruck zugewiesen.  Jedoch nicht
f&uuml;r Mustervariablen, die Argumente der Addition <code>+</code> oder Multiplikation
<code>*</code> sind.  Diese Operatoren werden besonders behandelt.  Andere Maxima oder
vom Nutzer definierte N-ary-Operatoren werden dagegen wie normale Funktionen
behandelt.
</p>
<p>Im Falle der Addition und der Multiplikation kann der Mustervariablen ein
einzelner Term zugewiesen werden, f&uuml;r den der Musterabgleich zu einer
&Uuml;berstimmung f&uuml;hrt, oder auch eine Summe oder ein Produkt von Termen.  Die
mehrfache &Uuml;bereinstimmung hat Vorrang.  Aussagefunktionen werden in der
Reihenfolge ausgewertet, in der die der Aussagefunktion zugeordneten
Mustervariablen im Muster auftreten.  F&uuml;hrt der Musterabgleich f&uuml;r einen
Term zu einer &Uuml;bereinstimmung mit mehreren Aussagefunktionen, dann wird der
Term der Mustervariablen zugeordnet f&uuml;r den die erste Aussagefunktion
zutrifft.  Jede Aussagefunktion wird zun&auml;chst auf alle Argumente einer Summe
oder eines Produktes angewendet, bevor die n&auml;chste Aussagefunktion ausgewertet
wird.  Wird f&uuml;r die Zahlen 0 oder 1 eine &Uuml;bereinstimmung gefunden und es
sind keine weiteren Terme vorhanden, wird der Mustervariablen 0 oder 1
zugewiesen.
</p>
<p>Der Algorithmus, um Muster abzugleichen, die die Addition oder die
Multiplikation als Operanden enthalten, kann von der Anordnung der Terme im
Muster oder im zu pr&uuml;fenden Ausdruck abh&auml;ngen.  Solange sich jedoch die
einzelnen Aussagefunktionen gegeneinander ausschlie&szlig;en, wird das Ergebnis
nicht von der Reihenfolge der Argumente beeinflu&szlig;t.
</p>
<p>Der Aufruf von <code>matchdeclare</code> f&uuml;r eine Variable <var>a</var> &uuml;berschreibt
eine vorhergehende Definition f&uuml;r diese Variable.  Wird eine Regel definiert,
ist die letzte mit <code>matchdeclare</code> definierte Zuordnung zu einer
Aussagefunktion wirksam.  Der erneute Aufruf von <code>matchdeclare</code> f&uuml;r eine
Variable hat keinen Einfluss auf bereits vorhandene Regeln.
</p>
<p>Das Kommando <code>propvars(matchdeclare)</code> gibt eine Liste der Variablen
zur&uuml;ck, die mit <code>matchdeclare</code> als Mustervariable definiert sind.
<code>printprops(<var>a</var>, matchdeclare)</code> gibt die der Variable <var>a</var>
zugeordnete Aussagefunktion zur&uuml;ck.  <code>printprops(all, matchdeclare)</code>
gibt die Aussagefunktionen aller Mustervariablen zur&uuml;ck.  Mit dem Kommando
<code>remove(<var>a</var>, matchdeclare)</code> wird die Definition von <var>a</var> als
Mustervariable entfernt.  Siehe auch die Funktionen <code><a href="maxima_11.html#propvars">propvars</a></code>,
<code><a href="maxima_11.html#printprops">printprops</a></code> und <code><a href="maxima_11.html#remove">remove</a></code>.
</p>
<p>Mit den Funktionen <code><a href="#defmatch">defmatch</a></code>, <code><a href="#defrule">defrule</a></code>,
<code><a href="#tellsimp">tellsimp</a></code>, <code><a href="#tellsimpafter">tellsimpafter</a></code> und <code><a href="#let">let</a></code> werden Regeln
definiert, die f&uuml;r Ausdr&uuml;cke einen Musterabgleich ausf&uuml;hren, wobei die
Mustervariablen mit den Werten belegt werden, f&uuml;r die eine &Uuml;bereinstimmung
gefunden wird.
</p>
<p><code>matchdeclare</code> wertet die Argumente nicht aus.  <code>matchdeclare</code> gibt
immer <code>done</code> als Ergebnis zur&uuml;ck.
</p>
<p>Beispiele:
</p>
<p>Eine Aussagefunktion kann mit dem Namen einer Funktion, einem Lambda-Ausdruck,
einem Funktionsaufruf, einem Lambda-Ausdruck, dem das letzte Argument fehlt,
oder den Werten <code>true</code> oder <code>all</code> bezeichnet werden.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre>
<p>Wird f&uuml;r einen Ausdruck beim Musterabgleich eine &Uuml;bereinstimmung gefunden,
wird dieser der Mustervariablen zugewiesen.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre>
<p>Im Falle der Addition und Multiplikation kann der Mustervariablen ein einzelner
Term zugewiesen werden, welcher mit der Aussage &uuml;bereinstimmt, aber auch 
eine Summe oder ein Produkt solcher Ausdr&uuml;cke.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre>
<p>Wird nach &Uuml;bereinstimmungen f&uuml;r die Argumente der Operatoren <code>+</code> oder
<code>*</code> gesucht und schlie&szlig;en sich die Aussagefunktionen gegeneinander
aus, ist das Ergebnis unabh&auml;ngig von der Anordnung der Terme.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre>
<p>Die Funktionen <code><a href="maxima_11.html#propvars">propvars</a></code> und <code><a href="maxima_11.html#printprops">printprops</a></code> geben Informationen &uuml;ber
Mustervariablen aus.
</p>
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre></dd></dl>

<p><a name="maxapplydepth"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>maxapplydepth</b>
<a name="IDX1395"></a>
</dt>
<dd><p>Standardwert: 10000
</p>
<p><code>maxapplydepth</code> ist die maximale Verschachtelungstiefe f&uuml;r die die
Funktionen <code><a href="#apply1">apply1</a></code> und <code><a href="#apply2">apply2</a></code> auf die Baumstruktur eines Ausdrucks
angewendet werden.
</p></dd></dl>

<p><a name="maxapplyheight"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>maxapplyheight</b>
<a name="IDX1396"></a>
</dt>
<dd><p>Standardwert: 10000
</p>
<p><code>maxapplyheight</code> ist die maximale Verschachtelungstiefe f&uuml;r die die
Funktion <code><a href="#applyb1">applyb1</a></code> Bottom-up auf die Baumstruktur eines Ausdrucks
angewendet wird.
</p></dd></dl>

<p><a name="remlet"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remlet</b><i> (<var>prod</var>, <var>package_name</var>)</i>
<a name="IDX1397"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> ()</i>
<a name="IDX1398"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> (all)</i>
<a name="IDX1399"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> (all, <var>package_name</var>)</i>
<a name="IDX1400"></a>
</dt>
<dd><p>Entfernt die Regel <var>prod</var> -&gt; <var>repl</var>, die zuletzt mit der Funktion
<code><a href="#let">let</a></code> definiert wurde.  Wird mit dem Argument <var>package_name</var>
ein Paket angegeben, wird die Regeln aus dem entsprechenden Paket entfernt.
</p>
<p><code>remlet()</code> und <code>remlet(all)</code> entfernen alle Regeln aus dem aktuellen
Paket, das mit <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code> bezeichnet ist.  Wird der Name
eines Regelpaketes als Argument angegeben, werden zus&auml;tzlich die Regeln dieses
Paketes entfernt.
</p>
<p>Soll eine vorhandene Regel durch eine neue Definition ersetzt werden, muss die
Regel nicht zuvor mit <code>remlet</code> entfernt werden.  Die neue Definition
&uuml;berschreibt eine vorhandene Regel.  Wurde eine vorhandene Regel
&uuml;berschrieben und wird die letzte Regel entfernt, dann ist die vorhergehende
Regel wieder aktiv.
</p>
<p>Siehe auch die Funktion <code><a href="#remrule">remrule</a></code>, um Regeln zu entfernen, die mit
den Funktionen <code><a href="#tellsimp">tellsimp</a></code> oder <code><a href="#tellsimpafter">tellsimpafter</a></code> definiert sind.
</p></dd></dl>

<p><a name="remrule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remrule</b><i> (<var>op</var>, <var>rulename</var>)</i>
<a name="IDX1401"></a>
</dt>
<dt><u>Funktion:</u> <b>remrule</b><i> (<var>op</var>, all)</i>
<a name="IDX1402"></a>
</dt>
<dd><p>Entfernt Regeln, die mit den Funktionen <code><a href="#tellsimp">tellsimp</a></code> oder 
<code><a href="#tellsimpafter">tellsimpafter</a></code> definiert sind.
</p>
<p><code>remrule(<var>op</var>, <var>rulename</var>)</code> entfernt die Regel mit dem Namen
<var>rulename</var> vom Operator <var>op</var>.  Ist der Operator <var>op</var> ein 
Maxima-Operator oder ein nutzerdefinierter Operator, der mit Funktionen wie
<code><a href="maxima_7.html#infix">infix</a></code> oder <code><a href="maxima_7.html#prefix">prefix</a></code> definiert wurde, muss der Name des Operators
<var>op</var> als eine Zeichenkette in Anf&uuml;hrungszeichen angegeben werden.
</p>
<p><code>remrule(<var>op</var>, all)</code> entfernt alle Regeln des Operators <var>op</var>.
</p>
<p>Siehe auch die Funktion <code><a href="#remlet">remlet</a></code>, um Regeln zu entfernen, die mit der
Funktion <code><a href="#let">let</a></code> definiert sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, ?\+rule1);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, ?\@\@rule1);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre></dd></dl>

<p><a name="rules"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>rules</b>
<a name="IDX1403"></a>
</dt>
<dd><p>Standardwert: <code>[]</code>
</p>
<p><code>rules</code> ist eine Informationsliste, die die vom Nutzer mit den Funktionen
<code>tellsimp</code>, <code>tellsimpafter</code>, <code>defmatch</code> oder <code>defrule</code>
definierten Regeln enth&auml;lt.
</p>
<p>Regeln, die mit der Funktion <code><a href="#let">let</a></code> definiert sind, sind nicht in der Liste
<code>rules</code> enthalten.  Diese Regeln werden in Paketen organisiert, die in
der Systemvariablen <code><a href="#let_005frule_005fpackages">let_rule_packages</a></code> aufgelistet und mit der Funktion
<code><a href="#letrules">letrules</a></code> angezeigt werden.
</p>
<p>Siehe auch die Systemvariable <code><a href="maxima_4.html#infolists">infolists</a></code>.
</p></dd></dl>

<p><a name="tellsimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>tellsimp</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1404"></a>
</dt>
<dd><p><code>tellsimp</code> ist vergleichbar mit der Funktion <code><a href="#tellsimpafter">tellsimpafter</a></code>,
wobei mit <code>tellsimp</code> Regeln f&uuml;r die Vereinfachung von Ausdr&uuml;cken
definiert werden, die noch vor den Regeln angewendet werden, die intern in
Maxima bekannt sind.
</p>
<p><code>tellsimp</code> wird daher eingesetzt, wenn Maxima Regeln f&uuml;r die
Vereinfachung des Ausdruckes kennt, es jedoch notwendig ist, noch vor Anwendung
dieser Regeln den Ausdruck auf eine andere Art zu modifizieren.  F&uuml;r den Fall
das Maxima den Ausdruck nicht ausreichend vereinfacht, kann es besser sein, eine
Regel mit der Funktion <code><a href="#tellsimpafter">tellsimpafter</a></code> zu definieren.
</p>
<p>Das Argument <var>pattern</var> kann keine Summe, kein Produkt, keine einzelne
Variable und keine Zahl sein.
</p>
<p>Regeln die mit <code>tellsimp</code> definiert werden, werden in die Informationsliste
<code><a href="#rules">rules</a></code> aufgenommen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre></dd></dl>

<p><a name="tellsimpafter"></a>
</p><dl>
<dt><u>Funktion:</u> <b>tellsimpafter</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1405"></a>
</dt>
<dd><p>Definiert eine Regel f&uuml;r die Vereinfachung eines Ausdrucks, die nach Anwendung
der Regeln angewendet wird, die Maxima intern kennt.  <var>pattern</var> ist ein
Ausdruck, der Mustervariablen enth&auml;lt, die mit der Funktion
<code><a href="#matchdeclare">matchdeclare</a></code> definiert sind und weitere Symbole und Operatoren, f&uuml;r
die die w&ouml;rtliche &Uuml;bereinstimmung bei einem Musterabgleich angenommen wird.
<var>replacement</var> wird in den Ausdruck substituiert, wenn der Musterabgleich
das Muster <var>pattern</var> im Ausdruck findet.  Den Mustervariablen in
<var>replacement</var> werden die Werte des Musterabgleichs zugewiesen.
</p>
<p>Das Muster <var>pattern</var> kann ein beliebiger Ausdruck sein, in dem der 
Hauptoperator keine Mustervariable ist.  Die neue Regel wird nach dem
Hauptoperator des Musters benannt und diesem zugeordnet.  Der Name von
Funktionen, mit einer unten beschriebenen Ausnahme, Listen und Arrays k&ouml;nnen
in <var>pattern</var> nicht als eine Mustervariable auftreten.  Daher k&ouml;nnen
Ausdr&uuml;cke wie <code>aa(x)</code> oder <code>bb[y]</code> nicht als Muster verwendet
werden, wenn <code>aa</code> oder <code>bb</code> Mustervariablen sind.  Die Namen
von Funktionen, Listen und Arrays, welche Mustervariablen sind, k&ouml;nnen dann
in dem Muster <var>pattern</var> auftreten, wenn sie nicht der Hauptoperator sind.
</p>
<p>Es gibt eine Ausnahme der oben genannten Einschr&auml;nkung f&uuml;r die Verwendung
von Funktionsnamen.  Der Name einer indizierten Funktion wie <code>aa[x](y)</code>
kann eine Mustervariable sein, da der Hauptoperator nicht <code>aa</code> ist, sondern
das interne Symbol <code>mqapply</code>.  Dies ist eine Konsequenz der internen
Darstellung einer indizierten Funktion.
</p>
<p>Regeln f&uuml;r die Vereinfachung werden nach der Auswertung eines Ausdrucks
angewendet, sofern die Auswertung, zum Beispiel mit dem Schalter
<code><a href="maxima_8.html#noeval">noeval</a></code>, nicht unterdr&uuml;ckt wurde.  Regeln, die mit
<code>tellsimpafter</code> definiert sind, werden nach den internen Regeln und in der
Reihenfolge angewendet, in der sie definiert sind.  Die Regeln f&uuml;r die
Vereinfachung werden zun&auml;chst f&uuml;r Teilausdr&uuml;cke und zuletzt f&uuml;r den
ganzen Ausdruck angewendet.  Es kann notwendig sein, Regeln f&uuml;r die
Vereinfachung mehrfach zum Beispiel mit dem <a href="maxima_8.html#g_t_0027_0027">Quote-Quote-Operator</a>
<code>''</code> oder dem Auswertungsschalter <code><a href="maxima_8.html#infeval">infeval</a></code> anzuwenden, um zu
erreichen, dass alle Regeln angewendet werden.
</p>
<p>Mustervariable werden als lokale Variablen in Regeln f&uuml;r die Vereinfachung
behandelt.  Sobald eine Regel definiert ist, beeinflusst die Zuweisung eines
Wertes an die Mustervariable nicht die Regel und die Variable wird nicht von
der Regel beeinflusst.  Die Zuweisung an eine Mustervariable, die aufgrund eines
erfolgreichen Musterabgleichs vorgenommen wird, beeinflusst nicht den aktuellen
Wert der Variablen.  Jedoch sind die Eigenschaften der Mustervariablen, wie sie
zum Beispiel auch mit der Funktion <code><a href="maxima_11.html#put">put</a></code> definiert werden k&ouml;nnen, global
in Maxima.
</p>
<p>Eine mit <code>tellsimpafter</code> definierte Regel wird nach dem Hauptoperator des
Musters <var>pattern</var> benannt.  Regeln f&uuml;r Maxima-Operatoren und f&uuml;r
Funktionen, die mit <code><a href="maxima_7.html#infix">infix</a></code>, <code><a href="maxima_7.html#prefix">prefix</a></code>, <code><a href="maxima_7.html#postfix">postfix</a></code>,
<code><a href="maxima_7.html#matchfix">matchfix</a></code> und <code><a href="maxima_7.html#nofix">nofix</a></code> als Operator definiert sind, haben einen
Lisp-Bezeichner als Namen.  Alle anderen Regeln erhalten einen Maxima-Bezeichner
als Namen.
</p>




<p><code>tellsimpafter</code> wertet die Argumente nicht aus.  <code>tellsimpafter</code> gibt
eine Liste der Regeln zur&uuml;ck, die f&uuml;r den Hauptoperator des Musters
<var>pattern</var> definiert sind.
</p>
<p>Siehe auch die Funktionen <code><a href="#matchdeclare">matchdeclare</a></code>, <code><a href="#defmatch">defmatch</a></code>,
<code><a href="#defrule">defrule</a></code>, <code><a href="#tellsimp">tellsimp</a></code>, <code><a href="#remrule">remrule</a></code> und
<code><a href="#clear_005frules">clear_rules</a></code>.
</p>
<p>Beispiele:
</p>
<p>Das Muster <var>pattern</var> kann ein beliebiger Ausdruck sein, in dem der
Hauptoperator keine Mustervariable ist.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre>
<p>Regeln werden in der Reihenfolge angewendet, in der sie definiert sind.
Treffen zwei Regeln bei einem Musterabgleich zu, wird die zuerst definierte
Regel angewendet.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre>
<p>Mustervariable werden als lokale Variable beim Musterabgleich der mit der
Funktion <code>tellsimpafter</code> definierten Regel behandelt.  Im Unterschied dazu
werden von Regeln, die mit <code><a href="#defmatch">defmatch</a></code> definiert sind, Mustervariable als
globale Variable behandelt.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre>
<p>Die Eigenschaften von Mustervariablen sind global, auch wenn die Werte lokal 
sind.  In diesem Beispiel wird eine Eigenschaft f&uuml;r die Zuweisung an eine
Variable mit der Funktion <code><a href="maxima_25.html#define_005fvariable">define_variable</a></code> definiert.  Die Eigenschaft 
des Symbols <code>bb</code> ist global in Maxima.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
<p>Regeln werden nach dem Hauptoperator benannt.  Die Namen der Regeln f&uuml;r
Maxima-Funktionen und nutzerdefinierte Operatoren sind Lisp-Bezeichner.  Alle
anderen Namen sind Maxima-Bezeichner.
</p>
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) remrule (foo, foorule1);
(%o10)                         foo
(%i11) remrule (&quot;^&quot;, ?\^rule1);
(%o11)                          ^
(%i12) rules;
(%o12)        [foorule2, foorule3, +rule1, *rule1]
</pre>
<p>Ein ausgearbeitetes Beispiel der nicht-kommutativen Multiplikation.
</p>
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC183" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_25.html#SEC186" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
