<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 19. Lineare Algebra</title>

<meta name="description" content="Maxima Manual: 19. Lineare Algebra">
<meta name="keywords" content="Maxima Manual: 19. Lineare Algebra">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Lineare-Algebra"></a>
<a name="SEC122"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_18.html#SEC121" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC123" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_18.html#SEC120" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 19. Lineare Algebra </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC123">19.1 Einf&uuml;hrung in die lineare Algebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC127">19.2 Funktionen und Variablen der linearen Algebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-die-lineare-Algebra"></a>
<a name="SEC123"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC122" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC124" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC122" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.1 Einf&uuml;hrung in die lineare Algebra </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC124">19.1.1 Nicht-kommutative Multiplikation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC125">19.1.2 Vektoren</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC126">19.1.3 Eigenwerte</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><a name="dot"></a>
</p><hr size="6">
<a name="Nicht_002dkommutative-Multiplikation"></a>
<a name="SEC124"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC123" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC125" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC123" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 19.1.1 Nicht-kommutative Multiplikation </h3>


<p>Der Operator <code>.</code> repr&auml;sentiert die nichtkommutative Multiplikation oder
das Skalarprodukt. Sind die Argumente 1-spaltige oder 1-reihige Matrizen
<code>a</code> und <code>b</code>, dann ist der Ausdruck <code>a . b</code> &auml;quivalent zu
<code>sum(a[i]*b[i], i, 1, length(a))</code>. Sind <code>a</code> und <code>b</code> nicht
komplex, dann ist der vorhergende Ausdruck das Skalarprodukt von <code>a</code> und
<code>b</code>. Das Skalarprodukt ist als <code>conjugate(a) . b</code> definiert, wenn
<code>a</code> und <code>b</code> komplex sind. Die Funktion <code><a href="#innerproduct">innerproduct</a></code> im Paket
<code>eigen</code> stellt das komplexe Skalarprodukt zur Verf&uuml;gung.
</p>

<p>Sind die Argumente <code>a</code> und <code>b</code> allgemeine Matrizen, dann ist das
Ergebnis der nichtkommutativen Multiplikation das Matrizprodukt der Argumente. 
Die Anzahl der Zeilen der Matrix <code>b</code> muss gleich der Anzahl der Spalten der
Matrix <code>a</code> sein. Das Ergebnis ist eine Matrix, deren Anzahl der Zeilen der 
der Matrix <code>a</code> entspricht und deren Anzahl der Spalten der der Matrix 
<code>b</code> entspricht.
</p>

<p>Um den nichtkommutativen Operator <code>.</code> vom Dezimalpunkt einer Gleitkommazahl
zu unterscheiden, kann es notwendig sein, dem Operator ein Leerzeichen 
voranzustellen und folgen zu lassen. Zum Beispiel ist <code>5.e3</code> die 
Gleitkommazahl <code>5000.0</code> und <code>5 .  e3</code> ist <code>5</code> multipliziert mit
der Variablen <code>e3</code>.
</p>

<p>Verschiedene Schalter kontrollieren die Vereinfachung der nichtkommutativen
Multiplikation. Zu diesen geh&ouml;ren:
</p>
<pre class="verbatim">   dot            dot0nscsimp     dot0simp
   dot1simp       dotassoc        dotconstrules
   dotdistrib     dotexptsimp     dotident
   dotscrules
</pre>
<hr size="6">
<a name="Vektoren"></a>
<a name="SEC125"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC124" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC123" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 19.1.2 Vektoren </h3>


<p><code>vect</code> ist ein Paket mit Funktionen der Vektoranalysis.  Mit dem Kommando
<code>load(vect)</code> wird das Paket geladen.  Das Kommando <code>demo(vect)</code> zeigt
Beispiele.
</p>

<p>Das Paket enth&auml;lt Funktionen, um Ausdr&uuml;cke mit nicht-kommutativen 
Multiplikationen und Kreuzprodukten sowie Gradienten, Divergenzen, Rotationen
und Laplace-Operatoren zu vereinfachen.  Die Vereinfachung dieser Operatoren
wird von verschiedenen Schaltern kontrolliert.  Weiterhin k&ouml;nnen die
Ergebnisse in verschiedenen Koordinatensystemen berechnet werden.  Mit weiteren 
Funktionen kann das Skalarpotential oder das Vektorpotential eines Feldes
bestimmt werden.
</p>

<p>Das Paket <code>vect</code> enth&auml;lt die folgenden Funktionen:
<code>vectorsimp</code>,
<code>scalefactors</code>,
<code>express</code>,
<code>potential</code> und
<code>vectorpotential</code>.
</p>

<hr size="6">
<a name="Eigenwerte"></a>
<a name="SEC126"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC125" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC127" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC123" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 19.1.3 Eigenwerte </h3>


<p>Das Paket <code>eigen</code> enth&auml;lt verschiedene Funktionen, um symbolisch 
Eigenwerte und Eigenvektoren zu bestimmen.  Maxima l&auml;dt dieses Paket 
automatisch, wenn eine der Funktionen dieses Pakets genutzt wird.  Das Paket 
kann auch mit dem Kommando <code>load(eigen)</code> geladen werden.
</p>

<p>Das Kommando <code>demo(eigen)</code> zeigt Beispiele f&uuml;r das Paket.  Die Beispiele
k&ouml;nnen auch mit dem Kommando <code>batch(eigen</code> angezeigt werden.  In diesem
Fall wartet Maxima zwischen den einzelnen Beispielen auf die Eingabe des
Nutzers.
</p>

<p>Das Paket <code>eigen</code> enth&auml;lt die folgenden Funktionen:
</p>
<pre class="verbatim">   innerproduct       unitvector            columnvector
   gramschmidt        eigenvalues           eigenvectors
   uniteigenvectors   similaritytransform
</pre>
<hr size="6">
<a name="Funktionen-und-Variablen-der-linearen-Algebra"></a>
<a name="SEC127"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC126" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC122" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.2 Funktionen und Variablen der linearen Algebra </h2>

<p><a name="addcol"></a>
</p><dl>
<dt><u>Funktion:</u> <b>addcol</b><i> (<var>M</var>, <var>list_1</var>, &hellip;, <var>list_n</var>)</i>
<a name="IDX926"></a>
</dt>
<dd>
<p>H&auml;ngt eine oder mehrere Spalten, die als Listen <var>list_1</var>, &hellip;, 
<var>list_n</var> &uuml;bergeben werden, an die Matrix <var>M</var> an.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addcol(M,[1,2],[x,y]);
                         [ a  b  1  x ]
(%o2)                    [            ]
                         [ c  d  2  y ]
</pre></dd></dl>

<p><a name="addrow"></a>
</p><dl>
<dt><u>Funktion:</u> <b>addrow</b><i> (<var>M</var>, <var>list_1</var>, &hellip;, <var>list_n</var>)</i>
<a name="IDX927"></a>
</dt>
<dd>
<p>H&auml;ngt eine oder mehrere Zeilen, die als Listen <var>list_1</var>, &hellip;,
<var>list_n</var> &uuml;bergeben werden, an die Matrix <var>M</var> an.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addrow(M,[1,2],[x,y]);
                            [ a  b ]
                            [      ]
                            [ c  d ]
(%o2)                       [      ]
                            [ 1  2 ]
                            [      ]
                            [ x  y ]
</pre></dd></dl>

<p><a name="adjoint"></a>
</p><dl>
<dt><u>Funktion:</u> <b>adjoint</b><i> (<var>M</var>)</i>
<a name="IDX928"></a>
</dt>
<dd>
<p>Gibt die adjungierte der Matrix <var>M</var> zur&uuml;ck.
</p></dd></dl>

<p><a name="augcoefmatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>augcoefmatrix</b><i> ([<var>eqn_1</var>, &hellip;, <var>eqn_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX929"></a>
</dt>
<dd>
<p>Gibt die erweiterte Koeffizientenmatrix f&uuml;r die Variablen <var>x_1</var>, &hellip;, 
<var>x_n</var> und dem linearen Gleichungssystem <var>eqn_1</var>, &hellip;, <var>eqn_m</var>.
Die erweiterte Koeffizientenmatrix entsteht, wenn an die Koeffizientenmatrix 
des Gleichungssystems die Spalte mit der rechten Seite des Gleichungssystems
angef&uuml;gt wird.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre></dd></dl>

<p><a name="charpoly"></a>
</p><dl>
<dt><u>Funktion:</u> <b>charpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX930"></a>
</dt>
<dd>
<p>Gibt das charakteristische Polynom der Matrix <var>M</var> f&uuml;r die Variable <var>x</var>
zur&uuml;ck.  Das charakterische Polynom wird als
<code>determinant(<var>M</var> - diagmatrix(length (<var>M</var>), <var>x</var>))</code> berechnet.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre></dd></dl>

<p><a name="coefmatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>coefmatrix</b><i> ([<var>eqn_1</var>, &hellip;, <var>eqn_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX931"></a>
</dt>
<dd>
<p>Gibt die Koeffizientenmatrix f&uuml;r die Variablen <var>x_1</var>, &hellip;, <var>x_n</var>
des linearen Gleichungssystem <var>eqn_1</var>, &hellip;, <var>eqn_m</var> zur&uuml;ck.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre></dd></dl>

<p><a name="col"></a>
</p><dl>
<dt><u>Funktion:</u> <b>col</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX932"></a>
</dt>
<dd>
<p>Gibt die <var>i</var>-te Spalte der Matrix <var>M</var> zur&uuml;ck.  Das Ergebnis ist eine
Matrix.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) M:matrix([1,2,3],[a,b,c]);
                           [ 1  2  3 ]
(%o1)                      [         ]
                           [ a  b  c ]
(%i2) col(M,2);
                              [ 2 ]
(%o2)                         [   ]
                              [ b ]
</pre></dd></dl>

<p><a name="columnvector"></a>
</p><dl>
<dt><u>Funktion:</u> <b>columnvector</b><i> (<var>L</var>)</i>
<a name="IDX933"></a>
</dt>
<dt><u>Funktion:</u> <b>covect</b><i> (<var>L</var>)</i>
<a name="IDX934"></a>
</dt>
<dd>
<p>Gibt eine Matrix mit einer Spalte zur&uuml;ck, die die Elemente der Liste <var>L</var>
enth&auml;lt.
</p>

<p><code>covect</code> ist ein Alias-Name f&uuml;r die Funktion <code>columnvector</code>.  Das 
Kommando <code>load(eigen)</code> l&auml;dt die Funktion.
</p>

<p>Beispiel:
</p>

<pre class="example">(%i1) load(eigen)$

(%i2) columnvector ([aa, bb, cc]);
                             [ aa ]
                             [    ]
(%o2)                        [ bb ]
                             [    ]
                             [ cc ]
</pre></dd></dl>

<p><a name="copymatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>copymatrix</b><i> (<var>M</var>)</i>
<a name="IDX935"></a>
</dt>
<dd>
<p>Gibt eine Kopie der Matrix <var>M</var> zur&uuml;ck.
</p>

<p>Die Zuweisung wie zum Beispiel <code>m2: m1</code> kopiert die Matrix <code>m1</code> nicht.
Wird nach dieser Zuweisung die Matrix <code>m2</code> ge&auml;ndert, wird auch die Matrix
<code>m1</code> ge&auml;ndert.  Um eine Kopie zu erhalten, muss <code>m2: copymatrix(m1)</code>
ausgef&uuml;hrt werden.
</p></dd></dl>

<p><a name="determinat"></a>
</p><dl>
<dt><u>Funktion:</u> <b>determinant</b><i> (<var>M</var>)</i>
<a name="IDX936"></a>
</dt>
<dd>
<p>Berechnet die Determinate der Matrix <var>M</var>.  Die angewendete Methode ist
vergleichbar mit dem Gau&szlig;-Verfahren.
</p>


<p><code>determinat</code> wird von den Schaltern <code>ratmx</code> und <code>sparse</code>
kontrolliert.  Haben beide Schalter den Wert <code>true</code>, wird ein spezieller
Algorithmus f&uuml;r schwachbesetzte Matrizen aufgerufen.
</p></dd></dl>

<p><a name="detout"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>detout</b>
<a name="IDX937"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>detout</code> den Wert <code>true</code>, wird die Determinate einer Matrix, f&uuml;r
die die inverse Matrix berechnet wird, aus der Matrix herausmultipliziert.
</p>

<p>Damit dieser Schalter einen Effekt hat, m&uuml;ssen die Optionsvariablen 
<code>doallmxops</code> und <code>doscmxops</code> den Wert <code>false</code> haben.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre>
</dd></dl>

<p><a name="diagmatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>diagmatrix</b><i> (<var>n</var>, <var>x</var>)</i>
<a name="IDX938"></a>
</dt>
<dd>
<p>Gibt eine <var>n</var>-dimensionale Diagonalmatrix zur&uuml;ck, deren Diagonalelemente
alle den Wert <var>x</var> haben.
</p>

<p><var>n</var> muss zu einer ganzen Zahl auswerten.  Ansonsten meldet Maxima einen
Fehler.
</p>

<p><var>x</var> kann ein beliebiger Ausdruck einschlie&szlig;lich einer Matrix sein.  Ist
<var>x</var> eine Matrix, dann wird diese nicht kopiert.
</p></dd></dl>

<p><a name="doallmxops"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>doallmxops</b>
<a name="IDX939"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>doallmxops</code> den Wert <code>true</code>, werden Matrixoperationen 
ausgef&uuml;hrt.  Ist der Wert <code>false</code>, werden nur die Matrixoperationen 
ausgef&uuml;hrt, die mit den einzelnen <code>dot</code>-Schaltern eingeschaltet sind.
</p></dd></dl>

<p><a name="domexpt"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>domxexpt</b>
<a name="IDX940"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>domxexpt</code> den Wert <code>true</code>, wird die Exponentiation
<code>exp(<var>M</var>)</code>, wobei <var>M</var> eine Matrix ist, elementweise f&uuml;r jedes
einzelne Matrixelement ausgef&uuml;hrt, so dass f&uuml;r jedes Element der Matrix 
gilt <code>exp (m[i,j])</code>.  Ansonsten wird die Exponentiation als
<code>exp (<var>ev(M)</var></code> ausgewertet.
</p>

<p><code>domxexpt</code> beeinflu&szlig;t alle Ausdr&uuml;cke der Form <code><var>a</var>^<var>b</var></code>,
wobei <var>a</var> eine Konstante oder ein skalarer Ausdruck und <var>b</var> eine
Liste oder Matrix ist.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre></dd></dl>

<p><a name="domxmxops"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>domxmxops</b>
<a name="IDX941"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>domxmxops</code> den Wert <code>true</code>, werden allen Matrix-Matrix und 
Matrix-Listen-Operationen ausgef&uuml;hrt.
</p>
</dd></dl>

<p><a name="domxnctimes"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>domxnctimes</b>
<a name="IDX942"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>domxnctimes</code> den Wert <code>true</code>, werden nichtkommutative Produkte
von Matrizen ausgef&uuml;hrt.
</p>
</dd></dl>

<p><a name="doscmxops"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>doscmxops</b>
<a name="IDX943"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>doscmxops</code> den Wert <code>true</code>, werden Skalar-Matrix-Operationen
ausgef&uuml;hrt.
</p>
</dd></dl>

<p><a name="doscmxplus"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>doscmxplus</b>
<a name="IDX944"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>doscmxplus</code> den Wert <code>true</code>, haben Skalar-Matrix-Operationen
eine Matrix als Ergebnis.  Dieser Schalter ist nicht unter <code>doallmxops</code>
subsumiert.
</p>
</dd></dl>

<p><a name="dot0nscsimp"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dot0nscsimp</b>
<a name="IDX945"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot0nscsimp</code> den Wert <code>true</code>, werden nichtkommutative Produkte
mit einer Null und einem nichtskalaren Term zu einem kommutativen Produkt
vereinfacht.
</p>
</dd></dl>

<p><a name="dot0simp"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dot0simp</b>
<a name="IDX946"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot0simp</code> den Wert <code>true</code>, werden nichtkommutative Produkte mit
einer Null und einem skalaren Term zu einem kommutatitiven Produkt vereinfacht.
</p>
</dd></dl>

<p><a name="dot1simp"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dot1simp</b>
<a name="IDX947"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot1simp</code> den Wert <code>true</code>, werden nichtkommutative Produkte mit
einer Eins und einem anderen Term zu einem kommutativen Produkt vereinfacht.
</p>
</dd></dl>

<p><a name="dotassoc"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotassoc</b>
<a name="IDX948"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotassoc</code> den Wert <code>true</code>, vereinfacht Maxima ein Ausdruck
<code>(A.B).C</code> zu <code>A.(B.C)</code>.
</p>
</dd></dl>

<p><a name="dotconstrules"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotconstrules</b>
<a name="IDX949"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotconstrules</code> den Wert <code>true</code>, werden nichtkommutative Produkte
einer Konstanten und eines Termes zu einem kommutativen Produkt vereinfacht.
Die folgenden Optionsvariablen <code>dot0simp</code>, <code>dot0nscsimp</code> und 
<code>dot1simp</code> erhalten den Wert <code>true</code>, wenn <code>construles</code> 
eingeschaltet wird.
</p>
</dd></dl>

<p><a name="dotdistrib"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotdistrib</b>
<a name="IDX950"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>dotdistrib</code> den Wert <code>true</code>, vereinfacht Maxima einen Ausdruck
<code>A.(B + C)</code> zu <code>A.B + A.C</code>.
</p>
</dd></dl>

<p><a name="dotexptsimp"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotexptsimp</b>
<a name="IDX951"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotexptsimp</code> den Wert <code>true</code>, vereinfacht Maxima einen Ausdruck 
<code>A.A</code> zu <code>A^^2</code>.
</p>
</dd></dl>

<p><a name="dotident"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotident</b>
<a name="IDX952"></a>
</dt>
<dd><p>Standardwert: 1
</p>

<p><code>dotident</code> ist der Wert der f&uuml;r den Ausdruck <code>X^^0</code> zur&uuml;ckgegeben 
wird.
</p>
</dd></dl>

<p><a name="dotscrules"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dotscrules</b>
<a name="IDX953"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>dotscrules</code> den Wert <code>true</code>, vereinfacht Maxima Ausdr&uuml;cke 
<code>A.SC</code> oder <code>SC.A</code> zu <code>SC*A</code> und <code>A.(SC*B)</code> zu 
<code>SC*(A.B)</code>.
</p>
</dd></dl>

<p><a name="echelon"></a>
</p><dl>
<dt><u>Funktion:</u> <b>echelon</b><i> (<var>M</var>)</i>
<a name="IDX954"></a>
</dt>
<dd>
<p>Gibt die Matrix <var>m</var> in ihrer Stufenform zur&uuml;ck, wie sie im Gau&szlig;schen
Eliminationsverfahren auftritt.
</p>

<p>Im Unterschied zur Funktion <code>triangularize</code> wird die Matrix so normiert,
dass die Hauptdiagonalelemente den Wert 1 haben.
</p>

<p><code>lu_factor</code> und <code>cholesky</code> sind weitere Funktionen, um 
Dreiecksmatrizen zu erhalten.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre></dd></dl>

<p><a name="eigenvalues"></a>
</p><dl>
<dt><u>Funktion:</u> <b>eigenvalues</b><i> (<var>M</var>)</i>
<a name="IDX955"></a>
</dt>
<dt><u>Funktion:</u> <b>eivals</b><i> (<var>M</var>)</i>
<a name="IDX956"></a>
</dt>
<dd>

<p>Gibt eine Liste mit den Eigenwerten der Matrix <var>M</var> und deren
Multiplizit&auml;ten zur&uuml;ck.  Die erste Teilliste enth&auml;lt die Eigenwerte, die
zweite deren Multiplizit&auml;ten.
</p>

<p><code>eivals</code> ist ein Alias-Name der Funktion <code>eigenvalues</code>.
</p>

<p><code>eigenvalues</code> ruft die Funktion <code>solve</code> auf, um die Nullstellen des
charakeristischen Polynoms der Matrix zu finden.  Wenn <code>solve</code> keine
Nullstellen finden kann, funktionieren einige Funktionen des Pakets nicht.
Dies trifft nicht auf die Funktionen <code>innerproduct</code>, <code>unitvector</code>, 
<code>columnvector</code> und <code>gramschmidt</code> zu.
</p>

<p>Die Eigenwerte, die <code>solve</code> findet, k&ouml;nnen sehr komplizierte Ausdr&uuml;cke 
sein.  Es kann m&ouml;glich sein, solche Ausdr&uuml;cke weiter zu vereinfachen.
</p>

<p>Das Paket <code>eigen</code> wird automatisch geladen, wenn eine der Funktionen
<code>eigenvalues</code> oder <code>eigenvectors</code> aufgerufen wird.
</p>
</dd></dl>

<p><a name="eigenvectors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>eigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX957"></a>
</dt>
<dt><u>Funktion:</u> <b>eivects</b><i> (<var>M</var>)</i>
<a name="IDX958"></a>
</dt>
<dd>
<p>Berechnet die Eigenvektoren der Matrix <var>M</var>.  Die R&uuml;ckgabe ist eine Liste, 
die zwei weitere Listen enth&auml;lt.  Die erste Liste enth&auml;lt die Eigenwerte der
Matrix <var>m</var> und deren Multiplizit&auml;ten.  Die zweite Liste enth&auml;lt die
Eigenvektoren.
</p>

<p><code>eivects</code> ist ein Alias-Name der Funktion <code>eigenvectors</code>.
</p>

<p>Das Paket <code>eigen</code> wird automatisch geladen, wenn die Funktionen
<code>eigenvalues</code> oder <code>eigenvectors</code> aufgerufen werden.
</p>

<p>Folgende Schalter kontrollieren <code>eigenvectors</code>:
</p>
<dl compact="compact">
<dt> <code>nondiagonalizable</code></dt>
<dd><p><code>nondiagonalizabel</code> hat den Wert <code>true</code> oder <code>false</code> nach
R&uuml;ckkehr der Funktion <code>eigenvectros</code> abh&auml;ngig davon, ob die Matrix 
diagonalisierbar ist oder nicht.
</p>

</dd>
<dt> <code>hermitianmatrix</code></dt>
<dd><p>Hat <code>hermitianmatrix</code> den Wert <code>true</code>, werden die entarteten
Eigenvektoren einer Hermitischen Matrix mit dem Gram-Schmidt-Verfahren 
orthogonalisiert.
</p>

</dd>
<dt> <code>knowneigvals</code></dt>
<dd><p>Hat <code>knowneigvals</code> den Wert <code>true</code>, werden die Eigenwerte der Matrix 
von den Funktionen des Paketes <code>eigen</code> als bekannt angenommen.  Die
Eigenwerte sind in diesem Fall in der Liste <code>listeigvals</code> abgespeichert.
Die Liste <code>listeigvals</code> muss dieselbe Form haben, wie die R&uuml;ckgabe der
Funktion <code>eigenvalues</code>.
</p>
</dd>
</dl>


<p>Die Eigenvektoren werden von der Funktion <code>algsys</code> berechnet.  Es ist 
m&ouml;glich, dass <code>algsys</code> die Eigenvektoren nicht findet.  In diesem Fall 
k&ouml;nnen m&ouml;glicherweise zun&auml;chst die Eigenwerte bestimmt und weiter 
vereinfacht werden.  Dannach kann die Funktion <code>eigenvectors</code> mit dem 
Schalter <code>knowneigvals</code> aufgerufen werden.
</p>

<p>Siehe auch <code><a href="#eigenvalues">eigenvalues</a></code>.
</p>
<p>Beispiele:
</p>

<p>Eine Matrix, die einen Eigenvektor zu jedem Eigenwert hat.
</p>
<pre class="example">(%i1) M1 : matrix ([11, -1], [1, 7]);
                           [ 11  - 1 ]
(%o1)                      [         ]
                           [ 1    7  ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]], 
                        [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                       val  = 9 - sqrt(3)
                          1

                            mult  = 1
                                1

                    vec  = [[1, sqrt(3) + 2]]
                       1

                       val  = sqrt(3) + 9
                          2

                            mult  = 1
                                2

                    vec  = [[1, 2 - sqrt(3)]]
                       2

(%o3)                         done
</pre>

<p>Eine Matrix, die zwei Eigenvektoren zu jedem Eigenwert hat.
</p>
<pre class="example">(%i1) M1 : matrix([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], 
                  [0, 0, 0, 2]);
                         [ 0  1  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o1)                    [            ]
                         [ 0  0  2  0 ]
                         [            ]
                         [ 0  0  0  2 ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                   [[0, 0, 1, 0], [0, 0, 0, 1]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                            val  = 0
                               1

                            mult  = 2
                                1

                      vec  = [[1, 0, 0, 0]]
                         1

                            val  = 2
                               2

                            mult  = 2
                                2

               vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                  2

(%o3)                         done
</pre></dd></dl>

<p><a name="ematrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ematrix</b><i> (<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX959"></a>
</dt>
<dd>
<p>Gibt eine <var>m</var> <code>x</code> <var>n</var>-Matrix zur&uuml;ck, deren Elemente den Wert 0 
haben, bis auf das Element <code>[<var>i</var>, <var>j</var>]</code>, das den Wert <var>x</var> hat.
</p></dd></dl>

<p><a name="entermatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>entermatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX960"></a>
</dt>
<dd>
<p>Gibt eine <var>m</var> <code>x</code> <var>n</var>-Matrix zur&uuml;ck, die von der Konsole 
eingelesen wird.
</p>

<p>Ist <var>n</var> gleich <var>m</var>, fragt Maxima nach dem Typ der Matrix.  Folgende
Typen k&ouml;nnen angegeben werden: diagonal, symmetric, antisymmetric oder 
allgemein.  Dannach werden die einzelnen Elemente der Matrix abgefragt.
</p>

<p>Sind <var>n</var> und <var>m</var> voneinander verschieden, fragt Maxima nach jedem 
Element der Matrix.
</p>

<p>Die Elemente k&ouml;nnen beliebige Ausdr&uuml;cke sein, die ausgewertet werden.
<code>entermatrix</code> wertet die Argumente aus.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric 
4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre></dd></dl>

<p><a name="express"></a>
</p><dl>
<dt><u>Funktion:</u> <b>express</b><i> (<var>expr</var>)</i>
<a name="IDX961"></a>
</dt>
<dd>

<p>Expandiert Differentialoperatoren in einem Ausdruck in partielle Ableitungen.
<code>express</code> erkennt die Operatoren <code>grad</code>, <code>div</code>, <code>curl</code>, 
<code>laplacian</code> und das Kreuzprodukt <code>~</code>.
</p>

<p>Enth&auml;lt die R&uuml;ckgabe Substantivformen von Ableitungen, k&ouml;nnen diese mit 
der Funktion <code>ev</code> und den Auswertungsschaltern <code>nouns</code> oder 
<code>diff</code> ausgewertet werden.
</p>

<p>Mit dem Kommando <code>load(vect)</code> wird die Funktion geladen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) load (&quot;vect&quot;)$
(%i2) grad (x^2 + y^2 + z^2);
                              2    2    2
(%o2)                  grad (z  + y  + x )
(%i3) express (%);
       d    2    2    2   d    2    2    2   d    2    2    2
(%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
       dx                 dy                 dz
(%i4) ev (%, diff);
(%o4)                    [2 x, 2 y, 2 z]
(%i5) div ([x^2, y^2, z^2]);
                              2   2   2
(%o5)                   div [x , y , z ]
(%i6) express (%);
                   d    2    d    2    d    2
(%o6)              -- (z ) + -- (y ) + -- (x )
                   dz        dy        dx
(%i7) ev (%, diff);
(%o7)                    2 z + 2 y + 2 x
(%i8) curl ([x^2, y^2, z^2]);
                               2   2   2
(%o8)                   curl [x , y , z ]
(%i9) express (%);
       d    2    d    2   d    2    d    2   d    2    d    2
(%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
       dy        dz       dz        dx       dx        dy
(%i10) ev (%, diff);
(%o10)                      [0, 0, 0]
(%i11) laplacian (x^2 * y^2 * z^2);
                                  2  2  2
(%o11)                laplacian (x  y  z )
(%i12) express (%);
         2                2                2
        d     2  2  2    d     2  2  2    d     2  2  2
(%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
          2                2                2
        dz               dy               dx
(%i13) ev (%, diff);
                      2  2      2  2      2  2
(%o13)             2 y  z  + 2 x  z  + 2 x  y
(%i14) [a, b, c] ~ [x, y, z];
(%o14)                [a, b, c] ~ [x, y, z]
(%i15) express (%);
(%o15)          [b z - c y, c x - a z, a y - b x]
</pre></dd></dl>

<p><a name="genmatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</i>
<a name="IDX962"></a>
</dt>
<dt><u>Funktion:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</i>
<a name="IDX963"></a>
</dt>
<dt><u>Funktion:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>)</i>
<a name="IDX964"></a>
</dt>
<dd>
<p>Generiert eine Matrix aus einem Array <var>a</var>.  Das erste Element der Matrix
ist der Wert <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code> und das letzte Element der
Matrix ist <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code>.  <var>a</var> muss ein deklariertes
Array sein, dass mit der Funktion <code>array</code> definiert wurde.  Weiterhin kann
<var>a</var> ein undeklariertes Array, eine Array-Funktion oder ein lambda-Ausdruck
mit zwei Argumenten sein.
</p>

<p>Wird <var>j_1</var> nicht angegeben, nimmt Maxima an, das der Wert gleich <var>i_1</var> 
ist.  Werden beide Argumente <var>j_1</var> und <var>i_1</var> nicht angegeben, werden
die Werte zu 1 angenommen.
</p>

<p>Ist eines der Elemente <code>[i,j]</code> des Arrays nicht definiert, enth&auml;lt die
Matrix den symbolischen Wert <code><var>a</var>[i,j]</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre></dd></dl>

<p><a name="gramschmidt"></a>
</p><dl>
<dt><u>Funktion:</u> <b>gramschmidt</b><i> (<var>x</var>)</i>
<a name="IDX965"></a>
</dt>
<dt><u>Funktion:</u> <b>gramschmidt</b><i> (<var>x</var>, <var>F</var>)</i>
<a name="IDX966"></a>
</dt>
<dd>
<p>Wendet das Gram-Schmidtsche Orthogonalisierungsverfahren auf das Argument
<var>x</var> an.  <var>x</var> ist eine Matrix oder eine Liste mit Listen f&uuml;r die 
Spalten.  Das Argument <var>x</var> wird von <code>gramschmidt</code> nicht ver&auml;ndert.
<var>F</var> bezeichnet eine Funktion, die als Skalarprodukt f&uuml;r das Verfahren 
verwendet wird.  Wird <var>F</var> nicht angegeben, wird die Funktion 
<code>innerproduct</code> f&uuml;r das Skalarprodukt angewendet.
</p>

<p>Ist <var>x</var> eine Matrix, wird der Algorithmus auf die Zeilen der Matrix
angewendet.  Ist <var>x</var> eine Liste mit Listen, wird der Algorithmus auf die
Teillisten angewendet, die jeweils die gleiche Anzahl an Elementen haben
m&uuml;ssen.
</p>

<p>Jede Stufe des Verfahrens ruft die Funktion <code>factor</code> auf, um die 
Zwischenergebnisse zu vereinfachen.  Dadurch kann das Ergebnis faktorisierte
ganze Zahlen enthalten.
</p>

<p>Das Kommando <code>load(eigen)</code> l&auml;dt die Funktion.
</p>
<p>Beispiele:
</p>

<p>Das Gram-Schmidtsche Orthogonalisierungsverfahren mit <code>innerproduct</code> 
als Skalarprodukt.
</p>
<pre class="example">(%i1) load (eigen)$
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
(%o4)                       [0, 0, 0]
</pre>

<p>Das Gram-Schmidtsche Orthogonalisierungsverfahren mit einer selbstdefinierten
Funktion f&uuml;r das Skalarprodukt.
</p>
<pre class="example">(%i1) load (eigen)$
(%i2) ip (f, g) := integrate (f * g, u, a, b);
(%o2)          ip(f, g) := integrate(f g, u, a, b)
(%i3) y : gramschmidt([1, sin(u), cos(u)], ip), a=-%pi/2, b=%pi/2;
                               %pi cos(u) - 2
(%o3)              [1, sin(u), --------------]
                                    %pi
(%i4) map(ip,[y[1],y[2],y[3]],[y[2],y[3],y[1]]), a=-%pi/2, b=%pi/2;
(%o4)                       [0, 0, 0]
</pre></dd></dl>

<p><a name="ident"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ident</b><i> (<var>n</var>)</i>
<a name="IDX967"></a>
</dt>
<dd>
<p>Gibt eine <var>n</var> <code>x</code> <var>n</var>-Einheitsmatrix zur&uuml;ck.
</p></dd></dl>

<p><a name="innerproduct"></a>
</p><dl>
<dt><u>Funktion:</u> <b>innerproduct</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX968"></a>
</dt>
<dt><u>Funktion:</u> <b>inprod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX969"></a>
</dt>
<dd>
<p>Gibt das Skalarprodukt der Argumente <var>x</var> und <var>y</var> zur&uuml;ck.  Die Argument
k&ouml;nnen Listen oder 1-spaltige oder 1-reihige Matrizen sein.  Das Skalarprodukt
wird als <code>conjugate(x) . y</code> berechnet, wobei <code>.</code> der Operator der
nicht-kommutativen Multiplikation ist.
</p>

<p>Das Kommando <code>load(eigen)</code> l&auml;dt die Funktion.
</p>

<p><code>inprod</code> ist ein Alias-Name der Funktion <code>innerproduct</code>.
</p>
</dd></dl>


<p><a name="invert"></a>
</p><dl>
<dt><u>Funktion:</u> <b>invert</b><i> (<var>M</var>)</i>
<a name="IDX970"></a>
</dt>
<dd>
<p>Gibt die inverse Matrix der Matrix <var>M</var> zur&uuml;ck.  Die inverse Matrix wird
mittels der Adjunkten Matrix berechnet.
</p>

<p>Mit dieser Methode kann die inverse Matrix auch f&uuml;r gro&szlig;e Gleitkommazahlen
sowie Polynomme als Matrixelemente berechnet werden.
</p>

<p>Die Kofaktoren werden mit der Funktion <code>determinant</code> berechnet.  Hat die
Optionsvariable <code>ratmx</code> den Wert <code>true</code>, wird die inverse Matrix
daher ohne einen Wechsel der Darstellung berechnet.
</p>

<p>Die implementierte Methode ist jedoch ineffizient f&uuml;r gro&szlig;e Matrizen.
</p>

<p>Hat die Optionsvariable <code>detout</code> den Wert <code>true</code>, wird die 
Determinante als Faktor aus der Matrix herausgezogen.
</p>

<p>Die Elemente der inversen Matrix werden nicht automatisch expandiert.  Hat
<var>M</var> Polynome als Elemente, hat das Ergebnis m&ouml;glicherweise mit dem
Kommando <code>expand(invert(m)), detout</code> eine einfachere Form.  Mit der Funktion
<code>multthru</code> die Determinate in die Matrix hereinmultipliziert werden.  Die
inverse Matrix kann auch folgenderma&szlig;en berechnet werden:
</p>
<pre class="example">expand (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
</pre>

<p>Siehe auch den Operator <code>^^</code> der nicht-kommutativen Exponentiation f&uuml;r 
eine andere Methode zur Berechnung der inversen Matrix.
</p>
</dd></dl>

<dl>
<dt><u>Optionsvariable:</u> <b>lmxchar</b>
<a name="IDX971"></a>
</dt>
<dd><p>Standardwert: <code>[</code>
</p>

<p><code>lmxchar</code> ist das Zeichen, das f&uuml;r die linke Seite einer Matrix 
ausgegeben wird.  Siehe auch <code>rmxchar</code>.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre></dd></dl>

<p><a name="matrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>matrix</b><i> (<var>row_1</var>, &hellip;, <var>row_n</var>)</i>
<a name="IDX972"></a>
</dt>
<dd>
<p>Gibt eine Matrix mit den Spalten <var>row_1</var>, &hellip;, <var>row_n</var> zur&uuml;ck.
Jede Spalte ist eine Liste mit Asudr&uuml;cken.  Alle Spalten m&uuml;ssen die gleiche
L&auml;nge haben.
</p>

<p>Die Addition <code>+</code>, Subtraktion <code>-</code>, Multiplikation <code>*</code> und 
Division <code>/</code> werden elementweise ausgef&uuml;hrt, wenn die Argumente zwei 
Matrizen, ein Skalar und eine Matrix oder eine Matrix und ein Skalar sind.
Die Exponentiation <code>^</code> wird elementweise ausgef&uuml;hrt, wenn die Argumente
ein Skalar und eine Matrix oder umgekehrt sind.
</p>

<p>Die nichtkommutatie Multiplikation von Matrizen wird mit dem Operator <code>.</code>
ausgef&uuml;hrt.  Der entsprechende Operator f&uuml;r die nichtkommutative 
Exponentiation ist <code>^^</code>. F&uuml;r eine Matrix <code><var>A</var></code> ist 
<code><var>A</var> . <var>A</var> = <var>A</var>^^2</code>. <code><var>A</var>^^-1</code> ist die inverse 
Matrix, falls diese existiert.
</p>

<p>Folgende Schalter kontrollieren die Vereinfachung von Ausdr&uuml;cken, welche die
nichtkommutative Multiplikation und Matrizen enthalten:
</p>
<p><code>doallmxops</code>,
<code>domxexpt</code>,
<code>domxmxops</code>, 
<code>doscmxops</code> und 
<code>doscmxplus</code>.
</p>

<p>Weitere Optionsvariablen f&uuml;r Matrizen sind:
</p>
<p><code>lmxchar</code>, 
<code>rmxchar</code>, 
<code>ratmx</code>, 
<code>listarith</code>, 
<code>detout</code>,
<code>scalarmatrix</code> und
<code>sparse</code>.
</p>

<p>Folgende Funktionen akzeptieren Matrizen als ein Argument oder haben eine 
Matrix als R&uuml;ckgabewert: 
</p>
<p><code>eigenvalues</code>, 
<code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, 
<code>genmatrix</code>, 
<code>addcol</code>, 
<code>addrow</code>, 
<code>copymatrix</code>, 
<code>transpose</code>, 
<code>echelon</code> and
<code>rank</code>.
</p>
<p>Beispiele:
</p>

<p>Konstruiere eine Matrix mit Listen.
</p>
<pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre>

<p>Elementweise Addition zweier Matrizen.
</p>
<pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre>

<p>Elementweise Subtraktion zweier Matrizen.
</p>
<pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre>

<p>Elementweise Multiplikation zweier Matrizen.
</p>
<pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre>

<p>Elementweise Division zweier Matrizen.
</p>
<pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre>

<p>Elementweise Exponentiation einer Matrix mit einem Skalar.
</p>
<pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre>

<p>Elementweise Exponentiation eines Skalars mit einer Matrix.
</p>
<pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre>

<p>Die Exponentiation zweier Matrizen wird nicht elementweise ausgef&uuml;hrt.
</p>
<pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre>

<p>Nichtkommutative Multiplikation zweier Matrizen.
</p>
<pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre>

<p>Nichtkommutative Exponentiation einer Matrix.  Ist die Basis ein Skalar wird die
Exponentiation elementweise ausgef&uuml;hrt.  Daher haben die Operationen <code>^^</code>
und <code>^</code> f&uuml;r diesen Fall dasselbe Ergebnis.
</p>
<pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre>

<p>Berechnung der inversen Matrix mit <code>x^^-1</code>.
</p>
<pre class="example">(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre></dd></dl>

<p><a name="matrixmap"></a>
</p><dl>
<dt><u>Funktion:</u> <b>matrixmap</b><i> (<var>f</var>, <var>M</var>)</i>
<a name="IDX973"></a>
</dt>
<dd>
<p>Gibt eine Matrix mit den Elementen <code>[i,j]</code> zur&uuml;ck, die mit
<code><var>f</var>(<var>M</var>[i,j])</code> berechnet werden.
</p>

<p>Siehe auch <code>map</code>, <code>fullmap</code>, <code>fullmapl</code>, and <code>apply</code>.
</p>
</dd></dl>

<p><a name="matrixp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>matrixp</b><i> (<var>expr</var>)</i>
<a name="IDX974"></a>
</dt>
<dd>
<p>Gibt <code>true</code> zur&uuml;ck, wenn <var>expr</var> eine Matrix ist.  Ansonsten wird
<code>false</code> zur&uuml;ckgegeben.
</p></dd></dl>

<p><a name="matrix_005felement_005fadd"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>matrix_element_add</b>
<a name="IDX975"></a>
</dt>
<dd><p>Standardwert: <code>+</code>
</p>

<p><code>matrix_element_add</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung der
Addition von Matrizen.  Der Optionsvariablen <code>matrix_element_add</code> kann
ein N-Ary-Operator zugewiesen werden.  Der zugewiesene Wert kann der Name
eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.
</p>

<p>Siehe auch <code>matrix_element_mult</code> und <code>matrix_element_transpose</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre></dd></dl>

<p><a name="matrix_005felement_005fmult"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>matrix_element_mult</b>
<a name="IDX976"></a>
</dt>
<dd><p>Standardwert: <code>*</code>
</p>

<p><code>matrix_element_mult</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung der
Multiplikation von Matrizen.  Der Optionsvariablen <code>matrix_element_mult</code> 
kann ein bin&auml;rer Operator zugewiesen werden.  Der zugewiesene Wert kann der 
Name eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.
</p>

<p>Der nichtkommutative Operator <code>.</code> kann eine sinnvolle Alternative sein.
</p>

<p>Siehe auch <code>matrix_element_add</code> und <code>matrix_element_transpose</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre></dd></dl>

<p><a name="matrix_005felement_005ftranspose"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>matrix_element_transpose</b>
<a name="IDX977"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p><code>matrix_element_transpose</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung 
der Transponierung einer Matrix.  Der Optionsvariablen
<code>matrix_element_mult</code> kann ein un&auml;rer Operator zugewiesen werden.  Der 
zugewiesene Wert kann der Name eines Operators, einer Funktion oder ein
Lambda-Ausdruck sein.
</p>

<p>Hat <code>matrix_element_transpose</code> den Wert <code>transpose</code>, wird die 
Funktion <code>transpose</code> auf jedes Element der Matrix angewendet.  Hat
<code>matrix_element_transpose</code> den Wert <code>nonscalars</code>, wird die Funktion
<code>transpose</code> auf nichtskalare Elemente der Matrix angewendet.  Ist eines
der Elemente ein Atom, muss in diesem Fall das Atom als <code>nonscalar</code>
deklariert sein.
</p>

<p>Mit dem Standardwert <code>false</code> wird keine Operation angewendet.
</p>

<p>Siehe auch <code>matrix_element_add</code> und <code>matrix_element_mult</code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x)
      - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre></dd></dl>


<p><a name="mattrace"></a>
</p><dl>
<dt><u>Funktion:</u> <b>mattrace</b><i> (<var>M</var>)</i>
<a name="IDX978"></a>
</dt>
<dd>
<p>Gibt die Spur einer quadratischen Matrix <var>M</var> zur&uuml;ck.
</p>
</dd></dl>

<p><a name="minor"></a>
</p><dl>
<dt><u>Funktion:</u> <b>minor</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX979"></a>
</dt>
<dd>
<p>Gibt den Minor zu <var>i</var>, <var>j</var> der Matrix <var>M</var> zur&uuml;ck.  Die Matrix
entsteht durch Streichen der <var>i</var>-ten Spalte und <var>j</var>-ten Zeile.
</p></dd></dl>

<p><a name="ncharpoly"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ncharpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX980"></a>
</dt>
<dd>
<p>Gibt das charakteristische Polynom der Matrix <var>M</var> f&uuml;r die Variable <var>x</var>
zur&uuml;ck.  Diese Funktion ist eine Alternative zur Funktion <code>charpoly</code>.
</p>

<p>Der Algorithmus von <code>ncharpoly</code> ist vorteilhaft gegen&uuml;ber 
<code>charpoly</code>, wenn gro&szlig;e und d&uuml;nn besetzte Matrizen vorliegen.  Das 
Kommando <code>load(nchrpl</code> l&auml;dt die Funktion.
</p></dd></dl>

<p><a name="newdet"></a>
</p><dl>
<dt><u>Funktion:</u> <b>newdet</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX981"></a>
</dt>
<dd>
<p>Berechnet die Determinate der Matrix oder eines Arrays <var>M</var> mit dem
Johnson-Gentleman-Algorithmus.  Das Argument <var>n</var> ist die Ordnung.  F&uuml;r
eine Matrix ist <var>n</var> ein optionales Argument.
</p></dd></dl>

<p><a name="permanent"></a>
</p><dl>
<dt><u>Funktion:</u> <b>permanent</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX982"></a>
</dt>
<dd>
<p>Berechnet die Permanente der Matrix <var>M</var>.  Die Permanente ist &auml;hnlich der
Determinate, aber es fehlen die Vorzeichenwechsel.
</p></dd></dl>

<p><a name="rank"></a>
</p><dl>
<dt><u>Funktion:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX983"></a>
</dt>
<dd>
<p>Berechnet den Rang der Matrix <var>M</var>.
</p>

<p><var>rank</var> kann ein falsches Ergebnis geben, wenn ein Element &auml;quivalent
zu Null ist, dies aber nicht von Maxima festgestellt werden kann.
</p></dd></dl>

<p><a name="potenial"></a>
</p><dl>
<dt><u>Funktion:</u> <b>potential</b><i> (<var>givengradient</var>)</i>
<a name="IDX984"></a>
</dt>
<dd><p>The calculation makes use of the global variable <code>potentialzeroloc[0]</code>
which must be <code>nonlist</code> or of the form
</p>
<pre class="example">[indeterminatej=expressionj, indeterminatek=expressionk, ...]
</pre>
<p>the former being equivalent to the nonlist expression for all right-hand 
sides in the latter.  The indicated right-hand sides are used as the lower 
limit of integration.  The success of the integrations may depend upon their 
values and order.  <code>potentialzeroloc</code> is initially set to 0.
</p></dd></dl>

<p><a name="ratmx"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>ratmx</b>
<a name="IDX985"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>ratmx</code> den Wert <code>false</code>, werden die Berechnung einer Determinante
sowie die Operationen der Addition, Subtraktion und Multiplikation in der
allgemeinen Darstellung ausgef&uuml;hrt.  Das Ergebnis ist wieder eine allgemeine
Darstellung.
</p>

<p>Hat <code>ratmx</code> den Wert <code>true</code>, werden die oben genannten Operationen
in einer CRE-Darstellung ausgef&uuml;hrt un das Ergebnis ist in einer 
CRE-Darstellung.
</p></dd></dl>

<p><a name="rmxchar"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>rmxchar</b>
<a name="IDX986"></a>
</dt>
<dd><p>Standardwert: <code>]</code>
</p>

<p><code>rmxchar</code> ist das Zeichen, das f&uuml;r die rechte Seite einer Matrix 
ausgegeben wird.  Siehe auch <code>lmxchar</code>.
</p></dd></dl>

<p><a name="row"></a>
</p><dl>
<dt><u>Funktion:</u> <b>row</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX987"></a>
</dt>
<dd>
<p>Gibt die <var>i</var>-te Spalte der Matrix <var>M</var> zur&uuml;ck.  Der R&uuml;ckgabewert ist 
eine Matrix.
</p></dd></dl>

<p><a name="scalarmatrixp"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>scalarmatrixp</b>
<a name="IDX988"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>true</code>, dann werden 1 x 1-Matrizen, die
als Ergebnis einer nicht-kommutativen Multiplikation auftreten, zu einem
Skalar vereinfacht.
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>all</code>, dann werden alle 1 x 1-Matrizen
zu einem Skalar vereinfacht.
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>false</code>, werden 1 x 1-Matrizen nicht zu
einem Skalar vereinfacht.
</p></dd></dl>


<dl>
<dt><u>Funktion:</u> <b>scalefactors</b><i> (<var>coordinatetransform</var>)</i>
<a name="IDX989"></a>
</dt>
<dd><p>Here coordinatetransform evaluates to the form [[expression1, expression2,
&hellip;], indeterminate1, indeterminat2, &hellip;], where indeterminate1, 
indeterminate2, etc. are the curvilinear coordinate variables and where a set of
rectangular Cartesian components is given in terms of the curvilinear
coordinates by [expression1, expression2, &hellip;].  <code>coordinates</code> is set
to the vector [indeterminate1, indeterminate2, &hellip;], and <code>dimension</code> is 
set to the length of this vector.  SF[1], SF[2], &hellip;, SF[DIMENSION] are set
to the coordinate scale factors, and <code>sfprod</code> is set to the product of
these scale factors.  Initially, <code>coordinates</code> is [X, Y, Z],
<code>dimension</code> is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 
3-dimensional rectangular Cartesian coordinates.  To expand an expression into 
physical components in the current coordinate system, there is a function with 
usage of the form
</p></dd></dl>

<p><a name="setelmx"></a>
</p><dl>
<dt><u>Funktion:</u> <b>setelmx</b><i> (<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</i>
<a name="IDX990"></a>
</dt>
<dd>
<p>Weist <var>x</var> dem Matrixelement <code>[<var>i</var>,<var>j</var>]</code> zu und gibt die
modifizierte Matrix zur&uuml;ck.
</p>

<p><code><var>M</var>[<var>i</var>, <var>j</var>]: <var>x</var></code> hat denselben Effekt.  In diesem Fall
wird jedoch der Wert <var>x</var> zur&uuml;ckgeben und nicht die Matrix.
</p></dd></dl>

<p><a name="similaritytransform"></a>
</p><dl>
<dt><u>Funktion:</u> <b>similaritytransform</b><i> (<var>M</var>)</i>
<a name="IDX991"></a>
</dt>
<dt><u>Funktion:</u> <b>simtran</b><i> (<var>M</var>)</i>
<a name="IDX992"></a>
</dt>
<dd><p><code>similaritytransform</code> computes a similarity transform of the matrix 
<code>M</code>.  It returns a list which is the output of the <code>uniteigenvectors</code>
command.  In addition if the flag <code>nondiagonalizable</code> is <code>false</code> two 
global matrices <code>leftmatrix</code> and <code>rightmatrix</code> are computed.  These 
matrices have the property that <code>leftmatrix . <var>M</var> . rightmatrix</code> is a 
diagonal matrix with the eigenvalues of <var>M</var> on the diagonal.  If 
<code>nondiagonalizable</code> is <code>true</code> the left and right matrices are not 
computed.
</p>
<p>If the flag <code>hermitianmatrix</code> is <code>true</code> then <code>leftmatrix</code> is the 
complex conjugate of the transpose of <code>rightmatrix</code>.  Otherwise 
<code>leftmatrix</code> is the inverse of <code>rightmatrix</code>.
</p>
<p><code>rightmatrix</code> is the matrix the columns of which are the unit eigenvectors 
of <var>M</var>.  The other flags (see <code>eigenvalues</code> and <code>eigenvectors</code>) 
have the same effects since <code>similaritytransform</code> calls the other functions
in the package in order to be able to form <code>rightmatrix</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> loads this function.
</p>
<p><code>simtran</code> is a synonym for <code>similaritytransform</code>.
</p></dd></dl>

<p><a name="sparse"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>sparse</b>
<a name="IDX993"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Haben <code>sparse</code> und <code>ratmx</code> den Wert <code>true</code>, verwendet die 
Funktion <code>determinant</code> einen speziellen Algorithmus f&uuml;r d&uuml;nn besetzte
Matrizen, um die Determinante einer Matrix zu berechnen.
</p></dd></dl>

<p><a name="submatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>submatrix</b><i> (<var>i_1</var>, &hellip;, <var>i_m</var>, <var>M</var>, <var>j_1</var>, &hellip;, <var>j_n</var>)</i>
<a name="IDX994"></a>
</dt>
<dt><u>Funktion:</u> <b>submatrix</b><i> (<var>i_1</var>, &hellip;, <var>i_m</var>, <var>M</var>)</i>
<a name="IDX995"></a>
</dt>
<dt><u>Funktion:</u> <b>submatrix</b><i> (<var>M</var>, <var>j_1</var>, &hellip;, <var>j_n</var>)</i>
<a name="IDX996"></a>
</dt>
<dd><p>Gibt eine Kopie der Matrix <var>M</var> zur&uuml;ck, in der die Zeilen 
<var>i_1</var>, &hellip;, <var>i_m</var> und Spalten <var>j_1</var>, &hellip;, <var>j_n</var> 
nicht enthalten sind.
</p></dd></dl>

<p><a name="transpose"></a>
</p><dl>
<dt><u>Funktion:</u> <b>transpose</b><i> (<var>M</var>)</i>
<a name="IDX997"></a>
</dt>
<dd>
<p>Gibt die Transponierte der Matrix <var>M</var> zur&uuml;ck.
</p>

<p>Ist <var>M</var> eine Matrix, ist das Ergebnis eine Matrix <var>N</var> mit den 
Elementen <code>N[i,j] = M[j,i]</code>.
</p>

<p>Ist <var>M</var> eine Liste, ist die R&uuml;ckgabe eine Matrix <var>N</var> mit
<code>length(M)</code> Spalten und einer Zeile.  Die Elemente sind 
<code>N[i,1] = M[i]</code>.
</p>

<p>Ansonsten wird eine Substantivform <code>'transpose(<var>M</var>)</code> zur&uuml;ckgegeben.
</p></dd></dl>

<p><a name="triangularize"></a>
</p><dl>
<dt><u>Funktion:</u> <b>triangularize</b><i> (<var>M</var>)</i>
<a name="IDX998"></a>
</dt>
<dd>
<p>Gibt die obere Dreiecksmatrix f&uuml;r die Matrix <code>M</code> zur&uuml;ck, wie sie mit 
dem Gau&szlig;schen Eliminationsverfahren berechnet wird.  Die Dreiecksmatrix 
entspricht der R&uuml;ckgabe der Funktion <code>echelon</code> mit dem Unterschied, dass 
die Elemente auf der Diagonalen nicht zu 1 normalisiert sind.
</p>

<p>Mit den Funktionen <code>lu_factor</code> und <code>cholesky</code> kann ebenfalls eine
Matrix in die Dreiecksform transformiert werden.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre></dd></dl>

<p><a name="uniteigenvectors"></a>
</p><dl>
<dt><u>Funktion:</u> <b>uniteigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX999"></a>
</dt>
<dt><u>Funktion:</u> <b>ueivects</b><i> (<var>M</var>)</i>
<a name="IDX1000"></a>
</dt>
<dd>
<p>Berechnet die Einheitsvektoren der Matrix <var>M</var>.  Die R&uuml;ckgabe ist eine 
Liste, die zwei weitere Listen enth&auml;lt.  Die erste Liste enth&auml;lt die 
Eigenwerte der Matrix <var>M</var> und deren Multiplizit&auml;ten.  Die zweite Liste 
enth&auml;lt die Einheitsvektoren.
</p>
<p>Ansonsten entspricht <code>uniteigenvectors</code> der Funktion <code>eigenvectors</code>.
</p>




<p>Das Kommando <code>load(eigen)</code> l&auml;dt die Funktion.
</p>

<p><code>ueivects</code> ist ein Alias-Name der Funkion <code>uniteigenvectors</code>.
</p></dd></dl>

<p><a name="unitvector"></a>
</p><dl>
<dt><u>Funktion:</u> <b>unitvector</b><i> (<var>x</var>)</i>
<a name="IDX1001"></a>
</dt>
<dt><u>Funktion:</u> <b>uvect</b><i> (<var>x</var>)</i>
<a name="IDX1002"></a>
</dt>
<dd>
<p>Gibt den Einheitsvektor <em><var>x</var>/norm(<var>x</var>)</em> zur&uuml;ck.
</p>

<p>Das Kommando <code>load(eigen)</code> l&auml;dt die Funktion.
</p>

<p><code>uvect</code> ist ein Alias-Name der Funktion <code>unitvector</code>.
</p></dd></dl>

<p><a name="vectorpotential"></a>
</p><dl>
<dt><u>Funktion:</u> <b>vectorpotential</b><i> (<var>givencurl</var>)</i>
<a name="IDX1003"></a>
</dt>
<dd><p>Returns the vector potential of a given curl vector, in the current 
coordinate system.  <code>potentialzeroloc</code> has a similar role as for 
<code>potential</code>, but the order of the left-hand sides of the equations must 
be a cyclic permutation of the coordinate variables.
</p></dd></dl>


<p><a name="vectorsimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>vectorsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1004"></a>
</dt>
<dd><p>Applies simplifications and expansions according to the following global flags:
</p>
<pre class="verbatim">expandall         expanddot             expanddotplus
expandcross       expandcrossplus       expandcrosscross
expandgrad        expandgradplus        expandgradprod
expanddiv         expanddivplus         expanddivprod
expandcurl        expandcurlplus        expandcurlcurl 
expandlaplacian   expandlaplacianplus   expandlaplacianprod
</pre>
<p>All these flags have default value <code>false</code>.  The <code>plus</code> suffix refers
to employing additivity or distributivity.  The <code>prod</code> suffix refers to 
the expansion for an operand that is any kind of product.
</p>
<dl compact="compact">
<dt> <code>expandcrosscross</code></dt>
<dd><p>Simplifies <code>p ~ (q ~ r)</code> to <code>(p . r)*q - (p . q)*r</code>.
</p>
</dd>
<dt> <code>expandcurlcurl</code></dt>
<dd><p>Simplifies <code>curl curl p</code> to <code>grad div p + div grad p</code>.
</p>
</dd>
<dt> <code>expandlaplaciantodivgrad</code></dt>
<dd><p>Simplifies <code>laplacian p</code> to <code>div grad p</code>.
</p>
</dd>
<dt> <code>expandcross</code></dt>
<dd><p>Enables <code>expandcrossplus</code> and <code>expandcrosscross</code>.
</p>
</dd>
<dt> <code>expandplus</code></dt>
<dd><p align="left">Enables <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code>, and <code>expandlaplacianplus</code>.
</p>
</dd>
<dt> <code>expandprod</code></dt>
<dd><p>Enables <code>expandgradprod</code>, <code>expanddivprod</code>, and 
<code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>These flags have all been declared <code>evflag</code>.
</p>
</dd></dl>

<p><a name="vect_005fcross"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>vect_cross</b>
<a name="IDX1005"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>vect_cross</code> den Wert <code>true</code>, werden Ausdr&uuml;cke, die die 
Ableitung eines Kreuzproduktes enthalten, vereinfacht.
</p>
<p>Beispiel:
</p>
<pre class="example">(%i1) load(vect)$

(%i2) vect_cross:false;
(%o2)                         false
(%i3) diff(f(x)~g(x),x);
                        d
(%o3)                   -- (f(x) ~ g(x))
                        dx
(%i4) vect_cross:true;
(%o4)                         true
(%i5) diff(f(x)~g(x),x);
                     d                    d
(%o5)        f(x) ~ (-- (g(x))) - g(x) ~ (-- (f(x)))
                     dx                   dx
</pre></dd></dl>

<p><a name="zeromatrix"></a>
</p><dl>
<dt><u>Funktion:</u> <b>zeromatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX1006"></a>
</dt>
<dd>
<p>Gibt eine <var>m</var> x <var>n</var>-Matrix zur&uuml;ck, deren Elemente alle Null sind.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC128" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
