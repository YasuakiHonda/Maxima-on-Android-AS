<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on Oktober, 3 2017 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 25. Funktionsdefinitionen</title>

<meta name="description" content="Maxima Manual: 25. Funktionsdefinitionen">
<meta name="keywords" content="Maxima Manual: 25. Funktionsdefinitionen">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%}
-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Funktionsdefinitionen"></a>
<a name="SEC186"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC185" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC183" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Funktionsdefinitionen </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC187">25.1 Funktionen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC190">25.2 Makros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC191">25.3 Funktionen und Variablen f&uuml;r Funktionsdefinitionen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funktionen"></a>
<a name="SEC187"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC186" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC186" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Funktionen </h2>

<hr size="6">
<a name="SEC188"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC187" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC189" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Gew&ouml;hnliche Funktionen </h3>

<p>Eine Maxima-Funktion wird mit dem Operator <code><a href="maxima_7.html#g_t_003a_003d">:=</a></code> oder der Funktion
<code><a href="#define">define</a></code> definiert.  Im folgenden wird die Funktion <code>f</code> mit
dem Operator <code>:=</code> definiert:
</p>
<pre class="example">f(x) := sin(x)
</pre>
<p>Funktionen, die mit der Funktion <code><a href="#lambda">lambda</a></code> definiert werden, sind anonyme 
Funktionen, die keinen Namen haben.  Diese werden auch <code>lambda</code>-Ausdr&uuml;cke
genannt:
</p>
<pre class="example">lambda ([i, j], ...)
</pre>
<p>Anonyme Funktionen k&ouml;nnen &uuml;berall dort verwendet werden, wo eine Funktion 
als Argument erwartet wird.  Das folgende Beispiel gibt eine Liste zur&uuml;ck,
bei der jedes Element der Liste <code>L</code> mit 1 addiert wird:
</p>
<pre class="example">map (lambda ([i], i+1), L)
</pre>
<p>Ist das letzte oder einzige Argument einer Funktion eine Liste mit einem 
Element, kann eine variable Anzahl an Argumenten an die Funktion &uuml;bergeben 
werden:
</p>
<pre class="example">(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
</pre>
<p>Die rechte Seite einer Funktionsdefinition ist ein Ausdruck.  Mehrere
Ausdr&uuml;cke werden durch Kommata getrennt und mit Klammern umgeben.  Das
Ergebnis der Funktion ist der Wert des letzten Ausdrucks <code>exprn</code>:
</p>
<pre class="example">f(x) := (expr1, expr2, ...., exprn);
</pre>
<p>Ein R&uuml;cksprung mit der Anweisung <code><a href="maxima_27.html#return">return</a></code> aus einer Funktion ist 
m&ouml;glich, wenn die Definition der Funktion in einen Block eingef&uuml;gt wird.
Ein Block wird mit der <code><a href="maxima_27.html#block">block</a></code>-Anweisung definiert.  Das folgende Beispiel 
hat entweder den Wert <code>a</code> oder den Wert des Ausdrucks <var>exprn</var> als 
Ergebnis:
</p>
<pre class="example">block ([], expr1, ..., if (a &gt; 10) then return(a), ..., exprn)
</pre>
<p>Das erste paar Klammern <code>[]</code> in einem Block enth&auml;lt die Definition von 
lokalen Variablen wie zum Beispiel <code>[a: 3, b, c: []]</code>.  Die Variablen sind 
au&szlig;erhalb des Blocks nicht sichtbar.  Die Werte von globalen Variablen 
werden von den lokalen Werten &uuml;berschrieben.  Au&szlig;erhalb des Blocks haben 
die Variablen, wenn vorhanden, wieder ihre alten Werte.  Die Zuweisung der Werte
an die lokalen Variablen wird parallel ausgef&uuml;hrt.
</p>
<p>Im folgenden Beispiel wird der Wert der globalen Variablen <var>a</var> der lokalen 
Variablen <var>a</var> zugewiesen.  &Auml;nderungen von <var>a</var> im Block wirken sich 
nicht auf den globalen Wert der Variablen aus.
</p>
<pre class="example">block ([a: a], expr1, ... a: a+3, ..., exprn)
</pre>
<p>Die Anweisung <code>block ([x], ...)</code> bewirkt, dass <code>x</code> als lokale Variable
ohne einen Wert verwendet werden kann.
</p>
<p>Die Argumente einer Funktion werden in gleicher Weise wie lokal definierte
Variable behandelt.  Die folgende Definition
</p>
<pre class="example">f(x) := (expr1, ..., exprn);
</pre>
<p>mit
</p>
<pre class="example">f(1);
</pre>
<p>hat denselben Effekt wie der folgende Block:
</p>
<pre class="example">block ([x: 1], expr1, ..., exprn)
</pre>
<p>Soll die rechte Seite einer Funktionsdefinition ausgewertet werden,
kann die Funktionen <code><a href="#define">define</a></code> f&uuml;r die Definition der Funktion verwendet
werden.  Mit der Funktion <code><a href="#buildq">buildq</a></code> kann die Definition einer Funktion
konstruiert werden, wobei die Auswertung gezielt kontrolliert werden kann.
</p>
<p><a name="Array_002dFunktionen"></a>
</p><hr size="6">
<a name="SEC189"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC188" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC190" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Array-Funktionen </h3>

<p>Eine Array-Funktion speichert bei dem ersten Aufruf den Funktionswert zu dem 
Argument.  Wird die Array-Funktion mit demselben Argument aufgerufen, wird der
gespeicherte Wert zur&uuml;ckgeben, ohne diesen neu zu berechnen.  Dies wird auch
Memoisation genannt.
</p>
<p>Beispiel:
</p>
<p>Das folgende Beispiel zeigt die Definition einer Array-Funktion <code>f</code>, die
die Fakult&auml;t einer Zahl faktorisiert.  Im ersten Aufruf der Funktion mit dem
Argument <code>25000</code> wird eine Rechenzeit von etwa 24 Sekunden ben&ouml;tigt.
Der zweite Aufruf mit demselben Argument gibt sofort den abgespeicherten Wert
zur&uuml;ck.
</p>
<pre class="example">(%i1) f[x]:=factor(x!);
(%o1)                   f  := factor(x!)
                         x
(%i2) showtime:true;
Evaluation took 0.0000 seconds (0.0000 elapsed) using 0 bytes.
(%o2)                         true
(%i3) f[25000]$
Evaluation took 23.9250 seconds (26.0790 elapsed) using 3829.778 MB.
(%i4) f[25000]$
Evaluation took 0.0000 seconds (0.0000 elapsed) using 0 bytes. 
</pre>
<p>Die Namen der Array-Funktionen werden in die Informationsliste <code><a href="maxima_5.html#arrays">arrays</a></code>
und nicht in die Liste <code><a href="#functions">functions</a></code> eingetragen.  <code><a href="maxima_5.html#arrayinfo">arrayinfo</a></code> gibt eine
Liste der Argumente zur&uuml;ck, f&uuml;r die Werte gespeichert sind und 
<code><a href="maxima_5.html#listarray">listarray</a></code> gibt die Werte zur&uuml;ck.  Die Funktionen <code><a href="#dispfun">dispfun</a></code> und
<code><a href="#fundef">fundef</a></code> geben die Definition der Array-Funktion zur&uuml;ck.
</p>
<p>Beispiele:
</p>
<p>Mit dem obigen Beispiel werden die folgenden Ergebnisse ausgegeben.
</p>
<pre class="example">(%i5) arrays;
(%o5)                          [f]
(%i6) arrayinfo(f);
(%o6)                 [hashed, 1, [25000]]
(%i7) dispfun(f);
(%t7)                   f  := factor(x!)
                         x
(%o7)                         [%t7]
</pre>
<p><code><a href="maxima_5.html#arraymake">arraymake</a></code> erzeugt den Aufruf einer Array-Funktion.  Dies ist analog zu
der Funktion <code><a href="#funmake">funmake</a></code> f&uuml;r gew&ouml;hnliche Funktionen.
<code><a href="maxima_5.html#arrayapply">arrayapply</a></code> wendet eine Array-Funktion auf die Argumente an.  Dies
entspricht der Funktion <code><a href="#apply">apply</a></code> f&uuml;r gew&ouml;hnliche Funktionen.  Die
Funktion <code><a href="#map">map</a></code> hat keine Entsprechung f&uuml;r Array-Funktionen.
Vergleichbare Konstruktionen sind
<code>map(lambda([<var>x</var>], <var>a</var>[<var>x</var>]), <var>L</var>)</code> oder 
<code>makelist(<var>a</var>[<var>x</var>], <var>x</var>, <var>L</var>)</code>, wobei <var>L</var> eine Liste
ist.
</p>
<p><code><a href="maxima_5.html#remarray">remarray</a></code> entfernt die Definition einer Array-Funktion einschlie&szlig;lich 
der gespeicherten Werte.  Dies entspricht <code><a href="#remfunction">remfunction</a></code> f&uuml;r gew&ouml;hnliche
Funktionen.
</p>
<p><code>kill(<var>a</var>[<var>x</var>])</code> entfernt den f&uuml;r das Argument <var>x</var> 
gespeicherten Wert einer Array-Funktion <var>a</var>.  Beim n&auml;chsten Aufruf von 
<var>a</var> mit dem Argument <var>x</var> wird der Funktionswert neu berechnet.  Es gibt
keine M&ouml;glichkeit, alle gespeicherten Werte zu l&ouml;schen, ohne dass die
Definition der Funktion entfernt wird.  Die Kommandos <code>kill(<var>a</var>)</code> und
<code>remarray(<var>a</var>)</code> l&ouml;schen alle Werte einschlie&szlig;lich der Definition
der Funktion.
</p>
<hr size="6">
<a name="Makros"></a>
<a name="SEC190"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC189" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC186" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Makros </h2>

<p><a name="buildq"></a>
</p><dl>
<dt><u>Funktion:</u> <b>buildq</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX1406"></a>
</dt>
<dd><p>Die Variablen der Liste <var>L</var> werden in den Ausdruck <var>expr</var> substituiert.
Die Substitution wird parallel ausgef&uuml;hrt.  Das Ergebnis der Substitution wird
vereinfacht, aber nicht ausgewertet.
</p>
<p>Die Elemente der Liste <var>L</var> sind Symbole oder Zuweisungen der Form
<code><var>symbol</var>: <var>value</var></code>.  Die Zuweisungen werden parallel ausgewertet.
Der Wert einer Variablen auf der rechten Seite einer Zuweisung ist der globale
Wert in dem Kontext in dem <code>buildq</code> aufgerufen wird und nicht der lokale
Wert einer vorhergehenden Zuweisung.  Erh&auml;lt eine Variable keinen Wert, dann 
beh&auml;lt die Variable den globalen Wert.
</p>
<p>Dann werden die in der Liste <var>L</var> enthaltenen Variablen parallel in den 
Ausdruck <var>expr</var> substituiert.
</p>
<p>Enth&auml;lt <var>expr</var> Ausdr&uuml;cke der Form <code>splice(<var>x</var>)</code>, muss die 
Variable <var>x</var> eine Liste sein.  Die Liste wird in den Ausdruck eingef&uuml;gt.
Siehe auch <code><a href="#splice">splice</a></code>.
</p>
<p>Variablen in in dem Ausdruck <var>expr</var>, die nicht in <var>L</var> enthalten sind,
werden nicht durch einen Wert ersetzt, auch wenn es eine globale Variable mit
demselben Namen gibt, da der Ausdruck nicht ausgewertet wird.
</p>
<p>Beispiele:
</p>
<p>Der Variablen <code>a</code> wird der Wert zugewiesen.  Die Variable <code>b</code> erh&auml;lt
den globalen Wert.  Die Variable <code>c</code> hat keinen Wert.  Das Ergebnis ist
ein nicht ausgewerteter Ausdruck.  Die Auswertung wird mit dem 
<a href="maxima_8.html#g_t_0027_0027">Quote-Quote-Operator</a> <code>''</code> erzwungen.
</p>
<pre class="example">(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
</pre>
<p><code>e</code> ist eine Liste, die einmal als Argument der Funktion <code>foo</code>
vorliegt und zum anderen in die Argumentliste der Funktion <code>bar</code> 
eingef&uuml;gt wird.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
</pre>
<p>Das Ergebnis wird nach der Substitution vereinfacht, ansonsten h&auml;tten die
beiden folgenden Beispiele dasselbe Ergebnis.
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
</pre>
<p>Die Variablen der Liste <var>L</var> erhalten ihren Wert parallel, ansonsten w&auml;re
das erste Ergebnis <code>foo(b,b)</code>.  Substitutionen werden parallel 
ausgef&uuml;hrt.  Im Gegensatz dazu werden die Substitutionen mit der Funktion 
<code><a href="maxima_6.html#subst">subst</a></code> nacheinander ausgef&uuml;hrt.
</p>
<pre class="example">(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
              bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
             bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
</pre>
<p>Konstruktion einer Liste mit Gleichungen mit Variablen oder Ausdr&uuml;cken auf 
der linken Seite und deren Werten auf der rechten Seite.  Die Funktion
<code><a href="#macroexpand">macroexpand</a></code> expandiert das Makro <code>show_values</code>.
</p>
<pre class="example">(%i1) show_values ([L]) ::= buildq ([L], map (&quot;=&quot;, 'L, L))$
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
</pre>
<p>Konstruktion einer Funktion.
</p>
<pre class="example">(%i1) curry (f, [a]) :=
        buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
(%i2) by3 : curry (&quot;*&quot;, 3);
(%o2)        lambda([[x]], apply(*, append([3], x)))
(%i3) by3 (a + b);
(%o3)                       3 (b + a)
</pre></dd></dl>

<p><a name="macroexpand"></a>
</p><dl>
<dt><u>Funktion:</u> <b>macroexpand</b><i> (<var>expr</var>)</i>
<a name="IDX1407"></a>
</dt>
<dd><p>Ist das Argument <var>expr</var> ein Makro, wird das Makro expandiert, ohne dass es 
ausgewertet wird.  Ansonsten wird <var>expr</var> zur&uuml;ckgegeben.
</p>
<p>Ist die Expansion des Makros selbst ein Makro, wird dieses Makro wiederholt
expandiert.
</p>
<p><code>macroexpand</code> wertet das Argument <var>expr</var> nicht aus.  Hat die Expansion
des Makros Seiteneffekte, dann werden diese ausgef&uuml;hrt.
</p>
<p>Siehe auch <code><a href="maxima_7.html#g_t_003a_003a_003d">::=</a></code> und <code><a href="#macroexpand1">macroexpand1</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre></dd></dl>

<p><a name="macroexpand1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>macroexpand1</b><i> (<var>expr</var>)</i>
<a name="IDX1408"></a>
</dt>
<dd><p>Gibt die Makro-Expansion von <var>expr</var> zur&uuml;ck, ohne das Ergebnis auszuwerten.
Ist <var>expr</var> keine Makro-Funktion gibt <code>macroexpand1</code> das Argument
<var>expr</var> zur&uuml;ck.
</p>
<p><code>macroexpand1</code> wertet das Argument nicht aus.  Hat die Expansion des Makros
Seiteneffekte, dann werden diese ausgef&uuml;hrt.
</p>
<p>Enth&auml;lt die Expansion <var>expr</var> wiederum Makros, werden diese im Unterschied
zur Funktion <code>macroexpand</code> nicht expandiert.
</p>
<p>Siehe auch <code><a href="maxima_7.html#g_t_003a_003a_003d">::=</a></code> und <code><a href="#macroexpand">macroexpand</a></code>.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a))$
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre></dd></dl>

<dl>
<dt><u>Optionsvariable:</u> <b>macroexpansion</b>
<a name="IDX1409"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>
<p><code>macroexpansion</code> kontrolliert die Expansion von Makros.
</p>
<dl compact="compact">
<dt> <code>false</code></dt>
<dd><p>Die Expansion des Makros wird nicht f&uuml;r die aufrufende Funktion ersetzt.
</p>
</dd>
<dt> <code>expand</code></dt>
<dd><p>Wird die Makro-Funktion das erste Mal ausgewertet, wird die Expansion des Makros
gespeichert.  Weitere Aufrufe werten das Makro nicht erneut aus.  Seiteneffekte,
wie Zuweisungen an globale Variablen, werden nur bei der ersten Auswertung 
wirksam.  Die Expansion des Makros beeinflusst nicht andere Ausdr&uuml;cke, die das
Makro ebenfalls aufrufen.
</p>
</dd>
<dt> <code>displace</code></dt>
<dd><p>Wird die Makro-Funktion das erste mal ausgewertet, wird die Expansion des Makros
in den aufrufenden Ausdruck eingesetzt.  Weitere Aufrufe werten das Makro nicht
erneut aus.  Seiteneffekte, wie Zuweisungen an globale Variablen, werden nur bei
der ersten Auswertung wirksam.  Die Expansion des Makros beeinflusst nicht 
andere Ausdr&uuml;cke, die das Makro ebenfalls aufrufen.
</p></dd>
</dl>

<p>Beispiele:
</p>
<p>Hat <code>macroexpansion</code> den Wert <code>false</code>, wird eine Makro-Funktion
jedes mal aufgerufen, wenn der aufrufende Ausdruck ausgewertet wird.  Der
aufrufende Ausdruck wird nicht modifiziert.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Hat <code>macroexpansion</code> den Wert <code>expand</code>, wird eine Makro-Funktion nur
einmal aufgerufen.  Der aufrufende Ausdruck wird nicht modifiziert.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p>Hat <code>macroexpansion</code> den Wert <code>displace</code>, wird eine Makro-Funktion
nur einmal aufgerufen.  Der aufrufende Ausdruck wird modifiziert.
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></dd></dl>

<p><a name="macros"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>macros</b>
<a name="IDX1410"></a>
</dt>
<dd><p>Standardwert: <code>[]</code>
</p>
<p>Die Systemvariable <code>macros</code> ist eine Informationsliste, die die vom Nutzer
mit dem Operator <code><a href="maxima_7.html#g_t_003a_003a_003d">::=</a></code> definierten Makros enth&auml;lt.  Wird das Makro mit
einer der Funktionen <code><a href="maxima_4.html#kill">kill</a></code>, <code><a href="maxima_11.html#remove">remove</a></code> oder <code><a href="#remfunction">remfunction</a></code>
gel&ouml;scht, wird der Eintrag aus der Informationsliste entfernt.  Siehe auch die
Systemvariable <code><a href="maxima_4.html#infolists">infolists</a></code>.
</p></dd></dl>

<p><a name="splice"></a>
</p><dl>
<dt><u>Funktion:</u> <b>splice</b><i> (<var>a</var>)</i>
<a name="IDX1411"></a>
</dt>
<dd><p>Die Funktion <code>splice</code> kann nur im Zusammenhang mit der Funktion 
<code><a href="#buildq">buildq</a></code> verwendet werden.  Das Argument <var>a</var> bezeichnet eine Liste, die
an Stelle von <code>splice(a)</code> in einen Ausdruck eingef&uuml;gt wird.  <var>a</var> kann
nicht selbst eine Liste oder ein Ausdruck sein, der zu einer Liste auswertet.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], &quot;/&quot; (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix (&quot;&lt;&gt;&quot;, &quot;&lt;&gt;&quot;);
(%o3)                          &lt;&gt;
(%i4) buildq ([x: [1, %pi, z - y]], &quot;&lt;&gt;&quot; (splice (x)));
(%o4)                   &lt;&gt;1, %pi, z - y&lt;&gt;
</pre></dd></dl>

<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-Funktionsdefinitionen"></a>
<a name="SEC191"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC190" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC186" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.3 Funktionen und Variablen f&uuml;r Funktionsdefinitionen </h2>

<p><a name="apply"></a>
</p><dl>
<dt><u>Funktion:</u> <b>apply</b><i> (<var>F</var>, [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX1412"></a>
</dt>
<dd><p>Konstruiert den Ausdruck <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code> und 
wertet diesen aus.
</p>
<p><code>apply</code> versucht nicht Array-Funktionen von gew&ouml;hnlichen Funktionen zu
unterscheiden.  Ist <var>F</var> der Name eine Array-Funktion, wertet <code>apply</code>
den Ausdruck <code><var>F</var>(...)</code> aus.  <code><a href="maxima_5.html#arrayapply">arrayapply</a></code> entspricht der 
Funktion <code>apply</code>, wenn <var>F</var> eine Array-Funktion ist.
</p>
<p>Beispiele:
</p>
<p><code>apply</code> wertet die Argumente aus.  In diesem Beispiel wird die Funktion
<code><a href="maxima_10.html#min">min</a></code> auf die Liste <code>L</code> angewendet.
</p>
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre>
<p><code>apply</code> wertet die Argumente auch dann aus, wenn die Funktion <code>F</code>
die Auswertung ihrer Argumente unterdr&uuml;ckt.
</p>
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre>
<p><code>apply</code> wertet den Namen der Funktion <var>F</var> aus.  Mit dem
<a href="maxima_8.html#g_t_0027">Quote-Operator</a> <code>'</code> wird die Auswertung unterdr&uuml;ckt.
<code><a href="maxima_9.html#demoivre">demoivre</a></code> ist der Name einer globalen Optionsvariable und einer Funktion.
</p>
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre></dd></dl>

<p><a name="define"></a>
</p><dl>
<dt><u>Funktion:</u> <b>define</b><i> (<var>f</var>(<var>x_1</var>, &hellip;, <var>x_n</var>), <var>expr</var>)</i>
<a name="IDX1413"></a>
</dt>
<dt><u>Funktion:</u> <b>define</b><i> (<var>f</var>[<var>x_1</var>, &hellip;, <var>x_n</var>], <var>expr</var>)</i>
<a name="IDX1414"></a>
</dt>
<dt><u>Funktion:</u> <b>define</b><i> (funmake (<var>f</var>, [<var>x_1</var>, &hellip;, <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1415"></a>
</dt>
<dt><u>Funktion:</u> <b>define</b><i> (arraymake (<var>f</var>, [<var>x_1</var>, &hellip;, <var>x_n</var>]), <var>expr</var>)</i>
<a name="IDX1416"></a>
</dt>
<dt><u>Funktion:</u> <b>define</b><i> (ev (<var>expr_1</var>), <var>expr_2</var>)</i>
<a name="IDX1417"></a>
</dt>
<dd><p>Definiert eine Funktion mit dem Namen <var>f</var> und den Argumenten <var>x1</var>, 
&hellip;, <var>x_n</var> und der Funktionsdefinition <var>expr</var>.  <code>define</code>
wertet das zweite Argument immer aus.
</p>
<p>Ist das letzte oder einzige Argument <var>x_n</var> eine Liste mit einem Element, 
dann akzeptiert die Funktion eine variable Anzahl an Argumenten.  Die Argumente
der Funktion werden nacheinander den Variablen <var>x_1</var>, &hellip;, <var>x_(n-1)</var>
zugewiesen.  Sind weitere Argumente vorhanden, werden diese als Liste der
Variablen <var>x_n</var> zugewiesen.
</p>
<p>Ist das erste Argument der Funktion <code>define</code> ein Ausdruck der Form
<code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> oder <code><var>f</var>[<var>x_1</var>, ...,
<var>x_n</var>]</code> werden die Argumente der Funktion ausgewertet, aber nicht die
Funktion <var>f</var> selbst.  <var>f</var> wird auch dann nicht ausgewertet, wenn es
bereits eine Funktion mit dem Namen <var>f</var> gibt.
</p>
<p>Das erste Argument wird dann ausgewertet, wenn es ein Ausdruck mit den 
Funktionen <code><a href="#funmake">funmake</a></code>, <code><a href="maxima_5.html#arraymake">arraymake</a></code> oder <code><a href="maxima_8.html#ev">ev</a></code> ist.
</p>
<p>Alle Funktionsdefinitionen treten in demselben Namensraum auf.  Die Definition
einer Funktion <code>g</code> innerhalb einer Funktion <code>f</code> f&uuml;hrt nicht 
automatisch zu einer lokalen Definition.  Um eine lokale Funktion zu erhalten,
kann <code>lokal(g)</code> innerhalb der Funktion <code>f</code> ausgef&uuml;hrt werden.
Siehe auch <code><a href="maxima_27.html#local">local</a></code>.
</p>
<p>Ist eines der Argumente <var>x_k</var> nach der Auswertung ein quotiertes Symbol,
wertet die mit <code>define</code> definierte Funktion das Argument nicht aus.
Alle weiteren Argumente der Funktion werden ausgewertet.
</p>
<p>Siehe auch <code><a href="maxima_7.html#g_t_003a_003d">:=</a></code> und <code><a href="maxima_7.html#g_t_003a_003a_003d">::=</a></code>.
</p>
<p>Beispiele:
</p>
<p><code>define</code> wertet das zweite Argument aus.
</p>
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre>

<p>Mit <code>define</code> k&ouml;nnen gew&ouml;hnliche Maxima-Funktionen und Array-Funktionen 
definiert werden.
</p>
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre>
<p>Ist das letzte oder einzige Argument <var>x_n</var> eine Liste mit einem Element,
akzeptiert die mit <code>define</code> definierte Funktion eine variable Anzahl an
Argumenten.
</p>
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre>
<p>Ist das erste Argument ein Ausdruck mit den Funktionen <code>funmake</code>,
<code>arraymake</code> oder <code>ev</code> wird das Argument ausgewertet.
</p>
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre></dd></dl>

<p><a name="define_005fvariable"></a>
</p><dl>
<dt><u>Funktion:</u> <b>define_variable</b><i> (<var>name</var>, <var>default_value</var>, <var>mode</var>)</i>
<a name="IDX1418"></a>
</dt>
<dd><p>Definiert eine globale Variable in der Maxima-Umgebung.  <code>define_variable</code>
ist n&uuml;tzlich f&uuml;r das Schreiben von Paketen, die h&auml;ufig &uuml;bersetzt oder 
kompiliert werden.  <code>define_variable</code> f&uuml;hrt die folgenden Schritte aus:
</p>
<ol>
<li>
<code>mode_declare(<var>name</var>, <var>mode</var>)</code> deklariert den Typ der Variablen
<var>name</var> f&uuml;r den &Uuml;bersetzer.  Siehe <code><a href="maxima_28.html#mode_005fdeclare">mode_declare</a></code> f&uuml;r eine Liste 
der m&ouml;glichen Typen.

</li><li>
Hat die Variable keinen Wert, wird der Variablen der Wert <var>default_value</var>
zugewiesen.

</li><li>
<code>declare(<var>name</var>, special)</code> deklariert die Variable als Special.

</li><li>
Ordnet der Variablen <var>name</var> eine Testfunktion zu, um sicherzustellen, dass 
der Variablen nur Werte zugewiesen werden k&ouml;nnen.
</li></ol>

<p>Einer mit <code>define_variable</code> definierten Variablen, die einen anderen Typ 
als <code>any</code> erhalten hat, kann die Eigenschaft <code>value_check</code> zugewiesen
werden.  Die <code>value_check</code>-Eigenschaft ist eine Aussagefunktion mit einer
Variablen oder ein Lambda-Ausdruck, die aufgerufen werden, wenn der Variablen
ein Wert zugewiesen werden soll.  Das Argument der <code>value_check</code>-Funktion
ist der Wert, den die Variable erhalten soll.
</p>
<p><code>define_variable</code> wertet <code>default_value</code> aus.  Die Argumente 
<code>name</code> und <code>mode</code> werden nicht ausgewertet.  <code>define_variable</code>
gibt den aktuellen Wert der Variable <code>name</code> zur&uuml;ck.  Dieser ist
<code>default_value</code>, wenn der Variablen bisher kein Wert zugewiesen wurde.
</p>
<p>Beispiele:
</p>
<p><code>foo</code> ist eine boolesche Variable mit dem Wert <code>true</code>.
</p>
<pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre>
<p><code>bar</code> ist eine Variable mit dem Typ einer ganzen Zahl, die eine Primzahl
sein muss.
</p>
<pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre>
<p><code>baz_quux</code> ist eine Variable, der kein Wert zugewiesen werden kann.  Der
Typ <code>any_check</code> ist vergleichbar mit <code>any</code>.  Aber <code>any_check</code> 
ruft im Gegensatz zu <code>any</code> den <code>value_check</code>-Mechanismus auf.
</p>
<pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
                 error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre></dd></dl>

<p><a name="dispfun"></a>
</p><dl>
<dt><u>Funktion:</u> <b>dispfun</b><i> (<var>f_1</var>, &hellip;, <var>f_n</var>)</i>
<a name="IDX1419"></a>
</dt>
<dt><u>Funktion:</u> <b>dispfun</b><i> (all)</i>
<a name="IDX1420"></a>
</dt>
<dd><p>Zeigt die Definitionen der nutzerdefinierten Funktionen <var>f_1</var>, &hellip;, 
<var>f_n</var> an.  Die Argumente k&ouml;nnen gew&ouml;hnliche Funktionen, Makros, 
Array-Funktionen oder indizierte Funktionen sein.
</p>
<p><code>dispfun(all)</code> zeigt die Definitionen aller nutzerdefinierten Funktionen
an, die in den Informationslisten <code><a href="#functions">functions</a></code>, <code><a href="maxima_5.html#arrays">arrays</a></code> oder
<code><a href="#macros">macros</a></code> enthalten sind.
</p>
<p><code>dispfun</code> erzeugt Zwischenmarken <code>%t</code> f&uuml;r jede einzelne anzuzeigende
Funktion und weist die Funktionsdefinitionen den Zwischenmarken zu.  Im 
Gegensatz dazu, zeigt die Funktion <code><a href="#fundef">fundef</a></code> die Funktionsdefinition ohne
Zwischenmarken an.
</p>
<p><code>dispfun</code> wertet die Argumente nicht aus.  <code>dispfun</code> gibt eine Liste
mit den Zwischenmarken zur&uuml;ck, die zu den angezeigten Funktionen geh&ouml;ren.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre></dd></dl>

<p><a name="fullmap"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fullmap</b><i> (<var>f</var>, <var>expr_1</var>, &hellip;)</i>
<a name="IDX1421"></a>
</dt>
<dd><p>Die Funktion <code>fullmap</code> ist vergleichbar mit der Funktion <code><a href="#map">map</a></code>.
Im  Unterschied zu der Funktion <code>map</code> kann <code>fullmap</code> auf
verschachtelte Ausdr&uuml;cke angewendet werden.
</p>
<p>Intern wird <code>fullmap</code> von Maxima f&uuml;r die Vereinfachung von Matrizen 
aufgerufen.  Daher k&ouml;nnen bei der Vereinfachung von Matrizen Fehlermeldungen 
im Zusammenhang mit <code>fullmap</code> auftreten, ohne dass die Funktion direkt 
aufgerufen wurde.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre></dd></dl>

<p><a name="fullmapl"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fullmapl</b><i> (<var>f</var>, <var>list_1</var>, &hellip;)</i>
<a name="IDX1422"></a>
</dt>
<dd><p>Die Funktion <code>fullmapl</code> ist vergleichbar mit <code><a href="#fullmap">fullmap</a></code>.
<code>fullmapl</code> kann jedoch nur auf Matrizen und Listen angewendet werden kann.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre></dd></dl>

<p><a name="functions"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>functions</b>
<a name="IDX1423"></a>
</dt>
<dd><p>Standardwert: <code>[]</code>
</p>
<p><code>functions</code> ist eine Informationsliste, die die vom Nutzer mit dem
Operator <code><a href="maxima_7.html#g_t_003a_003d">:=</a></code> oder der Funktion <code><a href="#define">define</a></code> definierten Funktionen
enth&auml;lt.  Siehe auch die Systemvariable <code><a href="maxima_4.html#infolists">infolists</a></code>.
</p>
<p>Array-Funktionen und indizierte Funktionen werden nicht in die Informationsliste
<code><a href="#functions">functions</a></code>, sondern in die Informationsliste <code><a href="maxima_5.html#arrays">arrays</a></code>
eingetragen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre></dd></dl>

<p><a name="fundef"></a>
</p><dl>
<dt><u>Funktion:</u> <b>fundef</b><i> (<var>f</var>)</i>
<a name="IDX1424"></a>
</dt>
<dd><p>Gibt die Definition der Funktion <var>f</var> zur&uuml;ck.
</p>
<p>Das Argument <var>f</var> kann eine gew&ouml;hnliche Funktion, eine Makro-Funktion, eine
Array-Funktion oder eine indizierte Funktion sein.
</p>
<p><code>fundef</code> wertet das Argument aus.  Siehe auch <code><a href="#dispfun">dispfun</a></code>.
</p></dd></dl>

<p><a name="funmake"></a>
</p><dl>
<dt><u>Funktion:</u> <b>funmake</b><i> (<var>F</var>, [<var>arg_1</var>, &hellip;, <var>arg_n</var>])</i>
<a name="IDX1425"></a>
</dt>
<dd><p>Gibt den Ausdruck <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code> zur&uuml;ck.  Die
R&uuml;ckgabe wird vereinfacht, aber nicht ausgewertet.  Die Funktion <var>F</var> wird
also nicht aufgerufen, auch wenn diese existiert.
</p>
<p><code>funmake</code> versucht nicht, Array-Funktionen von gew&ouml;hnlichen Funktionen zu 
unterscheiden.  Ist <var>F</var> der Name einer Array-Funktion, dann gibt
<code>funmake</code> einen Ausdruck der Form <code><var>F</var>(...)</code> zur&uuml;ck.
F&uuml;r Array-Funktionen kann die Funktion <code><a href="maxima_5.html#arraymake">arraymake</a></code> verwendet werden.
</p>
<p><code>funmake</code> wertet die Argumente aus.
</p>
<p>Beispiele:
</p>
<p><code>funmake</code> angewendet auf eine gew&ouml;hnliche Funktion.
</p>
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre>
<p><code>funmake</code> angewendet auf ein Makro.
</p>
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre>
<p><code>funmake</code> angewendet auf eine indizierte Funktion.
</p>
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre>
<p><code>funmake</code> angewendet auf ein Symbol, welches keine Funktion 
repr&auml;sentiert.
</p>
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre>
<p><code>funmake</code> wertet die Argumente, aber nicht die R&uuml;ckgabe aus.
</p>
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre>
<p>Maxima vereinfacht den R&uuml;ckgabewert der Funktion <code>funmake</code>.
</p>
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre></dd></dl>

<p><a name="lambda"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lambda</b><i> ([<var>x_1</var>, &hellip;, <var>x_m</var>], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1426"></a>
</dt>
<dt><u>Funktion:</u> <b>lambda</b><i> ([[<var>L</var>]], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1427"></a>
</dt>
<dt><u>Funktion:</u> <b>lambda</b><i> ([<var>x_1</var>, &hellip;, <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1428"></a>
</dt>
<dd><p>Definiert einen Lambda-Ausdruck, der auch als anonyme Funktion bezeichnet wird,
und gibt diesen zur&uuml;ck.  Die Funktion kann Argumente <var>x_1</var>, &hellip;,
<var>x_m</var> und optionale Argumente <var>L</var> haben.  Die R&uuml;ckgabe der Funktion
ist das Ergebnis des Ausdrucks <var>exprn</var>.  Ein Lambda-Ausdruck kann einer
Variablen zugewiesen werden und wertet wie eine gew&ouml;hnliche Funktion aus.  Ein
Lambda-Ausdruck kann an solchen Stellen verwendet werden, wo der Name einer
Funktion erwartet wird.
</p>
<p>Wird der Lambda-Ausdruck ausgewertet, werden lokale Variablen <var>x_1</var>, 
&hellip;, <var>x_m</var> erzeugt.  <code>lambda</code> kann innerhalb von Bl&ouml;cken oder 
anderen Lambda-Ausdr&uuml;cken verwendet werden.  Mit jeder <code>block</code>-Anweisung 
oder jedem Lambda-Ausdruck werden erneut lokale Variablen erzeugt.  Die lokalen
Variablen sind jeweils global zu jeder eingeschlossenen <code>block</code>-Anweisung
oder zu jedem eingeschlossenen Lambda-Ausdruck.  Ist eine Variable innerhalb von
<code>block</code> oder <code>lambda</code> nicht lokal, hat sie den Wert der 
n&auml;chst h&ouml;heren Anweisung, die ihr einen Wert gibt oder den globalen Wert der 
Maxima-Umgebung.
</p>
<p>Nachdem die lokalen Variablen erzeugt sind, werden die Ausdr&uuml;cke <var>expr_1</var>,
&hellip;, <var>expr_n</var> nacheinander ausgewertet.  Die Systemvariable <code>%%</code>,
welche das Ergebnis eines vorhergehendes Ausdrucks enth&auml;lt, kann verwendet 
werden.  In einem Lambda-Ausdruck k&ouml;nnen die Anweisungen <code><a href="maxima_27.html#catch">catch</a></code> und
<code><a href="maxima_27.html#throw">throw</a></code> verwendet werden.
</p>
<p>Die <code><a href="maxima_27.html#return">return</a></code>-Anweisung kann in einem Lambda-Ausdruck nur verwendet werden,
wenn sie von einer <code>block</code>-Anweisung eingeschlossen wird.  Die 
<code>return</code>-Anweisung definiert jedoch den R&uuml;ckgabewert des Blocks und nicht 
des Lambda-Ausdrucks.  Auch die <code><a href="maxima_27.html#go">go</a></code>-Anweisung kann in einem
Lambda-Ausdrucks nur in einem Block verwendet werden.
</p>
<p><code>lambda</code> wertet die Argumente nicht aus.
</p>
<p>Beispiele:
</p>
<p>Ein Lambda-Ausdruck kann einer Variablen zugewiesen werden und wie eine
gew&ouml;hnliche Funktion ausgewertet werden.
</p>
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre>
<p>Ein Lamda-Ausdruck kann an Stellen verwendet werden, wo der Name einer Funktion
erwartet wird.
</p>
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre>
<p>Die Argumente sind lokale Variablen.  Andere Variablen sind globale Variablen.
Globale Variablen werden zu dem Zeitpunkt ausgewertet, wenn der Lambda-Ausdruck
ausgewertet wird.
</p>
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre>
<p>Lambda-Ausdr&uuml;cke k&ouml;nnen verschachtelt werden.  Lokale Variablen eines
&auml;u&szlig;eren Lambda-Ausdrucks sind global zu den enthaltenen
Lambda-Ausdr&uuml;cken, au&szlig;er diese werden wieder als lokal erkl&auml;rt.
</p>
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre>
<p>Da <code>lambda</code> die Argumente nicht auswertet, definiert der unten angegebene
Ausdruck <code>i</code> keine Funktion &quot;multipliziere mit <code>a</code>&quot;.  Solch eine
Funktion kann mit Hilfe der Funktion <code><a href="#buildq">buildq</a></code> definiert werden.
</p>
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre>
<p>Ein Lambda-Ausdruck kann eine variable Anzahl an Argumenten haben, wenn das
letzte Argument eine Liste mit einem Element ist.
</p>
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></dd></dl>

<p><a name="map"></a>
</p><dl>
<dt><u>Funktion:</u> <b>map</b><i> (<var>f</var>, <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1429"></a>
</dt>
<dd><p>Gibt einen Ausdruck zur&uuml;ck, dessen Hauptoperator derselbe ist, wie der der
Argumente <var>expr_1</var>, &hellip;, <var>expr_n</var> aber dessen Operanden das Ergebnis
der Anwendung des Operators <var>f</var> auf die Teilausdr&uuml;cke des Ausdrucks sind.
<var>f</var> ist entweder der Name einer Funktion mit <em>n</em> Argumenten oder
ein Lambda-Ausdruck mit <em>n</em> Argumenten.
</p>
<p>Hat <code><a href="#maperror">maperror</a></code> den Wert <code>false</code>, wird die Anwendung der Funktion
<var>f</var> gestoppt, (1) wenn die Anwendung auf den k&uuml;rzesten Ausdruck 
<var>expr_i</var> beendet ist und die Ausdr&uuml;cke nicht alle dieselbe L&auml;nge haben 
oder (2) wenn die Ausdr&uuml;cke <var>expr_i</var> einen verschiedenen Typ haben.  Hat 
<code>maperror</code> den Wert <code>true</code> wird in den obigen F&auml;llen eine 
Fehlermeldung ausgegeben.
</p>

      
<p>Beispiele:
</p>
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


</pre></dd></dl>

<p><a name="mapatom"></a>
</p><dl>
<dt><u>Funktion:</u> <b>mapatom</b><i> (<var>expr</var>)</i>
<a name="IDX1430"></a>
</dt>
<dd><p>Gibt den Wert <code>true</code> zur&uuml;ck, wenn der Ausdruck <var>expr</var> von Funktionen 
die auf Argumente angewendete werden, als ein Atom betrachtet wird.  Als Atome
werden Zahlen, einschlie&szlig;lich rationaler Zahlen und gro&szlig;er 
Gleitkommazahlen, Symbole und indizierte Symbole betrachtet.
</p></dd></dl>

<p><a name="maperror"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>maperror</b>
<a name="IDX1431"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>
<p>Hat <code>maperror</code> den Wert <code>false</code>, wird die Anwendung der Funktion 
<var>f</var> gestoppt, (1) wenn die Anwendung auf den k&uuml;rzesten Ausdruck 
<var>expr_i</var> beendet ist und die Ausdr&uuml;cke nicht alle dieselbe L&auml;nge haben 
oder (2) wenn die Ausdr&uuml;cke <var>expr_i</var> einen verschiedenen Typ haben.  Hat 
<code>maperror</code> den Wert <code>true</code> wird in den obigen F&auml;llen eine 
Fehlermeldung ausgegeben.
</p></dd></dl>

<p><a name="mapprint"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>mapprint</b>
<a name="IDX1432"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>
<p>Hat <code>mapprint</code> den Wert <code>true</code>, werden verschiedene Informationen von
den Funktionen <code><a href="#map">map</a></code>, <code><a href="#maplist">maplist</a></code> und <code><a href="#fullmap">fullmap</a></code> ausgegeben.
Dies ist der Fall, wenn die Funktion <code>map</code> die Funktion <code>apply</code>
aufruft oder wenn f&uuml;r die Funktion <code>map</code> die Argumente eine verschiedene
L&auml;nge haben.
</p>
<p>Hat <code>mapprint</code> den Wert <code>false</code>, werden diese Meldungen unterdr&uuml;ckt.
</p></dd></dl>

<p><a name="maplist"></a>
</p><dl>
<dt><u>Funktion:</u> <b>maplist</b><i> (<var>f</var>, <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1433"></a>
</dt>
<dd><p>Wendet die Funktion <var>f</var> auf die Ausdr&uuml;cke <var>expr_1</var>, &hellip;, 
<var>expr_n</var> an und gibt das Ergebnis als eine Liste zur&uuml;ck.  <var>f</var> ist der 
Name einer Funktion oder ein lambda-Ausdruck.
</p>
<p>Im Unterschied zu <code>maplist</code> gibt die Funktion <code><a href="#map">map</a></code> einen Ausdruck
zur&uuml;ck, der denselben Hauptoperator wie die Ausdr&uuml;cke <var>expr_i</var> hat.
</p></dd></dl>

<p><a name="outermap"></a>
</p><dl>
<dt><u>Funktion:</u> <b>outermap</b><i> (<var>f</var>, <var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX1434"></a>
</dt>
<dd><p>Wendet die Funktion <var>f</var> auf jedes Element des &auml;u&szlig;eren Produktes der
Argumente <var>a_1</var> <code>x</code> <var>a_2</var> <code>x</code> &hellip; <code>x</code> <var>a_n</var> an. 
</p>
<p><var>f</var> ist der Name einer Funktion mit <em>n</em> Argumenten oder ein 
Lambda-Ausdruck mit <em>n</em> Argumenten.  Jedes Argument <var>a_k</var> kann eine
Liste oder verschachtelte Liste, eine Matrix oder irgendein anderer Ausdruck
sein.
</p>

<p><code>outermap</code> wertet die Argumente aus.
</p>
<p>Siehe auch <code><a href="#map">map</a></code>, <code><a href="#maplist">maplist</a></code> und <code><a href="#apply">apply</a></code>.
</p>
<p>Beispiele:
</p>
<p>Einfaches Beispiel f&uuml;r <code>outermap</code>.  Die Funktion <code>F</code> ist 
undefiniert.
</p>
<pre class="example">(%i1) outermap(F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre>
<p>Das Beispiel zeigt die R&uuml;ckgabe der Funktion <code>outermap</code> detaillierter.
Das erste, zweite und dritte Argument sind eine Matrix, eine Liste und eine
Matrix.  Der R&uuml;ckgabewert ist eine Matrix.  Jedes Element der Matrix ist eine
Liste und jedes Element der Liste ist eine Matrix.
</p>
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                   arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre>
<p><code>outermap</code> erh&auml;lt die Struktur der Argumente im Ergebnis.  Die Funktion
<code>cartesian_product</code> erh&auml;lt die Struktur der Argumente nicht.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map(lambda([L], apply(F, L)),
                     cartesian_product({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre></dd></dl>

<p><a name="remfunction"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remfunction</b><i> (<var>f_1</var>, &hellip;, <var>f_n</var>)</i>
<a name="IDX1435"></a>
</dt>
<dt><u>Funktion:</u> <b>remfunction</b><i> (all)</i>
<a name="IDX1436"></a>
</dt>
<dd><p>Hebt die Bindung der Symbole <var>f_1</var>, &hellip;, <var>f_n</var> an ihre
Funktionsdefinitionen auf.  Die Argumente k&ouml;nnen die Namen von Funktionen 
sein, die mit dem Operator <code><a href="maxima_7.html#g_t_003a_003d">:=</a></code> oder der Funktion <code><a href="#define">define</a></code> definiert
wurden sowie Makro-Funktionen, die mit dem Operator <code><a href="maxima_7.html#g_t_003a_003a_003d">::=</a></code> definiert wurden.
</p>
<p><code>remfunction(all)</code> entfernt alle Bindungen von Funktionsdefinitionen.
</p>
<p><code>remfunction</code> gibt eine Liste mit den Symbolen zur&uuml;ck, die von ihren 
Funktionsdefinitionen entbunden wurden.  <code>false</code> wird f&uuml;r die Symbole
zur&uuml;ckgegeben, f&uuml;r die es keine Funktionsdefinition gibt.
</p>
<p><code>remfunction</code> wertet die Argumente nicht aus.
</p>
<p><code>remfunction</code> kann nicht auf Array-Funktionen und indizierte Funktionen
angewendet werden.  F&uuml;r diese Funktionen kann <code><a href="maxima_5.html#remarray">remarray</a></code> verwendet
werden.
</p></dd></dl>

<p><a name="scanmap"></a>
</p><dl>
<dt><u>Funktion:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>)</i>
<a name="IDX1437"></a>
</dt>
<dt><u>Funktion:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>, bottomup)</i>
<a name="IDX1438"></a>
</dt>
<dd><p>Wendet die Funktion <var>f</var> rekursiv auf alle Teilausdr&uuml;cke in <var>expr</var> an.
Dies kann zum Beispiel verwendet werden, um einen Ausdruck vollst&auml;ndig zu 
faktorisieren.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre>
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre>
<p>Ein weiteres Beispiel f&uuml;r die Anwendung einer Funktion auf alle 
Teilausdr&uuml;cke.
</p>
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre>
<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> wendet die Funktion <var>f</var>
Bottom-up auf den Ausdruck <var>expr</var> an.
</p>

<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC186" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC192" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC410" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Viktor T. Toth</em> on <em>Oktober, 3 2017</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
